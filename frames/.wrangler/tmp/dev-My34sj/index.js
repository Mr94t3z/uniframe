var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __esm = (fn2, res) => function __init() {
  return fn2 && (res = (0, fn2[__getOwnPropNames(fn2)[0]])(fn2 = 0)), res;
};
var __commonJS = (cb, mod) => function __require2() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));

// .wrangler/tmp/bundle-KhfhM0/checked-fetch.js
function checkURL(request, init) {
  const url = request instanceof URL ? request : new URL(
    (typeof request === "string" ? new Request(request, init) : request).url
  );
  if (url.port && url.port !== "443" && url.protocol === "https:") {
    if (!urls.has(url.toString())) {
      urls.add(url.toString());
      console.warn(
        `WARNING: known issue with \`fetch()\` requests to custom HTTPS ports in published Workers:
 - ${url.toString()} - the custom port will be ignored when the Worker is published using the \`wrangler deploy\` command.
`
      );
    }
  }
}
var urls;
var init_checked_fetch = __esm({
  ".wrangler/tmp/bundle-KhfhM0/checked-fetch.js"() {
    "use strict";
    urls = /* @__PURE__ */ new Set();
    globalThis.fetch = new Proxy(globalThis.fetch, {
      apply(target, thisArg, argArray) {
        const [request, init] = argArray;
        checkURL(request, init);
        return Reflect.apply(target, thisArg, argArray);
      }
    });
  }
});

// wrangler-modules-watch:wrangler:modules-watch
var init_wrangler_modules_watch = __esm({
  "wrangler-modules-watch:wrangler:modules-watch"() {
    init_checked_fetch();
    init_modules_watch_stub();
  }
});

// node_modules/wrangler/templates/modules-watch-stub.js
var init_modules_watch_stub = __esm({
  "node_modules/wrangler/templates/modules-watch-stub.js"() {
    init_wrangler_modules_watch();
  }
});

// node_modules/abitype/dist/esm/regex.js
function execTyped(regex, string) {
  const match = regex.exec(string);
  return match?.groups;
}
var init_regex = __esm({
  "node_modules/abitype/dist/esm/regex.js"() {
    init_checked_fetch();
    init_modules_watch_stub();
  }
});

// node_modules/abitype/dist/esm/human-readable/formatAbiParameter.js
function formatAbiParameter(abiParameter) {
  let type = abiParameter.type;
  if (tupleRegex.test(abiParameter.type) && "components" in abiParameter) {
    type = "(";
    const length = abiParameter.components.length;
    for (let i = 0; i < length; i++) {
      const component = abiParameter.components[i];
      type += formatAbiParameter(component);
      if (i < length - 1)
        type += ", ";
    }
    const result = execTyped(tupleRegex, abiParameter.type);
    type += `)${result?.array ?? ""}`;
    return formatAbiParameter({
      ...abiParameter,
      type
    });
  }
  if ("indexed" in abiParameter && abiParameter.indexed)
    type = `${type} indexed`;
  if (abiParameter.name)
    return `${type} ${abiParameter.name}`;
  return type;
}
var tupleRegex;
var init_formatAbiParameter = __esm({
  "node_modules/abitype/dist/esm/human-readable/formatAbiParameter.js"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_regex();
    tupleRegex = /^tuple(?<array>(\[(\d*)\])*)$/;
  }
});

// node_modules/abitype/dist/esm/human-readable/formatAbiParameters.js
function formatAbiParameters(abiParameters) {
  let params = "";
  const length = abiParameters.length;
  for (let i = 0; i < length; i++) {
    const abiParameter = abiParameters[i];
    params += formatAbiParameter(abiParameter);
    if (i !== length - 1)
      params += ", ";
  }
  return params;
}
var init_formatAbiParameters = __esm({
  "node_modules/abitype/dist/esm/human-readable/formatAbiParameters.js"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_formatAbiParameter();
  }
});

// node_modules/abitype/dist/esm/human-readable/formatAbiItem.js
function formatAbiItem(abiItem) {
  if (abiItem.type === "function")
    return `function ${abiItem.name}(${formatAbiParameters(abiItem.inputs)})${abiItem.stateMutability && abiItem.stateMutability !== "nonpayable" ? ` ${abiItem.stateMutability}` : ""}${abiItem.outputs.length ? ` returns (${formatAbiParameters(abiItem.outputs)})` : ""}`;
  else if (abiItem.type === "event")
    return `event ${abiItem.name}(${formatAbiParameters(abiItem.inputs)})`;
  else if (abiItem.type === "error")
    return `error ${abiItem.name}(${formatAbiParameters(abiItem.inputs)})`;
  else if (abiItem.type === "constructor")
    return `constructor(${formatAbiParameters(abiItem.inputs)})${abiItem.stateMutability === "payable" ? " payable" : ""}`;
  else if (abiItem.type === "fallback")
    return "fallback()";
  return "receive() external payable";
}
var init_formatAbiItem = __esm({
  "node_modules/abitype/dist/esm/human-readable/formatAbiItem.js"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_formatAbiParameters();
  }
});

// node_modules/abitype/dist/esm/exports/index.js
var init_exports = __esm({
  "node_modules/abitype/dist/esm/exports/index.js"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_formatAbiItem();
  }
});

// node_modules/viem/_esm/utils/abi/formatAbiItem.js
function formatAbiItem2(abiItem, { includeName = false } = {}) {
  if (abiItem.type !== "function" && abiItem.type !== "event" && abiItem.type !== "error")
    throw new InvalidDefinitionTypeError(abiItem.type);
  return `${abiItem.name}(${formatAbiParams(abiItem.inputs, { includeName })})`;
}
function formatAbiParams(params, { includeName = false } = {}) {
  if (!params)
    return "";
  return params.map((param) => formatAbiParam(param, { includeName })).join(includeName ? ", " : ",");
}
function formatAbiParam(param, { includeName }) {
  if (param.type.startsWith("tuple")) {
    return `(${formatAbiParams(param.components, { includeName })})${param.type.slice("tuple".length)}`;
  }
  return param.type + (includeName && param.name ? ` ${param.name}` : "");
}
var init_formatAbiItem2 = __esm({
  "node_modules/viem/_esm/utils/abi/formatAbiItem.js"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_abi();
  }
});

// node_modules/viem/_esm/utils/data/isHex.js
function isHex(value, { strict = true } = {}) {
  if (!value)
    return false;
  if (typeof value !== "string")
    return false;
  return strict ? /^0x[0-9a-fA-F]*$/.test(value) : value.startsWith("0x");
}
var init_isHex = __esm({
  "node_modules/viem/_esm/utils/data/isHex.js"() {
    init_checked_fetch();
    init_modules_watch_stub();
  }
});

// node_modules/viem/_esm/utils/data/size.js
function size(value) {
  if (isHex(value, { strict: false }))
    return Math.ceil((value.length - 2) / 2);
  return value.length;
}
var init_size = __esm({
  "node_modules/viem/_esm/utils/data/size.js"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_isHex();
  }
});

// node_modules/viem/_esm/errors/version.js
var version;
var init_version = __esm({
  "node_modules/viem/_esm/errors/version.js"() {
    init_checked_fetch();
    init_modules_watch_stub();
    version = "2.7.16";
  }
});

// node_modules/viem/_esm/errors/utils.js
var getVersion;
var init_utils = __esm({
  "node_modules/viem/_esm/errors/utils.js"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_version();
    getVersion = () => `viem@${version}`;
  }
});

// node_modules/viem/_esm/errors/base.js
function walk(err, fn2) {
  if (fn2?.(err))
    return err;
  if (err && typeof err === "object" && "cause" in err)
    return walk(err.cause, fn2);
  return fn2 ? null : err;
}
var BaseError;
var init_base = __esm({
  "node_modules/viem/_esm/errors/base.js"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_utils();
    BaseError = class extends Error {
      constructor(shortMessage, args = {}) {
        super();
        Object.defineProperty(this, "details", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        Object.defineProperty(this, "docsPath", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        Object.defineProperty(this, "metaMessages", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        Object.defineProperty(this, "shortMessage", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "ViemError"
        });
        Object.defineProperty(this, "version", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: getVersion()
        });
        const details = args.cause instanceof BaseError ? args.cause.details : args.cause?.message ? args.cause.message : args.details;
        const docsPath2 = args.cause instanceof BaseError ? args.cause.docsPath || args.docsPath : args.docsPath;
        this.message = [
          shortMessage || "An error occurred.",
          "",
          ...args.metaMessages ? [...args.metaMessages, ""] : [],
          ...docsPath2 ? [
            `Docs: https://viem.sh${docsPath2}${args.docsSlug ? `#${args.docsSlug}` : ""}`
          ] : [],
          ...details ? [`Details: ${details}`] : [],
          `Version: ${this.version}`
        ].join("\n");
        if (args.cause)
          this.cause = args.cause;
        this.details = details;
        this.docsPath = docsPath2;
        this.metaMessages = args.metaMessages;
        this.shortMessage = shortMessage;
      }
      walk(fn2) {
        return walk(this, fn2);
      }
    };
  }
});

// node_modules/viem/_esm/errors/abi.js
var AbiEncodingArrayLengthMismatchError, AbiEncodingBytesSizeMismatchError, AbiEncodingLengthMismatchError, AbiFunctionNotFoundError, AbiItemAmbiguityError, InvalidAbiEncodingTypeError, InvalidArrayError, InvalidDefinitionTypeError;
var init_abi = __esm({
  "node_modules/viem/_esm/errors/abi.js"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_formatAbiItem2();
    init_size();
    init_base();
    AbiEncodingArrayLengthMismatchError = class extends BaseError {
      constructor({ expectedLength, givenLength, type }) {
        super([
          `ABI encoding array length mismatch for type ${type}.`,
          `Expected length: ${expectedLength}`,
          `Given length: ${givenLength}`
        ].join("\n"));
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "AbiEncodingArrayLengthMismatchError"
        });
      }
    };
    AbiEncodingBytesSizeMismatchError = class extends BaseError {
      constructor({ expectedSize, value }) {
        super(`Size of bytes "${value}" (bytes${size(value)}) does not match expected size (bytes${expectedSize}).`);
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "AbiEncodingBytesSizeMismatchError"
        });
      }
    };
    AbiEncodingLengthMismatchError = class extends BaseError {
      constructor({ expectedLength, givenLength }) {
        super([
          "ABI encoding params/values length mismatch.",
          `Expected length (params): ${expectedLength}`,
          `Given length (values): ${givenLength}`
        ].join("\n"));
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "AbiEncodingLengthMismatchError"
        });
      }
    };
    AbiFunctionNotFoundError = class extends BaseError {
      constructor(functionName, { docsPath: docsPath2 } = {}) {
        super([
          `Function ${functionName ? `"${functionName}" ` : ""}not found on ABI.`,
          "Make sure you are using the correct ABI and that the function exists on it."
        ].join("\n"), {
          docsPath: docsPath2
        });
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "AbiFunctionNotFoundError"
        });
      }
    };
    AbiItemAmbiguityError = class extends BaseError {
      constructor(x, y) {
        super("Found ambiguous types in overloaded ABI items.", {
          metaMessages: [
            `\`${x.type}\` in \`${formatAbiItem2(x.abiItem)}\`, and`,
            `\`${y.type}\` in \`${formatAbiItem2(y.abiItem)}\``,
            "",
            "These types encode differently and cannot be distinguished at runtime.",
            "Remove one of the ambiguous items in the ABI."
          ]
        });
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "AbiItemAmbiguityError"
        });
      }
    };
    InvalidAbiEncodingTypeError = class extends BaseError {
      constructor(type, { docsPath: docsPath2 }) {
        super([
          `Type "${type}" is not a valid encoding type.`,
          "Please provide a valid ABI type."
        ].join("\n"), { docsPath: docsPath2 });
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "InvalidAbiEncodingType"
        });
      }
    };
    InvalidArrayError = class extends BaseError {
      constructor(value) {
        super([`Value "${value}" is not a valid array.`].join("\n"));
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "InvalidArrayError"
        });
      }
    };
    InvalidDefinitionTypeError = class extends BaseError {
      constructor(type) {
        super([
          `"${type}" is not a valid definition type.`,
          'Valid types: "function", "event", "error"'
        ].join("\n"));
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "InvalidDefinitionTypeError"
        });
      }
    };
  }
});

// node_modules/viem/_esm/errors/data.js
var SliceOffsetOutOfBoundsError, SizeExceedsPaddingSizeError;
var init_data = __esm({
  "node_modules/viem/_esm/errors/data.js"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_base();
    SliceOffsetOutOfBoundsError = class extends BaseError {
      constructor({ offset, position, size: size2 }) {
        super(`Slice ${position === "start" ? "starting" : "ending"} at offset "${offset}" is out-of-bounds (size: ${size2}).`);
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "SliceOffsetOutOfBoundsError"
        });
      }
    };
    SizeExceedsPaddingSizeError = class extends BaseError {
      constructor({ size: size2, targetSize, type }) {
        super(`${type.charAt(0).toUpperCase()}${type.slice(1).toLowerCase()} size (${size2}) exceeds padding size (${targetSize}).`);
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "SizeExceedsPaddingSizeError"
        });
      }
    };
  }
});

// node_modules/viem/_esm/utils/data/pad.js
function pad(hexOrBytes, { dir, size: size2 = 32 } = {}) {
  if (typeof hexOrBytes === "string")
    return padHex(hexOrBytes, { dir, size: size2 });
  return padBytes(hexOrBytes, { dir, size: size2 });
}
function padHex(hex_, { dir, size: size2 = 32 } = {}) {
  if (size2 === null)
    return hex_;
  const hex3 = hex_.replace("0x", "");
  if (hex3.length > size2 * 2)
    throw new SizeExceedsPaddingSizeError({
      size: Math.ceil(hex3.length / 2),
      targetSize: size2,
      type: "hex"
    });
  return `0x${hex3[dir === "right" ? "padEnd" : "padStart"](size2 * 2, "0")}`;
}
function padBytes(bytes4, { dir, size: size2 = 32 } = {}) {
  if (size2 === null)
    return bytes4;
  if (bytes4.length > size2)
    throw new SizeExceedsPaddingSizeError({
      size: bytes4.length,
      targetSize: size2,
      type: "bytes"
    });
  const paddedBytes = new Uint8Array(size2);
  for (let i = 0; i < size2; i++) {
    const padEnd = dir === "right";
    paddedBytes[padEnd ? i : size2 - i - 1] = bytes4[padEnd ? i : bytes4.length - i - 1];
  }
  return paddedBytes;
}
var init_pad = __esm({
  "node_modules/viem/_esm/utils/data/pad.js"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_data();
  }
});

// node_modules/viem/_esm/errors/encoding.js
var IntegerOutOfRangeError, SizeOverflowError;
var init_encoding = __esm({
  "node_modules/viem/_esm/errors/encoding.js"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_base();
    IntegerOutOfRangeError = class extends BaseError {
      constructor({ max: max2, min, signed, size: size2, value }) {
        super(`Number "${value}" is not in safe ${size2 ? `${size2 * 8}-bit ${signed ? "signed" : "unsigned"} ` : ""}integer range ${max2 ? `(${min} to ${max2})` : `(above ${min})`}`);
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "IntegerOutOfRangeError"
        });
      }
    };
    SizeOverflowError = class extends BaseError {
      constructor({ givenSize, maxSize }) {
        super(`Size cannot exceed ${maxSize} bytes. Given size: ${givenSize} bytes.`);
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "SizeOverflowError"
        });
      }
    };
  }
});

// node_modules/viem/_esm/utils/data/trim.js
function trim(hexOrBytes, { dir = "left" } = {}) {
  let data = typeof hexOrBytes === "string" ? hexOrBytes.replace("0x", "") : hexOrBytes;
  let sliceLength = 0;
  for (let i = 0; i < data.length - 1; i++) {
    if (data[dir === "left" ? i : data.length - i - 1].toString() === "0")
      sliceLength++;
    else
      break;
  }
  data = dir === "left" ? data.slice(sliceLength) : data.slice(0, data.length - sliceLength);
  if (typeof hexOrBytes === "string") {
    if (data.length === 1 && dir === "right")
      data = `${data}0`;
    return `0x${data.length % 2 === 1 ? `0${data}` : data}`;
  }
  return data;
}
var init_trim = __esm({
  "node_modules/viem/_esm/utils/data/trim.js"() {
    init_checked_fetch();
    init_modules_watch_stub();
  }
});

// node_modules/viem/_esm/utils/encoding/fromHex.js
function assertSize(hexOrBytes, { size: size2 }) {
  if (size(hexOrBytes) > size2)
    throw new SizeOverflowError({
      givenSize: size(hexOrBytes),
      maxSize: size2
    });
}
var init_fromHex = __esm({
  "node_modules/viem/_esm/utils/encoding/fromHex.js"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_encoding();
    init_size();
  }
});

// node_modules/viem/_esm/utils/encoding/toHex.js
function toHex(value, opts = {}) {
  if (typeof value === "number" || typeof value === "bigint")
    return numberToHex(value, opts);
  if (typeof value === "string") {
    return stringToHex(value, opts);
  }
  if (typeof value === "boolean")
    return boolToHex(value, opts);
  return bytesToHex(value, opts);
}
function boolToHex(value, opts = {}) {
  const hex3 = `0x${Number(value)}`;
  if (typeof opts.size === "number") {
    assertSize(hex3, { size: opts.size });
    return pad(hex3, { size: opts.size });
  }
  return hex3;
}
function bytesToHex(value, opts = {}) {
  let string = "";
  for (let i = 0; i < value.length; i++) {
    string += hexes[value[i]];
  }
  const hex3 = `0x${string}`;
  if (typeof opts.size === "number") {
    assertSize(hex3, { size: opts.size });
    return pad(hex3, { dir: "right", size: opts.size });
  }
  return hex3;
}
function numberToHex(value_, opts = {}) {
  const { signed, size: size2 } = opts;
  const value = BigInt(value_);
  let maxValue;
  if (size2) {
    if (signed)
      maxValue = (1n << BigInt(size2) * 8n - 1n) - 1n;
    else
      maxValue = 2n ** (BigInt(size2) * 8n) - 1n;
  } else if (typeof value_ === "number") {
    maxValue = BigInt(Number.MAX_SAFE_INTEGER);
  }
  const minValue = typeof maxValue === "bigint" && signed ? -maxValue - 1n : 0;
  if (maxValue && value > maxValue || value < minValue) {
    const suffix = typeof value_ === "bigint" ? "n" : "";
    throw new IntegerOutOfRangeError({
      max: maxValue ? `${maxValue}${suffix}` : void 0,
      min: `${minValue}${suffix}`,
      signed,
      size: size2,
      value: `${value_}${suffix}`
    });
  }
  const hex3 = `0x${(signed && value < 0 ? (1n << BigInt(size2 * 8)) + BigInt(value) : value).toString(16)}`;
  if (size2)
    return pad(hex3, { size: size2 });
  return hex3;
}
function stringToHex(value_, opts = {}) {
  const value = encoder.encode(value_);
  return bytesToHex(value, opts);
}
var hexes, encoder;
var init_toHex = __esm({
  "node_modules/viem/_esm/utils/encoding/toHex.js"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_encoding();
    init_pad();
    init_fromHex();
    hexes = /* @__PURE__ */ Array.from({ length: 256 }, (_v2, i) => i.toString(16).padStart(2, "0"));
    encoder = /* @__PURE__ */ new TextEncoder();
  }
});

// node_modules/viem/_esm/utils/encoding/toBytes.js
function toBytes(value, opts = {}) {
  if (typeof value === "number" || typeof value === "bigint")
    return numberToBytes(value, opts);
  if (typeof value === "boolean")
    return boolToBytes(value, opts);
  if (isHex(value))
    return hexToBytes(value, opts);
  return stringToBytes(value, opts);
}
function boolToBytes(value, opts = {}) {
  const bytes4 = new Uint8Array(1);
  bytes4[0] = Number(value);
  if (typeof opts.size === "number") {
    assertSize(bytes4, { size: opts.size });
    return pad(bytes4, { size: opts.size });
  }
  return bytes4;
}
function charCodeToBase16(char) {
  if (char >= charCodeMap.zero && char <= charCodeMap.nine)
    return char - charCodeMap.zero;
  if (char >= charCodeMap.A && char <= charCodeMap.F)
    return char - (charCodeMap.A - 10);
  if (char >= charCodeMap.a && char <= charCodeMap.f)
    return char - (charCodeMap.a - 10);
  return void 0;
}
function hexToBytes(hex_, opts = {}) {
  let hex3 = hex_;
  if (opts.size) {
    assertSize(hex3, { size: opts.size });
    hex3 = pad(hex3, { dir: "right", size: opts.size });
  }
  let hexString = hex3.slice(2);
  if (hexString.length % 2)
    hexString = `0${hexString}`;
  const length = hexString.length / 2;
  const bytes4 = new Uint8Array(length);
  for (let index = 0, j = 0; index < length; index++) {
    const nibbleLeft = charCodeToBase16(hexString.charCodeAt(j++));
    const nibbleRight = charCodeToBase16(hexString.charCodeAt(j++));
    if (nibbleLeft === void 0 || nibbleRight === void 0) {
      throw new BaseError(`Invalid byte sequence ("${hexString[j - 2]}${hexString[j - 1]}" in "${hexString}").`);
    }
    bytes4[index] = nibbleLeft * 16 + nibbleRight;
  }
  return bytes4;
}
function numberToBytes(value, opts) {
  const hex3 = numberToHex(value, opts);
  return hexToBytes(hex3);
}
function stringToBytes(value, opts = {}) {
  const bytes4 = encoder2.encode(value);
  if (typeof opts.size === "number") {
    assertSize(bytes4, { size: opts.size });
    return pad(bytes4, { dir: "right", size: opts.size });
  }
  return bytes4;
}
var encoder2, charCodeMap;
var init_toBytes = __esm({
  "node_modules/viem/_esm/utils/encoding/toBytes.js"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_base();
    init_isHex();
    init_pad();
    init_fromHex();
    init_toHex();
    encoder2 = /* @__PURE__ */ new TextEncoder();
    charCodeMap = {
      zero: 48,
      nine: 57,
      A: 65,
      F: 70,
      a: 97,
      f: 102
    };
  }
});

// node_modules/viem/node_modules/@noble/hashes/esm/_assert.js
function number(n) {
  if (!Number.isSafeInteger(n) || n < 0)
    throw new Error(`Wrong positive integer: ${n}`);
}
function bytes(b, ...lengths) {
  if (!(b instanceof Uint8Array))
    throw new Error("Expected Uint8Array");
  if (lengths.length > 0 && !lengths.includes(b.length))
    throw new Error(`Expected Uint8Array of length ${lengths}, not of length=${b.length}`);
}
function exists(instance, checkFinished = true) {
  if (instance.destroyed)
    throw new Error("Hash instance has been destroyed");
  if (checkFinished && instance.finished)
    throw new Error("Hash#digest() has already been called");
}
function output(out, instance) {
  bytes(out);
  const min = instance.outputLen;
  if (out.length < min) {
    throw new Error(`digestInto() expects output buffer of length at least ${min}`);
  }
}
var init_assert = __esm({
  "node_modules/viem/node_modules/@noble/hashes/esm/_assert.js"() {
    init_checked_fetch();
    init_modules_watch_stub();
  }
});

// node_modules/viem/node_modules/@noble/hashes/esm/_u64.js
function fromBig(n, le2 = false) {
  if (le2)
    return { h: Number(n & U32_MASK64), l: Number(n >> _32n & U32_MASK64) };
  return { h: Number(n >> _32n & U32_MASK64) | 0, l: Number(n & U32_MASK64) | 0 };
}
function split(lst, le2 = false) {
  let Ah2 = new Uint32Array(lst.length);
  let Al2 = new Uint32Array(lst.length);
  for (let i = 0; i < lst.length; i++) {
    const { h: h2, l } = fromBig(lst[i], le2);
    [Ah2[i], Al2[i]] = [h2, l];
  }
  return [Ah2, Al2];
}
var U32_MASK64, _32n, rotlSH, rotlSL, rotlBH, rotlBL;
var init_u64 = __esm({
  "node_modules/viem/node_modules/@noble/hashes/esm/_u64.js"() {
    init_checked_fetch();
    init_modules_watch_stub();
    U32_MASK64 = /* @__PURE__ */ BigInt(2 ** 32 - 1);
    _32n = /* @__PURE__ */ BigInt(32);
    rotlSH = (h2, l, s) => h2 << s | l >>> 32 - s;
    rotlSL = (h2, l, s) => l << s | h2 >>> 32 - s;
    rotlBH = (h2, l, s) => l << s - 32 | h2 >>> 64 - s;
    rotlBL = (h2, l, s) => h2 << s - 32 | l >>> 64 - s;
  }
});

// node_modules/viem/node_modules/@noble/hashes/esm/utils.js
function utf8ToBytes(str) {
  if (typeof str !== "string")
    throw new Error(`utf8ToBytes expected string, got ${typeof str}`);
  return new Uint8Array(new TextEncoder().encode(str));
}
function toBytes2(data) {
  if (typeof data === "string")
    data = utf8ToBytes(data);
  if (!u8a(data))
    throw new Error(`expected Uint8Array, got ${typeof data}`);
  return data;
}
function wrapConstructor(hashCons) {
  const hashC = (msg) => hashCons().update(toBytes2(msg)).digest();
  const tmp = hashCons();
  hashC.outputLen = tmp.outputLen;
  hashC.blockLen = tmp.blockLen;
  hashC.create = () => hashCons();
  return hashC;
}
function wrapXOFConstructorWithOpts(hashCons) {
  const hashC = (msg, opts) => hashCons(opts).update(toBytes2(msg)).digest();
  const tmp = hashCons({});
  hashC.outputLen = tmp.outputLen;
  hashC.blockLen = tmp.blockLen;
  hashC.create = (opts) => hashCons(opts);
  return hashC;
}
var u8a, u32, isLE, Hash, toStr;
var init_utils2 = __esm({
  "node_modules/viem/node_modules/@noble/hashes/esm/utils.js"() {
    init_checked_fetch();
    init_modules_watch_stub();
    u8a = (a) => a instanceof Uint8Array;
    u32 = (arr) => new Uint32Array(arr.buffer, arr.byteOffset, Math.floor(arr.byteLength / 4));
    isLE = new Uint8Array(new Uint32Array([287454020]).buffer)[0] === 68;
    if (!isLE)
      throw new Error("Non little-endian hardware is not supported");
    Hash = class {
      // Safe version that clones internal state
      clone() {
        return this._cloneInto();
      }
    };
    toStr = {}.toString;
  }
});

// node_modules/viem/node_modules/@noble/hashes/esm/sha3.js
function keccakP(s, rounds = 24) {
  const B = new Uint32Array(5 * 2);
  for (let round = 24 - rounds; round < 24; round++) {
    for (let x = 0; x < 10; x++)
      B[x] = s[x] ^ s[x + 10] ^ s[x + 20] ^ s[x + 30] ^ s[x + 40];
    for (let x = 0; x < 10; x += 2) {
      const idx1 = (x + 8) % 10;
      const idx0 = (x + 2) % 10;
      const B02 = B[idx0];
      const B12 = B[idx0 + 1];
      const Th2 = rotlH(B02, B12, 1) ^ B[idx1];
      const Tl2 = rotlL(B02, B12, 1) ^ B[idx1 + 1];
      for (let y = 0; y < 50; y += 10) {
        s[x + y] ^= Th2;
        s[x + y + 1] ^= Tl2;
      }
    }
    let curH = s[2];
    let curL = s[3];
    for (let t = 0; t < 24; t++) {
      const shift = SHA3_ROTL[t];
      const Th2 = rotlH(curH, curL, shift);
      const Tl2 = rotlL(curH, curL, shift);
      const PI = SHA3_PI[t];
      curH = s[PI];
      curL = s[PI + 1];
      s[PI] = Th2;
      s[PI + 1] = Tl2;
    }
    for (let y = 0; y < 50; y += 10) {
      for (let x = 0; x < 10; x++)
        B[x] = s[y + x];
      for (let x = 0; x < 10; x++)
        s[y + x] ^= ~B[(x + 2) % 10] & B[(x + 4) % 10];
    }
    s[0] ^= SHA3_IOTA_H[round];
    s[1] ^= SHA3_IOTA_L[round];
  }
  B.fill(0);
}
var SHA3_PI, SHA3_ROTL, _SHA3_IOTA, _0n, _1n, _2n, _7n, _256n, _0x71n, SHA3_IOTA_H, SHA3_IOTA_L, rotlH, rotlL, Keccak, gen, sha3_224, sha3_256, sha3_384, sha3_512, keccak_224, keccak_256, keccak_384, keccak_512, genShake, shake128, shake256;
var init_sha3 = __esm({
  "node_modules/viem/node_modules/@noble/hashes/esm/sha3.js"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_assert();
    init_u64();
    init_utils2();
    [SHA3_PI, SHA3_ROTL, _SHA3_IOTA] = [[], [], []];
    _0n = /* @__PURE__ */ BigInt(0);
    _1n = /* @__PURE__ */ BigInt(1);
    _2n = /* @__PURE__ */ BigInt(2);
    _7n = /* @__PURE__ */ BigInt(7);
    _256n = /* @__PURE__ */ BigInt(256);
    _0x71n = /* @__PURE__ */ BigInt(113);
    for (let round = 0, R = _1n, x = 1, y = 0; round < 24; round++) {
      [x, y] = [y, (2 * x + 3 * y) % 5];
      SHA3_PI.push(2 * (5 * y + x));
      SHA3_ROTL.push((round + 1) * (round + 2) / 2 % 64);
      let t = _0n;
      for (let j = 0; j < 7; j++) {
        R = (R << _1n ^ (R >> _7n) * _0x71n) % _256n;
        if (R & _2n)
          t ^= _1n << (_1n << /* @__PURE__ */ BigInt(j)) - _1n;
      }
      _SHA3_IOTA.push(t);
    }
    [SHA3_IOTA_H, SHA3_IOTA_L] = /* @__PURE__ */ split(_SHA3_IOTA, true);
    rotlH = (h2, l, s) => s > 32 ? rotlBH(h2, l, s) : rotlSH(h2, l, s);
    rotlL = (h2, l, s) => s > 32 ? rotlBL(h2, l, s) : rotlSL(h2, l, s);
    Keccak = class extends Hash {
      // NOTE: we accept arguments in bytes instead of bits here.
      constructor(blockLen, suffix, outputLen, enableXOF = false, rounds = 24) {
        super();
        this.blockLen = blockLen;
        this.suffix = suffix;
        this.outputLen = outputLen;
        this.enableXOF = enableXOF;
        this.rounds = rounds;
        this.pos = 0;
        this.posOut = 0;
        this.finished = false;
        this.destroyed = false;
        number(outputLen);
        if (0 >= this.blockLen || this.blockLen >= 200)
          throw new Error("Sha3 supports only keccak-f1600 function");
        this.state = new Uint8Array(200);
        this.state32 = u32(this.state);
      }
      keccak() {
        keccakP(this.state32, this.rounds);
        this.posOut = 0;
        this.pos = 0;
      }
      update(data) {
        exists(this);
        const { blockLen, state } = this;
        data = toBytes2(data);
        const len = data.length;
        for (let pos = 0; pos < len; ) {
          const take = Math.min(blockLen - this.pos, len - pos);
          for (let i = 0; i < take; i++)
            state[this.pos++] ^= data[pos++];
          if (this.pos === blockLen)
            this.keccak();
        }
        return this;
      }
      finish() {
        if (this.finished)
          return;
        this.finished = true;
        const { state, suffix, pos, blockLen } = this;
        state[pos] ^= suffix;
        if ((suffix & 128) !== 0 && pos === blockLen - 1)
          this.keccak();
        state[blockLen - 1] ^= 128;
        this.keccak();
      }
      writeInto(out) {
        exists(this, false);
        bytes(out);
        this.finish();
        const bufferOut = this.state;
        const { blockLen } = this;
        for (let pos = 0, len = out.length; pos < len; ) {
          if (this.posOut >= blockLen)
            this.keccak();
          const take = Math.min(blockLen - this.posOut, len - pos);
          out.set(bufferOut.subarray(this.posOut, this.posOut + take), pos);
          this.posOut += take;
          pos += take;
        }
        return out;
      }
      xofInto(out) {
        if (!this.enableXOF)
          throw new Error("XOF is not possible for this instance");
        return this.writeInto(out);
      }
      xof(bytes4) {
        number(bytes4);
        return this.xofInto(new Uint8Array(bytes4));
      }
      digestInto(out) {
        output(out, this);
        if (this.finished)
          throw new Error("digest() was already called");
        this.writeInto(out);
        this.destroy();
        return out;
      }
      digest() {
        return this.digestInto(new Uint8Array(this.outputLen));
      }
      destroy() {
        this.destroyed = true;
        this.state.fill(0);
      }
      _cloneInto(to) {
        const { blockLen, suffix, outputLen, rounds, enableXOF } = this;
        to || (to = new Keccak(blockLen, suffix, outputLen, enableXOF, rounds));
        to.state32.set(this.state32);
        to.pos = this.pos;
        to.posOut = this.posOut;
        to.finished = this.finished;
        to.rounds = rounds;
        to.suffix = suffix;
        to.outputLen = outputLen;
        to.enableXOF = enableXOF;
        to.destroyed = this.destroyed;
        return to;
      }
    };
    gen = (suffix, blockLen, outputLen) => wrapConstructor(() => new Keccak(blockLen, suffix, outputLen));
    sha3_224 = /* @__PURE__ */ gen(6, 144, 224 / 8);
    sha3_256 = /* @__PURE__ */ gen(6, 136, 256 / 8);
    sha3_384 = /* @__PURE__ */ gen(6, 104, 384 / 8);
    sha3_512 = /* @__PURE__ */ gen(6, 72, 512 / 8);
    keccak_224 = /* @__PURE__ */ gen(1, 144, 224 / 8);
    keccak_256 = /* @__PURE__ */ gen(1, 136, 256 / 8);
    keccak_384 = /* @__PURE__ */ gen(1, 104, 384 / 8);
    keccak_512 = /* @__PURE__ */ gen(1, 72, 512 / 8);
    genShake = (suffix, blockLen, outputLen) => wrapXOFConstructorWithOpts((opts = {}) => new Keccak(blockLen, suffix, opts.dkLen === void 0 ? outputLen : opts.dkLen, true));
    shake128 = /* @__PURE__ */ genShake(31, 168, 128 / 8);
    shake256 = /* @__PURE__ */ genShake(31, 136, 256 / 8);
  }
});

// node_modules/viem/_esm/utils/hash/keccak256.js
function keccak256(value, to_) {
  const to = to_ || "hex";
  const bytes4 = keccak_256(isHex(value, { strict: false }) ? toBytes(value) : value);
  if (to === "bytes")
    return bytes4;
  return toHex(bytes4);
}
var init_keccak256 = __esm({
  "node_modules/viem/_esm/utils/hash/keccak256.js"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_sha3();
    init_isHex();
    init_toBytes();
    init_toHex();
  }
});

// node_modules/viem/_esm/utils/hash/hashSignature.js
function hashSignature(sig) {
  return hash(sig);
}
var hash;
var init_hashSignature = __esm({
  "node_modules/viem/_esm/utils/hash/hashSignature.js"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_toBytes();
    init_keccak256();
    hash = (value) => keccak256(toBytes(value));
  }
});

// node_modules/viem/_esm/utils/hash/normalizeSignature.js
function normalizeSignature(signature) {
  let active = true;
  let current = "";
  let level = 0;
  let result = "";
  let valid = false;
  for (let i = 0; i < signature.length; i++) {
    const char = signature[i];
    if (["(", ")", ","].includes(char))
      active = true;
    if (char === "(")
      level++;
    if (char === ")")
      level--;
    if (!active)
      continue;
    if (level === 0) {
      if (char === " " && ["event", "function", ""].includes(result))
        result = "";
      else {
        result += char;
        if (char === ")") {
          valid = true;
          break;
        }
      }
      continue;
    }
    if (char === " ") {
      if (signature[i - 1] !== "," && current !== "," && current !== ",(") {
        current = "";
        active = false;
      }
      continue;
    }
    result += char;
    current += char;
  }
  if (!valid)
    throw new BaseError("Unable to normalize signature.");
  return result;
}
var init_normalizeSignature = __esm({
  "node_modules/viem/_esm/utils/hash/normalizeSignature.js"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_base();
  }
});

// node_modules/viem/_esm/utils/hash/toSignature.js
var toSignature;
var init_toSignature = __esm({
  "node_modules/viem/_esm/utils/hash/toSignature.js"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_exports();
    init_normalizeSignature();
    toSignature = (def) => {
      const def_ = (() => {
        if (typeof def === "string")
          return def;
        return formatAbiItem(def);
      })();
      return normalizeSignature(def_);
    };
  }
});

// node_modules/viem/_esm/utils/hash/toSignatureHash.js
function toSignatureHash(fn2) {
  return hashSignature(toSignature(fn2));
}
var init_toSignatureHash = __esm({
  "node_modules/viem/_esm/utils/hash/toSignatureHash.js"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_hashSignature();
    init_toSignature();
  }
});

// node_modules/viem/_esm/utils/hash/toEventSelector.js
var toEventSelector;
var init_toEventSelector = __esm({
  "node_modules/viem/_esm/utils/hash/toEventSelector.js"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_toSignatureHash();
    toEventSelector = toSignatureHash;
  }
});

// node_modules/viem/_esm/errors/address.js
var InvalidAddressError;
var init_address = __esm({
  "node_modules/viem/_esm/errors/address.js"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_base();
    InvalidAddressError = class extends BaseError {
      constructor({ address }) {
        super(`Address "${address}" is invalid.`, {
          metaMessages: [
            "- Address must be a hex value of 20 bytes (40 hex characters).",
            "- Address must match its checksum counterpart."
          ]
        });
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "InvalidAddressError"
        });
      }
    };
  }
});

// node_modules/viem/_esm/utils/lru.js
var LruMap;
var init_lru = __esm({
  "node_modules/viem/_esm/utils/lru.js"() {
    init_checked_fetch();
    init_modules_watch_stub();
    LruMap = class extends Map {
      constructor(size2) {
        super();
        Object.defineProperty(this, "maxSize", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        this.maxSize = size2;
      }
      set(key, value) {
        super.set(key, value);
        if (this.maxSize && this.size > this.maxSize)
          this.delete(this.keys().next().value);
        return this;
      }
    };
  }
});

// node_modules/viem/_esm/utils/address/getAddress.js
function checksumAddress(address_, chainId) {
  const hexAddress = chainId ? `${chainId}${address_.toLowerCase()}` : address_.substring(2).toLowerCase();
  const hash2 = keccak256(stringToBytes(hexAddress), "bytes");
  const address = (chainId ? hexAddress.substring(`${chainId}0x`.length) : hexAddress).split("");
  for (let i = 0; i < 40; i += 2) {
    if (hash2[i >> 1] >> 4 >= 8 && address[i]) {
      address[i] = address[i].toUpperCase();
    }
    if ((hash2[i >> 1] & 15) >= 8 && address[i + 1]) {
      address[i + 1] = address[i + 1].toUpperCase();
    }
  }
  return `0x${address.join("")}`;
}
var init_getAddress = __esm({
  "node_modules/viem/_esm/utils/address/getAddress.js"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_toBytes();
    init_keccak256();
  }
});

// node_modules/viem/_esm/utils/address/isAddress.js
function isAddress(address, { strict = true } = {}) {
  if (isAddressCache.has(address))
    return isAddressCache.get(address);
  const result = (() => {
    if (!addressRegex.test(address))
      return false;
    if (address.toLowerCase() === address)
      return true;
    if (strict)
      return checksumAddress(address) === address;
    return true;
  })();
  isAddressCache.set(address, result);
  return result;
}
var addressRegex, isAddressCache;
var init_isAddress = __esm({
  "node_modules/viem/_esm/utils/address/isAddress.js"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_lru();
    init_getAddress();
    addressRegex = /^0x[a-fA-F0-9]{40}$/;
    isAddressCache = /* @__PURE__ */ new LruMap(8192);
  }
});

// node_modules/viem/_esm/utils/data/concat.js
function concat(values) {
  if (typeof values[0] === "string")
    return concatHex(values);
  return concatBytes(values);
}
function concatBytes(values) {
  let length = 0;
  for (const arr of values) {
    length += arr.length;
  }
  const result = new Uint8Array(length);
  let offset = 0;
  for (const arr of values) {
    result.set(arr, offset);
    offset += arr.length;
  }
  return result;
}
function concatHex(values) {
  return `0x${values.reduce((acc, x) => acc + x.replace("0x", ""), "")}`;
}
var init_concat = __esm({
  "node_modules/viem/_esm/utils/data/concat.js"() {
    init_checked_fetch();
    init_modules_watch_stub();
  }
});

// node_modules/viem/_esm/utils/data/slice.js
function slice(value, start, end, { strict } = {}) {
  if (isHex(value, { strict: false }))
    return sliceHex(value, start, end, {
      strict
    });
  return sliceBytes(value, start, end, {
    strict
  });
}
function assertStartOffset(value, start) {
  if (typeof start === "number" && start > 0 && start > size(value) - 1)
    throw new SliceOffsetOutOfBoundsError({
      offset: start,
      position: "start",
      size: size(value)
    });
}
function assertEndOffset(value, start, end) {
  if (typeof start === "number" && typeof end === "number" && size(value) !== end - start) {
    throw new SliceOffsetOutOfBoundsError({
      offset: end,
      position: "end",
      size: size(value)
    });
  }
}
function sliceBytes(value_, start, end, { strict } = {}) {
  assertStartOffset(value_, start);
  const value = value_.slice(start, end);
  if (strict)
    assertEndOffset(value, start, end);
  return value;
}
function sliceHex(value_, start, end, { strict } = {}) {
  assertStartOffset(value_, start);
  const value = `0x${value_.replace("0x", "").slice((start ?? 0) * 2, (end ?? value_.length) * 2)}`;
  if (strict)
    assertEndOffset(value, start, end);
  return value;
}
var init_slice = __esm({
  "node_modules/viem/_esm/utils/data/slice.js"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_data();
    init_isHex();
    init_size();
  }
});

// node_modules/viem/_esm/utils/abi/encodeAbiParameters.js
function encodeAbiParameters(params, values) {
  if (params.length !== values.length)
    throw new AbiEncodingLengthMismatchError({
      expectedLength: params.length,
      givenLength: values.length
    });
  const preparedParams = prepareParams({
    params,
    values
  });
  const data = encodeParams(preparedParams);
  if (data.length === 0)
    return "0x";
  return data;
}
function prepareParams({ params, values }) {
  const preparedParams = [];
  for (let i = 0; i < params.length; i++) {
    preparedParams.push(prepareParam({ param: params[i], value: values[i] }));
  }
  return preparedParams;
}
function prepareParam({ param, value }) {
  const arrayComponents = getArrayComponents(param.type);
  if (arrayComponents) {
    const [length, type] = arrayComponents;
    return encodeArray(value, { length, param: { ...param, type } });
  }
  if (param.type === "tuple") {
    return encodeTuple(value, {
      param
    });
  }
  if (param.type === "address") {
    return encodeAddress(value);
  }
  if (param.type === "bool") {
    return encodeBool(value);
  }
  if (param.type.startsWith("uint") || param.type.startsWith("int")) {
    const signed = param.type.startsWith("int");
    return encodeNumber(value, { signed });
  }
  if (param.type.startsWith("bytes")) {
    return encodeBytes(value, { param });
  }
  if (param.type === "string") {
    return encodeString(value);
  }
  throw new InvalidAbiEncodingTypeError(param.type, {
    docsPath: "/docs/contract/encodeAbiParameters"
  });
}
function encodeParams(preparedParams) {
  let staticSize = 0;
  for (let i = 0; i < preparedParams.length; i++) {
    const { dynamic, encoded } = preparedParams[i];
    if (dynamic)
      staticSize += 32;
    else
      staticSize += size(encoded);
  }
  const staticParams = [];
  const dynamicParams = [];
  let dynamicSize = 0;
  for (let i = 0; i < preparedParams.length; i++) {
    const { dynamic, encoded } = preparedParams[i];
    if (dynamic) {
      staticParams.push(numberToHex(staticSize + dynamicSize, { size: 32 }));
      dynamicParams.push(encoded);
      dynamicSize += size(encoded);
    } else {
      staticParams.push(encoded);
    }
  }
  return concat([...staticParams, ...dynamicParams]);
}
function encodeAddress(value) {
  if (!isAddress(value))
    throw new InvalidAddressError({ address: value });
  return { dynamic: false, encoded: padHex(value.toLowerCase()) };
}
function encodeArray(value, { length, param }) {
  const dynamic = length === null;
  if (!Array.isArray(value))
    throw new InvalidArrayError(value);
  if (!dynamic && value.length !== length)
    throw new AbiEncodingArrayLengthMismatchError({
      expectedLength: length,
      givenLength: value.length,
      type: `${param.type}[${length}]`
    });
  let dynamicChild = false;
  const preparedParams = [];
  for (let i = 0; i < value.length; i++) {
    const preparedParam = prepareParam({ param, value: value[i] });
    if (preparedParam.dynamic)
      dynamicChild = true;
    preparedParams.push(preparedParam);
  }
  if (dynamic || dynamicChild) {
    const data = encodeParams(preparedParams);
    if (dynamic) {
      const length2 = numberToHex(preparedParams.length, { size: 32 });
      return {
        dynamic: true,
        encoded: preparedParams.length > 0 ? concat([length2, data]) : length2
      };
    }
    if (dynamicChild)
      return { dynamic: true, encoded: data };
  }
  return {
    dynamic: false,
    encoded: concat(preparedParams.map(({ encoded }) => encoded))
  };
}
function encodeBytes(value, { param }) {
  const [, paramSize] = param.type.split("bytes");
  const bytesSize = size(value);
  if (!paramSize) {
    let value_ = value;
    if (bytesSize % 32 !== 0)
      value_ = padHex(value_, {
        dir: "right",
        size: Math.ceil((value.length - 2) / 2 / 32) * 32
      });
    return {
      dynamic: true,
      encoded: concat([padHex(numberToHex(bytesSize, { size: 32 })), value_])
    };
  }
  if (bytesSize !== parseInt(paramSize))
    throw new AbiEncodingBytesSizeMismatchError({
      expectedSize: parseInt(paramSize),
      value
    });
  return { dynamic: false, encoded: padHex(value, { dir: "right" }) };
}
function encodeBool(value) {
  return { dynamic: false, encoded: padHex(boolToHex(value)) };
}
function encodeNumber(value, { signed }) {
  return {
    dynamic: false,
    encoded: numberToHex(value, {
      size: 32,
      signed
    })
  };
}
function encodeString(value) {
  const hexValue = stringToHex(value);
  const partsLength = Math.ceil(size(hexValue) / 32);
  const parts = [];
  for (let i = 0; i < partsLength; i++) {
    parts.push(padHex(slice(hexValue, i * 32, (i + 1) * 32), {
      dir: "right"
    }));
  }
  return {
    dynamic: true,
    encoded: concat([
      padHex(numberToHex(size(hexValue), { size: 32 })),
      ...parts
    ])
  };
}
function encodeTuple(value, { param }) {
  let dynamic = false;
  const preparedParams = [];
  for (let i = 0; i < param.components.length; i++) {
    const param_ = param.components[i];
    const index = Array.isArray(value) ? i : param_.name;
    const preparedParam = prepareParam({
      param: param_,
      value: value[index]
    });
    preparedParams.push(preparedParam);
    if (preparedParam.dynamic)
      dynamic = true;
  }
  return {
    dynamic,
    encoded: dynamic ? encodeParams(preparedParams) : concat(preparedParams.map(({ encoded }) => encoded))
  };
}
function getArrayComponents(type) {
  const matches = type.match(/^(.*)\[(\d+)?\]$/);
  return matches ? (
    // Return `null` if the array is dynamic.
    [matches[2] ? Number(matches[2]) : null, matches[1]]
  ) : void 0;
}
var init_encodeAbiParameters = __esm({
  "node_modules/viem/_esm/utils/abi/encodeAbiParameters.js"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_abi();
    init_address();
    init_isAddress();
    init_concat();
    init_pad();
    init_size();
    init_slice();
    init_toHex();
  }
});

// node_modules/viem/_esm/utils/hash/toFunctionSelector.js
var toFunctionSelector;
var init_toFunctionSelector = __esm({
  "node_modules/viem/_esm/utils/hash/toFunctionSelector.js"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_slice();
    init_toSignatureHash();
    toFunctionSelector = (fn2) => slice(toSignatureHash(fn2), 0, 4);
  }
});

// node_modules/viem/_esm/utils/abi/getAbiItem.js
function getAbiItem(parameters) {
  const { abi, args = [], name } = parameters;
  const isSelector = isHex(name, { strict: false });
  const abiItems = abi.filter((abiItem) => {
    if (isSelector) {
      if (abiItem.type === "function")
        return toFunctionSelector(abiItem) === name;
      if (abiItem.type === "event")
        return toEventSelector(abiItem) === name;
      return false;
    }
    return "name" in abiItem && abiItem.name === name;
  });
  if (abiItems.length === 0)
    return void 0;
  if (abiItems.length === 1)
    return abiItems[0];
  let matchedAbiItem = void 0;
  for (const abiItem of abiItems) {
    if (!("inputs" in abiItem))
      continue;
    if (!args || args.length === 0) {
      if (!abiItem.inputs || abiItem.inputs.length === 0)
        return abiItem;
      continue;
    }
    if (!abiItem.inputs)
      continue;
    if (abiItem.inputs.length === 0)
      continue;
    if (abiItem.inputs.length !== args.length)
      continue;
    const matched = args.every((arg, index) => {
      const abiParameter = "inputs" in abiItem && abiItem.inputs[index];
      if (!abiParameter)
        return false;
      return isArgOfType(arg, abiParameter);
    });
    if (matched) {
      if (matchedAbiItem && "inputs" in matchedAbiItem && matchedAbiItem.inputs) {
        const ambiguousTypes = getAmbiguousTypes(abiItem.inputs, matchedAbiItem.inputs, args);
        if (ambiguousTypes)
          throw new AbiItemAmbiguityError({
            abiItem,
            type: ambiguousTypes[0]
          }, {
            abiItem: matchedAbiItem,
            type: ambiguousTypes[1]
          });
      }
      matchedAbiItem = abiItem;
    }
  }
  if (matchedAbiItem)
    return matchedAbiItem;
  return abiItems[0];
}
function isArgOfType(arg, abiParameter) {
  const argType = typeof arg;
  const abiParameterType = abiParameter.type;
  switch (abiParameterType) {
    case "address":
      return isAddress(arg, { strict: false });
    case "bool":
      return argType === "boolean";
    case "function":
      return argType === "string";
    case "string":
      return argType === "string";
    default: {
      if (abiParameterType === "tuple" && "components" in abiParameter)
        return Object.values(abiParameter.components).every((component, index) => {
          return isArgOfType(Object.values(arg)[index], component);
        });
      if (/^u?int(8|16|24|32|40|48|56|64|72|80|88|96|104|112|120|128|136|144|152|160|168|176|184|192|200|208|216|224|232|240|248|256)?$/.test(abiParameterType))
        return argType === "number" || argType === "bigint";
      if (/^bytes([1-9]|1[0-9]|2[0-9]|3[0-2])?$/.test(abiParameterType))
        return argType === "string" || arg instanceof Uint8Array;
      if (/[a-z]+[1-9]{0,3}(\[[0-9]{0,}\])+$/.test(abiParameterType)) {
        return Array.isArray(arg) && arg.every((x) => isArgOfType(x, {
          ...abiParameter,
          // Pop off `[]` or `[M]` from end of type
          type: abiParameterType.replace(/(\[[0-9]{0,}\])$/, "")
        }));
      }
      return false;
    }
  }
}
function getAmbiguousTypes(sourceParameters, targetParameters, args) {
  for (const parameterIndex in sourceParameters) {
    const sourceParameter = sourceParameters[parameterIndex];
    const targetParameter = targetParameters[parameterIndex];
    if (sourceParameter.type === "tuple" && targetParameter.type === "tuple" && "components" in sourceParameter && "components" in targetParameter)
      return getAmbiguousTypes(sourceParameter.components, targetParameter.components, args[parameterIndex]);
    const types2 = [sourceParameter.type, targetParameter.type];
    const ambiguous = (() => {
      if (types2.includes("address") && types2.includes("bytes20"))
        return true;
      if (types2.includes("address") && types2.includes("string"))
        return isAddress(args[parameterIndex], { strict: false });
      if (types2.includes("address") && types2.includes("bytes"))
        return isAddress(args[parameterIndex], { strict: false });
      return false;
    })();
    if (ambiguous)
      return types2;
  }
  return;
}
var init_getAbiItem = __esm({
  "node_modules/viem/_esm/utils/abi/getAbiItem.js"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_abi();
    init_isHex();
    init_isAddress();
    init_toEventSelector();
    init_toFunctionSelector();
  }
});

// node_modules/viem/_esm/utils/abi/encodeFunctionData.js
function encodeFunctionData(parameters) {
  const { abi, args, functionName } = parameters;
  let abiItem = abi[0];
  if (functionName) {
    const item = getAbiItem({
      abi,
      args,
      name: functionName
    });
    if (!item)
      throw new AbiFunctionNotFoundError(functionName, { docsPath });
    abiItem = item;
  }
  if (abiItem.type !== "function")
    throw new AbiFunctionNotFoundError(void 0, { docsPath });
  const definition = formatAbiItem2(abiItem);
  const signature = toFunctionSelector(definition);
  const data = "inputs" in abiItem && abiItem.inputs ? encodeAbiParameters(abiItem.inputs, args ?? []) : void 0;
  return concatHex([signature, data ?? "0x"]);
}
var docsPath;
var init_encodeFunctionData = __esm({
  "node_modules/viem/_esm/utils/abi/encodeFunctionData.js"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_abi();
    init_concat();
    init_toFunctionSelector();
    init_encodeAbiParameters();
    init_formatAbiItem2();
    init_getAbiItem();
    docsPath = "/docs/contract/encodeFunctionData";
  }
});

// node_modules/viem/_esm/utils/encoding/fromBytes.js
function bytesToString(bytes_, opts = {}) {
  let bytes4 = bytes_;
  if (typeof opts.size !== "undefined") {
    assertSize(bytes4, { size: opts.size });
    bytes4 = trim(bytes4, { dir: "right" });
  }
  return new TextDecoder().decode(bytes4);
}
var init_fromBytes = __esm({
  "node_modules/viem/_esm/utils/encoding/fromBytes.js"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_trim();
    init_fromHex();
  }
});

// node_modules/lz-string/libs/lz-string.js
var require_lz_string = __commonJS({
  "node_modules/lz-string/libs/lz-string.js"(exports2, module2) {
    init_checked_fetch();
    init_modules_watch_stub();
    var LZString = function() {
      var f = String.fromCharCode;
      var keyStrBase64 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
      var keyStrUriSafe = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+-$";
      var baseReverseDic = {};
      function getBaseValue(alphabet2, character) {
        if (!baseReverseDic[alphabet2]) {
          baseReverseDic[alphabet2] = {};
          for (var i = 0; i < alphabet2.length; i++) {
            baseReverseDic[alphabet2][alphabet2.charAt(i)] = i;
          }
        }
        return baseReverseDic[alphabet2][character];
      }
      var LZString2 = {
        compressToBase64: function(input) {
          if (input == null)
            return "";
          var res = LZString2._compress(input, 6, function(a) {
            return keyStrBase64.charAt(a);
          });
          switch (res.length % 4) {
            default:
            case 0:
              return res;
            case 1:
              return res + "===";
            case 2:
              return res + "==";
            case 3:
              return res + "=";
          }
        },
        decompressFromBase64: function(input) {
          if (input == null)
            return "";
          if (input == "")
            return null;
          return LZString2._decompress(input.length, 32, function(index) {
            return getBaseValue(keyStrBase64, input.charAt(index));
          });
        },
        compressToUTF16: function(input) {
          if (input == null)
            return "";
          return LZString2._compress(input, 15, function(a) {
            return f(a + 32);
          }) + " ";
        },
        decompressFromUTF16: function(compressed) {
          if (compressed == null)
            return "";
          if (compressed == "")
            return null;
          return LZString2._decompress(compressed.length, 16384, function(index) {
            return compressed.charCodeAt(index) - 32;
          });
        },
        //compress into uint8array (UCS-2 big endian format)
        compressToUint8Array: function(uncompressed) {
          var compressed = LZString2.compress(uncompressed);
          var buf = new Uint8Array(compressed.length * 2);
          for (var i = 0, TotalLen = compressed.length; i < TotalLen; i++) {
            var current_value = compressed.charCodeAt(i);
            buf[i * 2] = current_value >>> 8;
            buf[i * 2 + 1] = current_value % 256;
          }
          return buf;
        },
        //decompress from uint8array (UCS-2 big endian format)
        decompressFromUint8Array: function(compressed) {
          if (compressed === null || compressed === void 0) {
            return LZString2.decompress(compressed);
          } else {
            var buf = new Array(compressed.length / 2);
            for (var i = 0, TotalLen = buf.length; i < TotalLen; i++) {
              buf[i] = compressed[i * 2] * 256 + compressed[i * 2 + 1];
            }
            var result = [];
            buf.forEach(function(c) {
              result.push(f(c));
            });
            return LZString2.decompress(result.join(""));
          }
        },
        //compress into a string that is already URI encoded
        compressToEncodedURIComponent: function(input) {
          if (input == null)
            return "";
          return LZString2._compress(input, 6, function(a) {
            return keyStrUriSafe.charAt(a);
          });
        },
        //decompress from an output of compressToEncodedURIComponent
        decompressFromEncodedURIComponent: function(input) {
          if (input == null)
            return "";
          if (input == "")
            return null;
          input = input.replace(/ /g, "+");
          return LZString2._decompress(input.length, 32, function(index) {
            return getBaseValue(keyStrUriSafe, input.charAt(index));
          });
        },
        compress: function(uncompressed) {
          return LZString2._compress(uncompressed, 16, function(a) {
            return f(a);
          });
        },
        _compress: function(uncompressed, bitsPerChar, getCharFromInt) {
          if (uncompressed == null)
            return "";
          var i, value, context_dictionary = {}, context_dictionaryToCreate = {}, context_c = "", context_wc = "", context_w = "", context_enlargeIn = 2, context_dictSize = 3, context_numBits = 2, context_data = [], context_data_val = 0, context_data_position = 0, ii2;
          for (ii2 = 0; ii2 < uncompressed.length; ii2 += 1) {
            context_c = uncompressed.charAt(ii2);
            if (!Object.prototype.hasOwnProperty.call(context_dictionary, context_c)) {
              context_dictionary[context_c] = context_dictSize++;
              context_dictionaryToCreate[context_c] = true;
            }
            context_wc = context_w + context_c;
            if (Object.prototype.hasOwnProperty.call(context_dictionary, context_wc)) {
              context_w = context_wc;
            } else {
              if (Object.prototype.hasOwnProperty.call(context_dictionaryToCreate, context_w)) {
                if (context_w.charCodeAt(0) < 256) {
                  for (i = 0; i < context_numBits; i++) {
                    context_data_val = context_data_val << 1;
                    if (context_data_position == bitsPerChar - 1) {
                      context_data_position = 0;
                      context_data.push(getCharFromInt(context_data_val));
                      context_data_val = 0;
                    } else {
                      context_data_position++;
                    }
                  }
                  value = context_w.charCodeAt(0);
                  for (i = 0; i < 8; i++) {
                    context_data_val = context_data_val << 1 | value & 1;
                    if (context_data_position == bitsPerChar - 1) {
                      context_data_position = 0;
                      context_data.push(getCharFromInt(context_data_val));
                      context_data_val = 0;
                    } else {
                      context_data_position++;
                    }
                    value = value >> 1;
                  }
                } else {
                  value = 1;
                  for (i = 0; i < context_numBits; i++) {
                    context_data_val = context_data_val << 1 | value;
                    if (context_data_position == bitsPerChar - 1) {
                      context_data_position = 0;
                      context_data.push(getCharFromInt(context_data_val));
                      context_data_val = 0;
                    } else {
                      context_data_position++;
                    }
                    value = 0;
                  }
                  value = context_w.charCodeAt(0);
                  for (i = 0; i < 16; i++) {
                    context_data_val = context_data_val << 1 | value & 1;
                    if (context_data_position == bitsPerChar - 1) {
                      context_data_position = 0;
                      context_data.push(getCharFromInt(context_data_val));
                      context_data_val = 0;
                    } else {
                      context_data_position++;
                    }
                    value = value >> 1;
                  }
                }
                context_enlargeIn--;
                if (context_enlargeIn == 0) {
                  context_enlargeIn = Math.pow(2, context_numBits);
                  context_numBits++;
                }
                delete context_dictionaryToCreate[context_w];
              } else {
                value = context_dictionary[context_w];
                for (i = 0; i < context_numBits; i++) {
                  context_data_val = context_data_val << 1 | value & 1;
                  if (context_data_position == bitsPerChar - 1) {
                    context_data_position = 0;
                    context_data.push(getCharFromInt(context_data_val));
                    context_data_val = 0;
                  } else {
                    context_data_position++;
                  }
                  value = value >> 1;
                }
              }
              context_enlargeIn--;
              if (context_enlargeIn == 0) {
                context_enlargeIn = Math.pow(2, context_numBits);
                context_numBits++;
              }
              context_dictionary[context_wc] = context_dictSize++;
              context_w = String(context_c);
            }
          }
          if (context_w !== "") {
            if (Object.prototype.hasOwnProperty.call(context_dictionaryToCreate, context_w)) {
              if (context_w.charCodeAt(0) < 256) {
                for (i = 0; i < context_numBits; i++) {
                  context_data_val = context_data_val << 1;
                  if (context_data_position == bitsPerChar - 1) {
                    context_data_position = 0;
                    context_data.push(getCharFromInt(context_data_val));
                    context_data_val = 0;
                  } else {
                    context_data_position++;
                  }
                }
                value = context_w.charCodeAt(0);
                for (i = 0; i < 8; i++) {
                  context_data_val = context_data_val << 1 | value & 1;
                  if (context_data_position == bitsPerChar - 1) {
                    context_data_position = 0;
                    context_data.push(getCharFromInt(context_data_val));
                    context_data_val = 0;
                  } else {
                    context_data_position++;
                  }
                  value = value >> 1;
                }
              } else {
                value = 1;
                for (i = 0; i < context_numBits; i++) {
                  context_data_val = context_data_val << 1 | value;
                  if (context_data_position == bitsPerChar - 1) {
                    context_data_position = 0;
                    context_data.push(getCharFromInt(context_data_val));
                    context_data_val = 0;
                  } else {
                    context_data_position++;
                  }
                  value = 0;
                }
                value = context_w.charCodeAt(0);
                for (i = 0; i < 16; i++) {
                  context_data_val = context_data_val << 1 | value & 1;
                  if (context_data_position == bitsPerChar - 1) {
                    context_data_position = 0;
                    context_data.push(getCharFromInt(context_data_val));
                    context_data_val = 0;
                  } else {
                    context_data_position++;
                  }
                  value = value >> 1;
                }
              }
              context_enlargeIn--;
              if (context_enlargeIn == 0) {
                context_enlargeIn = Math.pow(2, context_numBits);
                context_numBits++;
              }
              delete context_dictionaryToCreate[context_w];
            } else {
              value = context_dictionary[context_w];
              for (i = 0; i < context_numBits; i++) {
                context_data_val = context_data_val << 1 | value & 1;
                if (context_data_position == bitsPerChar - 1) {
                  context_data_position = 0;
                  context_data.push(getCharFromInt(context_data_val));
                  context_data_val = 0;
                } else {
                  context_data_position++;
                }
                value = value >> 1;
              }
            }
            context_enlargeIn--;
            if (context_enlargeIn == 0) {
              context_enlargeIn = Math.pow(2, context_numBits);
              context_numBits++;
            }
          }
          value = 2;
          for (i = 0; i < context_numBits; i++) {
            context_data_val = context_data_val << 1 | value & 1;
            if (context_data_position == bitsPerChar - 1) {
              context_data_position = 0;
              context_data.push(getCharFromInt(context_data_val));
              context_data_val = 0;
            } else {
              context_data_position++;
            }
            value = value >> 1;
          }
          while (true) {
            context_data_val = context_data_val << 1;
            if (context_data_position == bitsPerChar - 1) {
              context_data.push(getCharFromInt(context_data_val));
              break;
            } else
              context_data_position++;
          }
          return context_data.join("");
        },
        decompress: function(compressed) {
          if (compressed == null)
            return "";
          if (compressed == "")
            return null;
          return LZString2._decompress(compressed.length, 32768, function(index) {
            return compressed.charCodeAt(index);
          });
        },
        _decompress: function(length, resetValue, getNextValue) {
          var dictionary = [], next, enlargeIn = 4, dictSize = 4, numBits = 3, entry = "", result = [], i, w, bits2, resb, maxpower, power, c, data = { val: getNextValue(0), position: resetValue, index: 1 };
          for (i = 0; i < 3; i += 1) {
            dictionary[i] = i;
          }
          bits2 = 0;
          maxpower = Math.pow(2, 2);
          power = 1;
          while (power != maxpower) {
            resb = data.val & data.position;
            data.position >>= 1;
            if (data.position == 0) {
              data.position = resetValue;
              data.val = getNextValue(data.index++);
            }
            bits2 |= (resb > 0 ? 1 : 0) * power;
            power <<= 1;
          }
          switch (next = bits2) {
            case 0:
              bits2 = 0;
              maxpower = Math.pow(2, 8);
              power = 1;
              while (power != maxpower) {
                resb = data.val & data.position;
                data.position >>= 1;
                if (data.position == 0) {
                  data.position = resetValue;
                  data.val = getNextValue(data.index++);
                }
                bits2 |= (resb > 0 ? 1 : 0) * power;
                power <<= 1;
              }
              c = f(bits2);
              break;
            case 1:
              bits2 = 0;
              maxpower = Math.pow(2, 16);
              power = 1;
              while (power != maxpower) {
                resb = data.val & data.position;
                data.position >>= 1;
                if (data.position == 0) {
                  data.position = resetValue;
                  data.val = getNextValue(data.index++);
                }
                bits2 |= (resb > 0 ? 1 : 0) * power;
                power <<= 1;
              }
              c = f(bits2);
              break;
            case 2:
              return "";
          }
          dictionary[3] = c;
          w = c;
          result.push(c);
          while (true) {
            if (data.index > length) {
              return "";
            }
            bits2 = 0;
            maxpower = Math.pow(2, numBits);
            power = 1;
            while (power != maxpower) {
              resb = data.val & data.position;
              data.position >>= 1;
              if (data.position == 0) {
                data.position = resetValue;
                data.val = getNextValue(data.index++);
              }
              bits2 |= (resb > 0 ? 1 : 0) * power;
              power <<= 1;
            }
            switch (c = bits2) {
              case 0:
                bits2 = 0;
                maxpower = Math.pow(2, 8);
                power = 1;
                while (power != maxpower) {
                  resb = data.val & data.position;
                  data.position >>= 1;
                  if (data.position == 0) {
                    data.position = resetValue;
                    data.val = getNextValue(data.index++);
                  }
                  bits2 |= (resb > 0 ? 1 : 0) * power;
                  power <<= 1;
                }
                dictionary[dictSize++] = f(bits2);
                c = dictSize - 1;
                enlargeIn--;
                break;
              case 1:
                bits2 = 0;
                maxpower = Math.pow(2, 16);
                power = 1;
                while (power != maxpower) {
                  resb = data.val & data.position;
                  data.position >>= 1;
                  if (data.position == 0) {
                    data.position = resetValue;
                    data.val = getNextValue(data.index++);
                  }
                  bits2 |= (resb > 0 ? 1 : 0) * power;
                  power <<= 1;
                }
                dictionary[dictSize++] = f(bits2);
                c = dictSize - 1;
                enlargeIn--;
                break;
              case 2:
                return result.join("");
            }
            if (enlargeIn == 0) {
              enlargeIn = Math.pow(2, numBits);
              numBits++;
            }
            if (dictionary[c]) {
              entry = dictionary[c];
            } else {
              if (c === dictSize) {
                entry = w + w.charAt(0);
              } else {
                return null;
              }
            }
            result.push(entry);
            dictionary[dictSize++] = w + entry.charAt(0);
            enlargeIn--;
            w = entry;
            if (enlargeIn == 0) {
              enlargeIn = Math.pow(2, numBits);
              numBits++;
            }
          }
        }
      };
      return LZString2;
    }();
    if (typeof define === "function" && define.amd) {
      define(function() {
        return LZString;
      });
    } else if (typeof module2 !== "undefined" && module2 != null) {
      module2.exports = LZString;
    } else if (typeof angular !== "undefined" && angular != null) {
      angular.module("LZString", []).factory("LZString", function() {
        return LZString;
      });
    }
  }
});

// node_modules/path-browserify/index.js
var require_path_browserify = __commonJS({
  "node_modules/path-browserify/index.js"(exports2, module2) {
    "use strict";
    init_checked_fetch();
    init_modules_watch_stub();
    function assertPath(path) {
      if (typeof path !== "string") {
        throw new TypeError("Path must be a string. Received " + JSON.stringify(path));
      }
    }
    function normalizeStringPosix(path, allowAboveRoot) {
      var res = "";
      var lastSegmentLength = 0;
      var lastSlash = -1;
      var dots = 0;
      var code;
      for (var i = 0; i <= path.length; ++i) {
        if (i < path.length)
          code = path.charCodeAt(i);
        else if (code === 47)
          break;
        else
          code = 47;
        if (code === 47) {
          if (lastSlash === i - 1 || dots === 1) {
          } else if (lastSlash !== i - 1 && dots === 2) {
            if (res.length < 2 || lastSegmentLength !== 2 || res.charCodeAt(res.length - 1) !== 46 || res.charCodeAt(res.length - 2) !== 46) {
              if (res.length > 2) {
                var lastSlashIndex = res.lastIndexOf("/");
                if (lastSlashIndex !== res.length - 1) {
                  if (lastSlashIndex === -1) {
                    res = "";
                    lastSegmentLength = 0;
                  } else {
                    res = res.slice(0, lastSlashIndex);
                    lastSegmentLength = res.length - 1 - res.lastIndexOf("/");
                  }
                  lastSlash = i;
                  dots = 0;
                  continue;
                }
              } else if (res.length === 2 || res.length === 1) {
                res = "";
                lastSegmentLength = 0;
                lastSlash = i;
                dots = 0;
                continue;
              }
            }
            if (allowAboveRoot) {
              if (res.length > 0)
                res += "/..";
              else
                res = "..";
              lastSegmentLength = 2;
            }
          } else {
            if (res.length > 0)
              res += "/" + path.slice(lastSlash + 1, i);
            else
              res = path.slice(lastSlash + 1, i);
            lastSegmentLength = i - lastSlash - 1;
          }
          lastSlash = i;
          dots = 0;
        } else if (code === 46 && dots !== -1) {
          ++dots;
        } else {
          dots = -1;
        }
      }
      return res;
    }
    function _format(sep, pathObject) {
      var dir = pathObject.dir || pathObject.root;
      var base = pathObject.base || (pathObject.name || "") + (pathObject.ext || "");
      if (!dir) {
        return base;
      }
      if (dir === pathObject.root) {
        return dir + base;
      }
      return dir + sep + base;
    }
    var posix = {
      // path.resolve([from ...], to)
      resolve: function resolve() {
        var resolvedPath = "";
        var resolvedAbsolute = false;
        var cwd;
        for (var i = arguments.length - 1; i >= -1 && !resolvedAbsolute; i--) {
          var path;
          if (i >= 0)
            path = arguments[i];
          else {
            if (cwd === void 0)
              cwd = process.cwd();
            path = cwd;
          }
          assertPath(path);
          if (path.length === 0) {
            continue;
          }
          resolvedPath = path + "/" + resolvedPath;
          resolvedAbsolute = path.charCodeAt(0) === 47;
        }
        resolvedPath = normalizeStringPosix(resolvedPath, !resolvedAbsolute);
        if (resolvedAbsolute) {
          if (resolvedPath.length > 0)
            return "/" + resolvedPath;
          else
            return "/";
        } else if (resolvedPath.length > 0) {
          return resolvedPath;
        } else {
          return ".";
        }
      },
      normalize: function normalize2(path) {
        assertPath(path);
        if (path.length === 0)
          return ".";
        var isAbsolute = path.charCodeAt(0) === 47;
        var trailingSeparator = path.charCodeAt(path.length - 1) === 47;
        path = normalizeStringPosix(path, !isAbsolute);
        if (path.length === 0 && !isAbsolute)
          path = ".";
        if (path.length > 0 && trailingSeparator)
          path += "/";
        if (isAbsolute)
          return "/" + path;
        return path;
      },
      isAbsolute: function isAbsolute(path) {
        assertPath(path);
        return path.length > 0 && path.charCodeAt(0) === 47;
      },
      join: function join2() {
        if (arguments.length === 0)
          return ".";
        var joined;
        for (var i = 0; i < arguments.length; ++i) {
          var arg = arguments[i];
          assertPath(arg);
          if (arg.length > 0) {
            if (joined === void 0)
              joined = arg;
            else
              joined += "/" + arg;
          }
        }
        if (joined === void 0)
          return ".";
        return posix.normalize(joined);
      },
      relative: function relative(from, to) {
        assertPath(from);
        assertPath(to);
        if (from === to)
          return "";
        from = posix.resolve(from);
        to = posix.resolve(to);
        if (from === to)
          return "";
        var fromStart = 1;
        for (; fromStart < from.length; ++fromStart) {
          if (from.charCodeAt(fromStart) !== 47)
            break;
        }
        var fromEnd = from.length;
        var fromLen = fromEnd - fromStart;
        var toStart = 1;
        for (; toStart < to.length; ++toStart) {
          if (to.charCodeAt(toStart) !== 47)
            break;
        }
        var toEnd = to.length;
        var toLen = toEnd - toStart;
        var length = fromLen < toLen ? fromLen : toLen;
        var lastCommonSep = -1;
        var i = 0;
        for (; i <= length; ++i) {
          if (i === length) {
            if (toLen > length) {
              if (to.charCodeAt(toStart + i) === 47) {
                return to.slice(toStart + i + 1);
              } else if (i === 0) {
                return to.slice(toStart + i);
              }
            } else if (fromLen > length) {
              if (from.charCodeAt(fromStart + i) === 47) {
                lastCommonSep = i;
              } else if (i === 0) {
                lastCommonSep = 0;
              }
            }
            break;
          }
          var fromCode = from.charCodeAt(fromStart + i);
          var toCode = to.charCodeAt(toStart + i);
          if (fromCode !== toCode)
            break;
          else if (fromCode === 47)
            lastCommonSep = i;
        }
        var out = "";
        for (i = fromStart + lastCommonSep + 1; i <= fromEnd; ++i) {
          if (i === fromEnd || from.charCodeAt(i) === 47) {
            if (out.length === 0)
              out += "..";
            else
              out += "/..";
          }
        }
        if (out.length > 0)
          return out + to.slice(toStart + lastCommonSep);
        else {
          toStart += lastCommonSep;
          if (to.charCodeAt(toStart) === 47)
            ++toStart;
          return to.slice(toStart);
        }
      },
      _makeLong: function _makeLong(path) {
        return path;
      },
      dirname: function dirname(path) {
        assertPath(path);
        if (path.length === 0)
          return ".";
        var code = path.charCodeAt(0);
        var hasRoot = code === 47;
        var end = -1;
        var matchedSlash = true;
        for (var i = path.length - 1; i >= 1; --i) {
          code = path.charCodeAt(i);
          if (code === 47) {
            if (!matchedSlash) {
              end = i;
              break;
            }
          } else {
            matchedSlash = false;
          }
        }
        if (end === -1)
          return hasRoot ? "/" : ".";
        if (hasRoot && end === 1)
          return "//";
        return path.slice(0, end);
      },
      basename: function basename(path, ext) {
        if (ext !== void 0 && typeof ext !== "string")
          throw new TypeError('"ext" argument must be a string');
        assertPath(path);
        var start = 0;
        var end = -1;
        var matchedSlash = true;
        var i;
        if (ext !== void 0 && ext.length > 0 && ext.length <= path.length) {
          if (ext.length === path.length && ext === path)
            return "";
          var extIdx = ext.length - 1;
          var firstNonSlashEnd = -1;
          for (i = path.length - 1; i >= 0; --i) {
            var code = path.charCodeAt(i);
            if (code === 47) {
              if (!matchedSlash) {
                start = i + 1;
                break;
              }
            } else {
              if (firstNonSlashEnd === -1) {
                matchedSlash = false;
                firstNonSlashEnd = i + 1;
              }
              if (extIdx >= 0) {
                if (code === ext.charCodeAt(extIdx)) {
                  if (--extIdx === -1) {
                    end = i;
                  }
                } else {
                  extIdx = -1;
                  end = firstNonSlashEnd;
                }
              }
            }
          }
          if (start === end)
            end = firstNonSlashEnd;
          else if (end === -1)
            end = path.length;
          return path.slice(start, end);
        } else {
          for (i = path.length - 1; i >= 0; --i) {
            if (path.charCodeAt(i) === 47) {
              if (!matchedSlash) {
                start = i + 1;
                break;
              }
            } else if (end === -1) {
              matchedSlash = false;
              end = i + 1;
            }
          }
          if (end === -1)
            return "";
          return path.slice(start, end);
        }
      },
      extname: function extname(path) {
        assertPath(path);
        var startDot = -1;
        var startPart = 0;
        var end = -1;
        var matchedSlash = true;
        var preDotState = 0;
        for (var i = path.length - 1; i >= 0; --i) {
          var code = path.charCodeAt(i);
          if (code === 47) {
            if (!matchedSlash) {
              startPart = i + 1;
              break;
            }
            continue;
          }
          if (end === -1) {
            matchedSlash = false;
            end = i + 1;
          }
          if (code === 46) {
            if (startDot === -1)
              startDot = i;
            else if (preDotState !== 1)
              preDotState = 1;
          } else if (startDot !== -1) {
            preDotState = -1;
          }
        }
        if (startDot === -1 || end === -1 || // We saw a non-dot character immediately before the dot
        preDotState === 0 || // The (right-most) trimmed path component is exactly '..'
        preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
          return "";
        }
        return path.slice(startDot, end);
      },
      format: function format(pathObject) {
        if (pathObject === null || typeof pathObject !== "object") {
          throw new TypeError('The "pathObject" argument must be of type Object. Received type ' + typeof pathObject);
        }
        return _format("/", pathObject);
      },
      parse: function parse(path) {
        assertPath(path);
        var ret = { root: "", dir: "", base: "", ext: "", name: "" };
        if (path.length === 0)
          return ret;
        var code = path.charCodeAt(0);
        var isAbsolute = code === 47;
        var start;
        if (isAbsolute) {
          ret.root = "/";
          start = 1;
        } else {
          start = 0;
        }
        var startDot = -1;
        var startPart = 0;
        var end = -1;
        var matchedSlash = true;
        var i = path.length - 1;
        var preDotState = 0;
        for (; i >= start; --i) {
          code = path.charCodeAt(i);
          if (code === 47) {
            if (!matchedSlash) {
              startPart = i + 1;
              break;
            }
            continue;
          }
          if (end === -1) {
            matchedSlash = false;
            end = i + 1;
          }
          if (code === 46) {
            if (startDot === -1)
              startDot = i;
            else if (preDotState !== 1)
              preDotState = 1;
          } else if (startDot !== -1) {
            preDotState = -1;
          }
        }
        if (startDot === -1 || end === -1 || // We saw a non-dot character immediately before the dot
        preDotState === 0 || // The (right-most) trimmed path component is exactly '..'
        preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
          if (end !== -1) {
            if (startPart === 0 && isAbsolute)
              ret.base = ret.name = path.slice(1, end);
            else
              ret.base = ret.name = path.slice(startPart, end);
          }
        } else {
          if (startPart === 0 && isAbsolute) {
            ret.name = path.slice(1, startDot);
            ret.base = path.slice(1, end);
          } else {
            ret.name = path.slice(startPart, startDot);
            ret.base = path.slice(startPart, end);
          }
          ret.ext = path.slice(startDot, end);
        }
        if (startPart > 0)
          ret.dir = path.slice(0, startPart - 1);
        else if (isAbsolute)
          ret.dir = "/";
        return ret;
      },
      sep: "/",
      delimiter: ":",
      win32: null,
      posix: null
    };
    posix.posix = posix;
    module2.exports = posix;
  }
});

// node_modules/gql-query-builder/build/OperationType.js
var require_OperationType = __commonJS({
  "node_modules/gql-query-builder/build/OperationType.js"(exports2) {
    "use strict";
    init_checked_fetch();
    init_modules_watch_stub();
    Object.defineProperty(exports2, "__esModule", { value: true });
    var OperationType;
    (function(OperationType2) {
      OperationType2["Mutation"] = "mutation";
      OperationType2["Query"] = "query";
      OperationType2["Subscription"] = "subscription";
    })(OperationType || (OperationType = {}));
    exports2.default = OperationType;
  }
});

// node_modules/gql-query-builder/build/NestedField.js
var require_NestedField = __commonJS({
  "node_modules/gql-query-builder/build/NestedField.js"(exports2) {
    "use strict";
    init_checked_fetch();
    init_modules_watch_stub();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.isNestedField = void 0;
    function isNestedField(object) {
      return typeof object === "object" && object.hasOwnProperty("operation") && object.hasOwnProperty("variables") && object.hasOwnProperty("fields") || typeof object === "object" && object.hasOwnProperty("operation") && object.hasOwnProperty("fragment") && object.hasOwnProperty("fields");
    }
    exports2.isNestedField = isNestedField;
  }
});

// node_modules/gql-query-builder/build/Utils.js
var require_Utils = __commonJS({
  "node_modules/gql-query-builder/build/Utils.js"(exports2) {
    "use strict";
    init_checked_fetch();
    init_modules_watch_stub();
    var __assign = exports2 && exports2.__assign || function() {
      __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
          s = arguments[i];
          for (var p2 in s)
            if (Object.prototype.hasOwnProperty.call(s, p2))
              t[p2] = s[p2];
        }
        return t;
      };
      return __assign.apply(this, arguments);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    var NestedField_1 = require_NestedField();
    var Utils = (
      /** @class */
      function() {
        function Utils2() {
        }
        Utils2.resolveVariables = function(operations) {
          var ret = {};
          for (var _i = 0, operations_1 = operations; _i < operations_1.length; _i++) {
            var _a2 = operations_1[_i], variables = _a2.variables, fields = _a2.fields;
            ret = __assign(__assign(__assign({}, ret), variables), fields && Utils2.getNestedVariables(fields) || {});
          }
          return ret;
        };
        Utils2.queryDataNameAndArgumentMap = function(variables) {
          return variables && Object.keys(variables).length ? "(".concat(Object.entries(variables).reduce(function(dataString, _a2, i) {
            var key = _a2[0], value = _a2[1];
            return "".concat(dataString).concat(i !== 0 ? ", " : "").concat(value && value.name ? value.name : key, ": $").concat(key);
          }, ""), ")") : "";
        };
        Utils2.queryFieldsMap = function(fields) {
          var _this = this;
          return fields ? fields.map(function(field) {
            if ((0, NestedField_1.isNestedField)(field)) {
              return Utils2.queryNestedFieldMap(field);
            } else if (typeof field === "object") {
              var result_1 = "";
              Object.entries(field).forEach(function(_a2, index, array) {
                var key = _a2[0], values = _a2[1];
                result_1 += "".concat(key, " ").concat(values.length > 0 ? "{ " + _this.queryFieldsMap(values) + " }" : "");
                if (index < array.length - 1) {
                  result_1 += ", ";
                }
              });
              return result_1;
            } else {
              return "".concat(field);
            }
          }).join(", ") : "";
        };
        Utils2.operationOrAlias = function(operation) {
          return typeof operation === "string" ? operation : "".concat(operation.alias, ": ").concat(operation.name);
        };
        Utils2.isFragment = function(field) {
          var _a2;
          return (_a2 = (field === null || field === void 0 ? void 0 : field.fragment) === true) !== null && _a2 !== void 0 ? _a2 : false;
        };
        Utils2.operationOrFragment = function(field) {
          return Utils2.isFragment(field) ? field.operation : Utils2.operationOrAlias(field.operation);
        };
        Utils2.getFragment = function(field) {
          return Utils2.isFragment(field) ? "... on " : "";
        };
        Utils2.queryNestedFieldMap = function(field) {
          return "".concat(Utils2.getFragment(field)).concat(Utils2.operationOrFragment(field), " ").concat(this.isFragment(field) ? "" : this.queryDataNameAndArgumentMap(field.variables), " ").concat(field.fields.length > 0 ? "{ " + this.queryFieldsMap(field.fields) + " }" : "");
        };
        Utils2.queryVariablesMap = function(variables, fields) {
          var variablesMapped = {};
          var update2 = function(vars) {
            if (vars) {
              Object.keys(vars).map(function(key) {
                variablesMapped[key] = typeof vars[key] === "object" ? vars[key].value : vars[key];
              });
            }
          };
          update2(variables);
          if (fields && typeof fields === "object") {
            update2(Utils2.getNestedVariables(fields));
          }
          return variablesMapped;
        };
        Utils2.getNestedVariables = function(fields) {
          var variables = {};
          function getDeepestVariables(innerFields) {
            innerFields === null || innerFields === void 0 ? void 0 : innerFields.forEach(function(field) {
              if ((0, NestedField_1.isNestedField)(field)) {
                variables = __assign(__assign(__assign({}, field.variables), variables), field.fields && getDeepestVariables(field.fields));
              } else {
                if (typeof field === "object") {
                  for (var _i = 0, _a2 = Object.entries(field); _i < _a2.length; _i++) {
                    var _b = _a2[_i], value = _b[1];
                    getDeepestVariables(value);
                  }
                }
              }
            });
            return variables;
          }
          getDeepestVariables(fields);
          return variables;
        };
        Utils2.queryDataType = function(variable) {
          var type = "String";
          var value = typeof variable === "object" ? variable.value : variable;
          if ((variable === null || variable === void 0 ? void 0 : variable.type) != null) {
            type = variable.type;
          } else {
            var candidateValue = Array.isArray(value) ? value[0] : value;
            switch (typeof candidateValue) {
              case "object":
                type = "Object";
                break;
              case "boolean":
                type = "Boolean";
                break;
              case "number":
                type = candidateValue % 1 === 0 ? "Int" : "Float";
                break;
            }
          }
          if (typeof variable === "object") {
            if (variable.list === true) {
              type = "[".concat(type, "]");
            } else if (Array.isArray(variable.list)) {
              type = "[".concat(type).concat(variable.list[0] ? "!" : "", "]");
            }
            if (variable.required) {
              type += "!";
            }
          }
          return type;
        };
        return Utils2;
      }()
    );
    exports2.default = Utils;
  }
});

// node_modules/gql-query-builder/build/adapters/DefaultAppSyncMutationAdapter.js
var require_DefaultAppSyncMutationAdapter = __commonJS({
  "node_modules/gql-query-builder/build/adapters/DefaultAppSyncMutationAdapter.js"(exports2) {
    "use strict";
    init_checked_fetch();
    init_modules_watch_stub();
    Object.defineProperty(exports2, "__esModule", { value: true });
    var OperationType_1 = require_OperationType();
    var Utils_1 = require_Utils();
    var DefaultAppSyncMutationAdapter = (
      /** @class */
      function() {
        function DefaultAppSyncMutationAdapter2(options) {
          if (Array.isArray(options)) {
            this.variables = Utils_1.default.resolveVariables(options);
          } else {
            this.variables = options.variables;
            this.fields = options.fields;
            this.operation = options.operation;
          }
        }
        DefaultAppSyncMutationAdapter2.prototype.mutationBuilder = function() {
          return this.operationWrapperTemplate(this.variables, this.operationTemplate(this.operation));
        };
        DefaultAppSyncMutationAdapter2.prototype.mutationsBuilder = function(mutations) {
          var _this = this;
          var content = mutations.map(function(opts) {
            _this.operation = opts.operation;
            _this.variables = opts.variables;
            _this.fields = opts.fields;
            return _this.operationTemplate(opts.operation);
          });
          return this.operationWrapperTemplate(Utils_1.default.resolveVariables(mutations), content.join("\n  "));
        };
        DefaultAppSyncMutationAdapter2.prototype.queryDataNameAndArgumentMap = function() {
          return this.variables && Object.keys(this.variables).length ? "(".concat(Object.keys(this.variables).reduce(function(dataString, key, i) {
            return "".concat(dataString).concat(i !== 0 ? ", " : "").concat(key, ": $").concat(key);
          }, ""), ")") : "";
        };
        DefaultAppSyncMutationAdapter2.prototype.queryDataArgumentAndTypeMap = function(variables) {
          return Object.keys(variables).length ? "(".concat(Object.keys(variables).reduce(function(dataString, key, i) {
            return "".concat(dataString).concat(i !== 0 ? ", " : "", "$").concat(key, ": ").concat(Utils_1.default.queryDataType(variables[key]));
          }, ""), ")") : "";
        };
        DefaultAppSyncMutationAdapter2.prototype.operationWrapperTemplate = function(variables, content) {
          var operation = typeof this.operation === "string" ? this.operation : this.operation.name;
          return {
            query: "".concat(OperationType_1.default.Mutation, " ").concat(operation.charAt(0).toUpperCase() + operation.slice(1), " ").concat(this.queryDataArgumentAndTypeMap(variables), " {\n  ").concat(content, "\n}"),
            variables: Utils_1.default.queryVariablesMap(variables)
          };
        };
        DefaultAppSyncMutationAdapter2.prototype.operationTemplate = function(operation) {
          var operationName = typeof operation === "string" ? operation : "".concat(operation.alias, ": ").concat(operation.name);
          return "".concat(operationName, " ").concat(this.queryDataNameAndArgumentMap(), " {\n    ").concat(this.queryFieldsMap(this.fields), "\n  }");
        };
        DefaultAppSyncMutationAdapter2.prototype.queryFieldsMap = function(fields) {
          var _this = this;
          return Array.isArray(fields) ? fields.map(function(field) {
            return typeof field === "object" ? "".concat(Object.keys(field)[0], " { ").concat(_this.queryFieldsMap(Object.values(field)[0]), " }") : "".concat(field);
          }).join(", ") : "";
        };
        return DefaultAppSyncMutationAdapter2;
      }()
    );
    exports2.default = DefaultAppSyncMutationAdapter;
  }
});

// node_modules/gql-query-builder/build/adapters/DefaultAppSyncQueryAdapter.js
var require_DefaultAppSyncQueryAdapter = __commonJS({
  "node_modules/gql-query-builder/build/adapters/DefaultAppSyncQueryAdapter.js"(exports2) {
    "use strict";
    init_checked_fetch();
    init_modules_watch_stub();
    Object.defineProperty(exports2, "__esModule", { value: true });
    var OperationType_1 = require_OperationType();
    var Utils_1 = require_Utils();
    var DefaultAppSyncQueryAdapter = (
      /** @class */
      function() {
        function DefaultAppSyncQueryAdapter2(options) {
          this.queryDataType = function(variable) {
            var type = "String";
            var value = typeof variable === "object" ? variable.value : variable;
            if (variable.type !== void 0) {
              type = variable.type;
            } else {
              switch (typeof value) {
                case "object":
                  type = "Object";
                  break;
                case "boolean":
                  type = "Boolean";
                  break;
                case "number":
                  type = value % 1 === 0 ? "Int" : "Float";
                  break;
              }
            }
            if (typeof variable === "object" && variable.required) {
              type += "!";
            }
            return type;
          };
          if (Array.isArray(options)) {
            this.variables = Utils_1.default.resolveVariables(options);
          } else {
            this.variables = options.variables;
            this.fields = options.fields || [];
            this.operation = options.operation;
          }
        }
        DefaultAppSyncQueryAdapter2.prototype.queryBuilder = function() {
          return this.operationWrapperTemplate(this.operationTemplate());
        };
        DefaultAppSyncQueryAdapter2.prototype.queriesBuilder = function(queries) {
          var _this = this;
          var content = function() {
            var tmpl = [];
            queries.forEach(function(query2) {
              if (query2) {
                _this.operation = query2.operation;
                _this.fields = query2.fields;
                _this.variables = query2.variables;
                tmpl.push(_this.operationTemplate());
              }
            });
            return tmpl.join(" ");
          };
          return this.operationWrapperTemplate(content());
        };
        DefaultAppSyncQueryAdapter2.prototype.queryDataNameAndArgumentMap = function() {
          return this.variables && Object.keys(this.variables).length ? "(".concat(Object.keys(this.variables).reduce(function(dataString, key, i) {
            return "".concat(dataString).concat(i !== 0 ? ", " : "").concat(key, ": $").concat(key);
          }, ""), ")") : "";
        };
        DefaultAppSyncQueryAdapter2.prototype.queryDataArgumentAndTypeMap = function() {
          var _this = this;
          return this.variables && Object.keys(this.variables).length ? "(".concat(Object.keys(this.variables).reduce(function(dataString, key, i) {
            return "".concat(dataString).concat(i !== 0 ? ", " : "", "$").concat(key, ": ").concat(_this.queryDataType(_this.variables[key]));
          }, ""), ")") : "";
        };
        DefaultAppSyncQueryAdapter2.prototype.operationWrapperTemplate = function(content) {
          var operation = typeof this.operation === "string" ? this.operation : this.operation.name;
          return {
            query: "".concat(OperationType_1.default.Query, " ").concat(operation.charAt(0).toUpperCase()).concat(operation.slice(1), " ").concat(this.queryDataArgumentAndTypeMap(), " { ").concat(content, " }"),
            variables: Utils_1.default.queryVariablesMap(this.variables)
          };
        };
        DefaultAppSyncQueryAdapter2.prototype.operationTemplate = function() {
          var operation = typeof this.operation === "string" ? this.operation : "".concat(this.operation.alias, ": ").concat(this.operation.name);
          return "".concat(operation, " ").concat(this.queryDataNameAndArgumentMap(), " { nodes { ").concat(Utils_1.default.queryFieldsMap(this.fields), " } }");
        };
        return DefaultAppSyncQueryAdapter2;
      }()
    );
    exports2.default = DefaultAppSyncQueryAdapter;
  }
});

// node_modules/gql-query-builder/build/adapters/index.js
var require_adapters = __commonJS({
  "node_modules/gql-query-builder/build/adapters/index.js"(exports2) {
    "use strict";
    init_checked_fetch();
    init_modules_watch_stub();
    Object.defineProperty(exports2, "__esModule", { value: true });
    var DefaultAppSyncMutationAdapter_1 = require_DefaultAppSyncMutationAdapter();
    var DefaultAppSyncQueryAdapter_1 = require_DefaultAppSyncQueryAdapter();
    exports2.default = { DefaultAppSyncQueryAdapter: DefaultAppSyncQueryAdapter_1.default, DefaultAppSyncMutationAdapter: DefaultAppSyncMutationAdapter_1.default };
  }
});

// node_modules/gql-query-builder/build/adapters/DefaultMutationAdapter.js
var require_DefaultMutationAdapter = __commonJS({
  "node_modules/gql-query-builder/build/adapters/DefaultMutationAdapter.js"(exports2) {
    "use strict";
    init_checked_fetch();
    init_modules_watch_stub();
    var __assign = exports2 && exports2.__assign || function() {
      __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
          s = arguments[i];
          for (var p2 in s)
            if (Object.prototype.hasOwnProperty.call(s, p2))
              t[p2] = s[p2];
        }
        return t;
      };
      return __assign.apply(this, arguments);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    var OperationType_1 = require_OperationType();
    var Utils_1 = require_Utils();
    var DefaultMutationAdapter = (
      /** @class */
      function() {
        function DefaultMutationAdapter2(options, configuration) {
          var _this = this;
          if (Array.isArray(options)) {
            this.variables = Utils_1.default.resolveVariables(options);
          } else {
            this.variables = options.variables;
            this.fields = options.fields;
            this.operation = options.operation;
          }
          this.config = {
            operationName: ""
          };
          if (configuration) {
            Object.entries(configuration).forEach(function(_a2) {
              var key = _a2[0], value = _a2[1];
              _this.config[key] = value;
            });
          }
        }
        DefaultMutationAdapter2.prototype.mutationBuilder = function() {
          return this.operationWrapperTemplate(OperationType_1.default.Mutation, this.variables, this.operationTemplate(this.operation));
        };
        DefaultMutationAdapter2.prototype.mutationsBuilder = function(mutations) {
          var _this = this;
          var content = mutations.map(function(opts) {
            _this.operation = opts.operation;
            _this.variables = opts.variables;
            _this.fields = opts.fields;
            return _this.operationTemplate(opts.operation);
          });
          return this.operationWrapperTemplate(OperationType_1.default.Mutation, Utils_1.default.resolveVariables(mutations), content.join("\n  "));
        };
        DefaultMutationAdapter2.prototype.queryDataArgumentAndTypeMap = function(variablesUsed) {
          if (this.fields && typeof this.fields === "object") {
            variablesUsed = __assign(__assign({}, Utils_1.default.getNestedVariables(this.fields)), variablesUsed);
          }
          return variablesUsed && Object.keys(variablesUsed).length > 0 ? "(".concat(Object.keys(variablesUsed).reduce(function(dataString, key, i) {
            return "".concat(dataString).concat(i !== 0 ? ", " : "", "$").concat(key, ": ").concat(Utils_1.default.queryDataType(variablesUsed[key]));
          }, ""), ")") : "";
        };
        DefaultMutationAdapter2.prototype.operationWrapperTemplate = function(type, variables, content) {
          var query2 = "".concat(type, " ").concat(this.queryDataArgumentAndTypeMap(variables), " {\n      ").concat(content, "\n    }");
          if (this.config.operationName) {
            query2 = query2.replace("mutation", "mutation ".concat(this.config.operationName));
          }
          return {
            query: query2,
            variables: Utils_1.default.queryVariablesMap(variables, this.fields)
          };
        };
        DefaultMutationAdapter2.prototype.operationTemplate = function(operation) {
          var operationName = typeof operation === "string" ? operation : "".concat(operation.alias, ": ").concat(operation.name);
          return "".concat(operationName, " ").concat(Utils_1.default.queryDataNameAndArgumentMap(this.variables), " ").concat(this.fields && this.fields.length > 0 ? "{\n    ".concat(Utils_1.default.queryFieldsMap(this.fields), "\n  }") : "");
        };
        return DefaultMutationAdapter2;
      }()
    );
    exports2.default = DefaultMutationAdapter;
  }
});

// node_modules/gql-query-builder/build/adapters/DefaultQueryAdapter.js
var require_DefaultQueryAdapter = __commonJS({
  "node_modules/gql-query-builder/build/adapters/DefaultQueryAdapter.js"(exports2) {
    "use strict";
    init_checked_fetch();
    init_modules_watch_stub();
    var __assign = exports2 && exports2.__assign || function() {
      __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
          s = arguments[i];
          for (var p2 in s)
            if (Object.prototype.hasOwnProperty.call(s, p2))
              t[p2] = s[p2];
        }
        return t;
      };
      return __assign.apply(this, arguments);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    var OperationType_1 = require_OperationType();
    var Utils_1 = require_Utils();
    var DefaultQueryAdapter = (
      /** @class */
      function() {
        function DefaultQueryAdapter2(options, configuration) {
          var _this = this;
          this.config = {
            operationName: ""
          };
          if (configuration) {
            Object.entries(configuration).forEach(function(_a2) {
              var key = _a2[0], value = _a2[1];
              _this.config[key] = value;
            });
          }
          if (Array.isArray(options)) {
            this.variables = Utils_1.default.resolveVariables(options);
          } else {
            this.variables = options.variables;
            this.fields = options.fields || [];
            this.operation = options.operation;
          }
        }
        DefaultQueryAdapter2.prototype.queryBuilder = function() {
          return this.operationWrapperTemplate(this.operationTemplate(this.variables));
        };
        DefaultQueryAdapter2.prototype.queriesBuilder = function(queries) {
          var _this = this;
          var content = function() {
            var tmpl = [];
            queries.forEach(function(query2) {
              if (query2) {
                _this.operation = query2.operation;
                _this.fields = query2.fields;
                tmpl.push(_this.operationTemplate(query2.variables));
              }
            });
            return tmpl.join(" ");
          };
          return this.operationWrapperTemplate(content());
        };
        DefaultQueryAdapter2.prototype.queryDataArgumentAndTypeMap = function() {
          var variablesUsed = this.variables;
          if (this.fields && typeof this.fields === "object") {
            variablesUsed = __assign(__assign({}, Utils_1.default.getNestedVariables(this.fields)), variablesUsed);
          }
          return variablesUsed && Object.keys(variablesUsed).length > 0 ? "(".concat(Object.keys(variablesUsed).reduce(function(dataString, key, i) {
            return "".concat(dataString).concat(i !== 0 ? ", " : "", "$").concat(key, ": ").concat(Utils_1.default.queryDataType(variablesUsed[key]));
          }, ""), ")") : "";
        };
        DefaultQueryAdapter2.prototype.operationWrapperTemplate = function(content) {
          var query2 = "".concat(OperationType_1.default.Query, " ").concat(this.queryDataArgumentAndTypeMap(), " { ").concat(content, " }");
          query2 = query2.replace("query", "query".concat(this.config.operationName !== "" ? " " + this.config.operationName : ""));
          return {
            query: query2,
            variables: Utils_1.default.queryVariablesMap(this.variables, this.fields)
          };
        };
        DefaultQueryAdapter2.prototype.operationTemplate = function(variables) {
          var operation = typeof this.operation === "string" ? this.operation : "".concat(this.operation.alias, ": ").concat(this.operation.name);
          return "".concat(operation, " ").concat(variables ? Utils_1.default.queryDataNameAndArgumentMap(variables) : "", " ").concat(this.fields && this.fields.length > 0 ? "{ " + Utils_1.default.queryFieldsMap(this.fields) + " }" : "");
        };
        return DefaultQueryAdapter2;
      }()
    );
    exports2.default = DefaultQueryAdapter;
  }
});

// node_modules/gql-query-builder/build/adapters/DefaultSubscriptionAdapter.js
var require_DefaultSubscriptionAdapter = __commonJS({
  "node_modules/gql-query-builder/build/adapters/DefaultSubscriptionAdapter.js"(exports2) {
    "use strict";
    init_checked_fetch();
    init_modules_watch_stub();
    Object.defineProperty(exports2, "__esModule", { value: true });
    var OperationType_1 = require_OperationType();
    var Utils_1 = require_Utils();
    var DefaultSubscriptionAdapter = (
      /** @class */
      function() {
        function DefaultSubscriptionAdapter2(options) {
          if (Array.isArray(options)) {
            this.variables = Utils_1.default.resolveVariables(options);
          } else {
            this.variables = options.variables;
            this.fields = options.fields;
            this.operation = options.operation;
          }
        }
        DefaultSubscriptionAdapter2.prototype.subscriptionBuilder = function() {
          return this.operationWrapperTemplate(OperationType_1.default.Subscription, this.variables, this.operationTemplate(this.operation));
        };
        DefaultSubscriptionAdapter2.prototype.subscriptionsBuilder = function(subscriptions) {
          var _this = this;
          var content = subscriptions.map(function(opts) {
            _this.operation = opts.operation;
            _this.variables = opts.variables;
            _this.fields = opts.fields;
            return _this.operationTemplate(opts.operation);
          });
          return this.operationWrapperTemplate(OperationType_1.default.Subscription, Utils_1.default.resolveVariables(subscriptions), content.join("\n  "));
        };
        DefaultSubscriptionAdapter2.prototype.queryDataNameAndArgumentMap = function() {
          return this.variables && Object.keys(this.variables).length ? "(".concat(Object.keys(this.variables).reduce(function(dataString, key, i) {
            return "".concat(dataString).concat(i !== 0 ? ", " : "").concat(key, ": $").concat(key);
          }, ""), ")") : "";
        };
        DefaultSubscriptionAdapter2.prototype.queryDataArgumentAndTypeMap = function(variables) {
          return Object.keys(variables).length ? "(".concat(Object.keys(variables).reduce(function(dataString, key, i) {
            return "".concat(dataString).concat(i !== 0 ? ", " : "", "$").concat(key, ": ").concat(Utils_1.default.queryDataType(variables[key]));
          }, ""), ")") : "";
        };
        DefaultSubscriptionAdapter2.prototype.operationWrapperTemplate = function(type, variables, content) {
          return {
            query: "".concat(type, " ").concat(this.queryDataArgumentAndTypeMap(variables), " {\n  ").concat(content, "\n}"),
            variables: Utils_1.default.queryVariablesMap(variables)
          };
        };
        DefaultSubscriptionAdapter2.prototype.operationTemplate = function(operation) {
          var operationName = typeof this.operation === "string" ? this.operation : "".concat(this.operation.alias, ": ").concat(this.operation.name);
          return "".concat(operationName, " ").concat(this.queryDataNameAndArgumentMap(), " {\n    ").concat(this.queryFieldsMap(this.fields), "\n  }");
        };
        DefaultSubscriptionAdapter2.prototype.queryFieldsMap = function(fields) {
          var _this = this;
          return fields ? fields.map(function(field) {
            return typeof field === "object" ? "".concat(Object.keys(field)[0], " { ").concat(_this.queryFieldsMap(Object.values(field)[0]), " }") : "".concat(field);
          }).join(", ") : "";
        };
        return DefaultSubscriptionAdapter2;
      }()
    );
    exports2.default = DefaultSubscriptionAdapter;
  }
});

// node_modules/gql-query-builder/build/index.js
var require_build = __commonJS({
  "node_modules/gql-query-builder/build/index.js"(exports2) {
    "use strict";
    init_checked_fetch();
    init_modules_watch_stub();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.adapters = exports2.query = exports2.mutation = exports2.subscription = void 0;
    var adapters_1 = require_adapters();
    exports2.adapters = adapters_1.default;
    var DefaultMutationAdapter_1 = require_DefaultMutationAdapter();
    var DefaultQueryAdapter_1 = require_DefaultQueryAdapter();
    var DefaultSubscriptionAdapter_1 = require_DefaultSubscriptionAdapter();
    function queryOperation(options, adapter, config2) {
      var defaultAdapter;
      if (Array.isArray(options)) {
        if (adapter) {
          var customAdapter = new adapter(options, config2);
          return customAdapter.queriesBuilder(options);
        }
        defaultAdapter = new DefaultQueryAdapter_1.default(options, config2);
        return defaultAdapter.queriesBuilder(options);
      }
      if (adapter) {
        var customAdapter = new adapter(options, config2);
        return customAdapter.queryBuilder();
      }
      defaultAdapter = new DefaultQueryAdapter_1.default(options, config2);
      return defaultAdapter.queryBuilder();
    }
    exports2.query = queryOperation;
    function mutationOperation(options, adapter, config2) {
      var customAdapter;
      var defaultAdapter;
      if (Array.isArray(options)) {
        if (adapter) {
          customAdapter = new adapter(options, config2);
          return customAdapter.mutationsBuilder(options);
        }
        defaultAdapter = new DefaultMutationAdapter_1.default(options, config2);
        return defaultAdapter.mutationsBuilder(options);
      }
      if (adapter) {
        customAdapter = new adapter(options, config2);
        return customAdapter.mutationBuilder();
      }
      defaultAdapter = new DefaultMutationAdapter_1.default(options, config2);
      return defaultAdapter.mutationBuilder();
    }
    exports2.mutation = mutationOperation;
    function subscriptionOperation(options, adapter) {
      var customAdapter;
      var defaultAdapter;
      if (Array.isArray(options)) {
        if (adapter) {
          customAdapter = new adapter(options);
          return customAdapter.subscriptionsBuilder(options);
        }
        defaultAdapter = new DefaultSubscriptionAdapter_1.default(options);
        return defaultAdapter.subscriptionsBuilder(options);
      }
      if (adapter) {
        customAdapter = new adapter(options);
        return customAdapter.subscriptionBuilder();
      }
      defaultAdapter = new DefaultSubscriptionAdapter_1.default(options);
      return defaultAdapter.subscriptionBuilder();
    }
    exports2.subscription = subscriptionOperation;
  }
});

// node_modules/@polkadot/wasm-crypto-wasm/cjs/bytes.js
var require_bytes = __commonJS({
  "node_modules/@polkadot/wasm-crypto-wasm/cjs/bytes.js"(exports2) {
    init_checked_fetch();
    init_modules_watch_stub();
    exports2.lenIn = 171008;
    exports2.lenOut = 339468;
    exports2.bytes = "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";
  }
});

// .wrangler/tmp/bundle-KhfhM0/middleware-loader.entry.ts
init_checked_fetch();
init_modules_watch_stub();

// .wrangler/tmp/bundle-KhfhM0/middleware-insertion-facade.js
init_checked_fetch();
init_modules_watch_stub();

// src/index.tsx
init_checked_fetch();
init_modules_watch_stub();

// node_modules/frog/_lib/edge/index.js
init_checked_fetch();
init_modules_watch_stub();

// node_modules/viem/_esm/index.js
init_checked_fetch();
init_modules_watch_stub();
init_abi();
init_encodeFunctionData();
init_getAbiItem();
init_toBytes();
init_toHex();
init_fromBytes();

// node_modules/hono-og/lib/exports/worker.js
init_checked_fetch();
init_modules_watch_stub();

// node_modules/workers-og/dist/index.js
init_checked_fetch();
init_modules_watch_stub();
import ly from "./ef4866ecae192fd87727067cf2c0c0cf9fb8b020-yoga-ZMNYPE6Z.wasm";
import fy from "./8b09a8aa3d916dc11b1a9d60545210c131c1ae36-resvg-LFIOYO65.wasm";
var Xl = Object.create;
var Ka = Object.defineProperty;
var ql = Object.getOwnPropertyDescriptor;
var Yl = Object.getOwnPropertyNames;
var Zl = Object.getPrototypeOf;
var Jl = Object.prototype.hasOwnProperty;
var et = (e, t) => () => (t || e((t = { exports: {} }).exports, t), t.exports);
var Kl = (e, t, r2, n) => {
  if (t && typeof t == "object" || typeof t == "function")
    for (let i of Yl(t))
      !Jl.call(e, i) && i !== r2 && Ka(e, i, { get: () => t[i], enumerable: !(n = ql(t, i)) || n.enumerable });
  return e;
};
var St = (e, t, r2) => (r2 = e != null ? Xl(Zl(e)) : {}, Kl(t || !e || !e.__esModule ? Ka(r2, "default", { value: e, enumerable: true }) : r2, e));
var lo = et((dy, uo) => {
  var di = 0, ro = -3;
  function Ir() {
    this.table = new Uint16Array(16), this.trans = new Uint16Array(288);
  }
  function Ql(e, t) {
    this.source = e, this.sourceIndex = 0, this.tag = 0, this.bitcount = 0, this.dest = t, this.destLen = 0, this.ltree = new Ir(), this.dtree = new Ir();
  }
  var no = new Ir(), io = new Ir(), vi = new Uint8Array(30), gi = new Uint16Array(30), ao = new Uint8Array(30), oo = new Uint16Array(30), ef = new Uint8Array([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]), Qa = new Ir(), Mt = new Uint8Array(320);
  function so(e, t, r2, n) {
    var i, a;
    for (i = 0; i < r2; ++i)
      e[i] = 0;
    for (i = 0; i < 30 - r2; ++i)
      e[i + r2] = i / r2 | 0;
    for (a = n, i = 0; i < 30; ++i)
      t[i] = a, a += 1 << e[i];
  }
  function tf(e, t) {
    var r2;
    for (r2 = 0; r2 < 7; ++r2)
      e.table[r2] = 0;
    for (e.table[7] = 24, e.table[8] = 152, e.table[9] = 112, r2 = 0; r2 < 24; ++r2)
      e.trans[r2] = 256 + r2;
    for (r2 = 0; r2 < 144; ++r2)
      e.trans[24 + r2] = r2;
    for (r2 = 0; r2 < 8; ++r2)
      e.trans[168 + r2] = 280 + r2;
    for (r2 = 0; r2 < 112; ++r2)
      e.trans[176 + r2] = 144 + r2;
    for (r2 = 0; r2 < 5; ++r2)
      t.table[r2] = 0;
    for (t.table[5] = 32, r2 = 0; r2 < 32; ++r2)
      t.trans[r2] = r2;
  }
  var eo = new Uint16Array(16);
  function pi(e, t, r2, n) {
    var i, a;
    for (i = 0; i < 16; ++i)
      e.table[i] = 0;
    for (i = 0; i < n; ++i)
      e.table[t[r2 + i]]++;
    for (e.table[0] = 0, a = 0, i = 0; i < 16; ++i)
      eo[i] = a, a += e.table[i];
    for (i = 0; i < n; ++i)
      t[r2 + i] && (e.trans[eo[t[r2 + i]]++] = i);
  }
  function rf(e) {
    e.bitcount-- || (e.tag = e.source[e.sourceIndex++], e.bitcount = 7);
    var t = e.tag & 1;
    return e.tag >>>= 1, t;
  }
  function Gt(e, t, r2) {
    if (!t)
      return r2;
    for (; e.bitcount < 24; )
      e.tag |= e.source[e.sourceIndex++] << e.bitcount, e.bitcount += 8;
    var n = e.tag & 65535 >>> 16 - t;
    return e.tag >>>= t, e.bitcount -= t, n + r2;
  }
  function hi(e, t) {
    for (; e.bitcount < 24; )
      e.tag |= e.source[e.sourceIndex++] << e.bitcount, e.bitcount += 8;
    var r2 = 0, n = 0, i = 0, a = e.tag;
    do
      n = 2 * n + (a & 1), a >>>= 1, ++i, r2 += t.table[i], n -= t.table[i];
    while (n >= 0);
    return e.tag = a, e.bitcount -= i, t.trans[r2 + n];
  }
  function nf(e, t, r2) {
    var n, i, a, o, u, s;
    for (n = Gt(e, 5, 257), i = Gt(e, 5, 1), a = Gt(e, 4, 4), o = 0; o < 19; ++o)
      Mt[o] = 0;
    for (o = 0; o < a; ++o) {
      var l = Gt(e, 3, 0);
      Mt[ef[o]] = l;
    }
    for (pi(Qa, Mt, 0, 19), u = 0; u < n + i; ) {
      var f = hi(e, Qa);
      switch (f) {
        case 16:
          var c = Mt[u - 1];
          for (s = Gt(e, 2, 3); s; --s)
            Mt[u++] = c;
          break;
        case 17:
          for (s = Gt(e, 3, 3); s; --s)
            Mt[u++] = 0;
          break;
        case 18:
          for (s = Gt(e, 7, 11); s; --s)
            Mt[u++] = 0;
          break;
        default:
          Mt[u++] = f;
          break;
      }
    }
    pi(t, Mt, 0, n), pi(r2, Mt, n, i);
  }
  function to(e, t, r2) {
    for (; ; ) {
      var n = hi(e, t);
      if (n === 256)
        return di;
      if (n < 256)
        e.dest[e.destLen++] = n;
      else {
        var i, a, o, u;
        for (n -= 257, i = Gt(e, vi[n], gi[n]), a = hi(e, r2), o = e.destLen - Gt(e, ao[a], oo[a]), u = o; u < o + i; ++u)
          e.dest[e.destLen++] = e.dest[u];
      }
    }
  }
  function af(e) {
    for (var t, r2, n; e.bitcount > 8; )
      e.sourceIndex--, e.bitcount -= 8;
    if (t = e.source[e.sourceIndex + 1], t = 256 * t + e.source[e.sourceIndex], r2 = e.source[e.sourceIndex + 3], r2 = 256 * r2 + e.source[e.sourceIndex + 2], t !== (~r2 & 65535))
      return ro;
    for (e.sourceIndex += 4, n = t; n; --n)
      e.dest[e.destLen++] = e.source[e.sourceIndex++];
    return e.bitcount = 0, di;
  }
  function of(e, t) {
    var r2 = new Ql(e, t), n, i, a;
    do {
      switch (n = rf(r2), i = Gt(r2, 2, 0), i) {
        case 0:
          a = af(r2);
          break;
        case 1:
          a = to(r2, no, io);
          break;
        case 2:
          nf(r2, r2.ltree, r2.dtree), a = to(r2, r2.ltree, r2.dtree);
          break;
        default:
          a = ro;
      }
      if (a !== di)
        throw new Error("Data error");
    } while (!n);
    return r2.destLen < r2.dest.length ? typeof r2.dest.slice == "function" ? r2.dest.slice(0, r2.destLen) : r2.dest.subarray(0, r2.destLen) : r2.dest;
  }
  tf(no, io);
  so(vi, gi, 4, 3);
  so(ao, oo, 2, 1);
  vi[28] = 0;
  gi[28] = 258;
  uo.exports = of;
});
var po = et((vy, co) => {
  var sf = new Uint8Array(new Uint32Array([305419896]).buffer)[0] === 18, fo = (e, t, r2) => {
    let n = e[t];
    e[t] = e[r2], e[r2] = n;
  }, uf = (e) => {
    let t = e.length;
    for (let r2 = 0; r2 < t; r2 += 4)
      fo(e, r2, r2 + 3), fo(e, r2 + 1, r2 + 2);
  }, lf = (e) => {
    sf && uf(e);
  };
  co.exports = { swap32LE: lf };
});
var mo = et((gy, go) => {
  var ho = lo(), { swap32LE: ff } = po(), yi = 11, vr = 5, cf = yi - vr, pf = 65536 >> yi, hf = 1 << cf, df = hf - 1, dn = 2, vf = 1 << vr, mi = vf - 1, vo = 65536 >> vr, gf = 1024 >> vr, mf = vo + gf, Df = mf, yf = 32, bf = Df + yf, xf = 1 << dn, Di = class {
    constructor(t) {
      let r2 = typeof t.readUInt32BE == "function" && typeof t.slice == "function";
      if (r2 || t instanceof Uint8Array) {
        let n;
        if (r2)
          this.highStart = t.readUInt32LE(0), this.errorValue = t.readUInt32LE(4), n = t.readUInt32LE(8), t = t.slice(12);
        else {
          let i = new DataView(t.buffer);
          this.highStart = i.getUint32(0, true), this.errorValue = i.getUint32(4, true), n = i.getUint32(8, true), t = t.subarray(12);
        }
        t = ho(t, new Uint8Array(n)), t = ho(t, new Uint8Array(n)), ff(t), this.data = new Uint32Array(t.buffer);
      } else
        ({ data: this.data, highStart: this.highStart, errorValue: this.errorValue } = t);
    }
    get(t) {
      let r2;
      return t < 0 || t > 1114111 ? this.errorValue : t < 55296 || t > 56319 && t <= 65535 ? (r2 = (this.data[t >> vr] << dn) + (t & mi), this.data[r2]) : t <= 65535 ? (r2 = (this.data[vo + (t - 55296 >> vr)] << dn) + (t & mi), this.data[r2]) : t < this.highStart ? (r2 = this.data[bf - pf + (t >> yi)], r2 = this.data[r2 + (t >> vr & df)], r2 = (r2 << dn) + (t & mi), this.data[r2]) : this.data[this.data.length - xf];
    }
  };
  go.exports = Di;
});
var Do = et((vn) => {
  var wf = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
  (function(e) {
    "use strict";
    var t = typeof Uint8Array < "u" ? Uint8Array : Array, r2 = 43, n = 47, i = 48, a = 97, o = 65, u = 45, s = 95;
    function l(p2) {
      var d = p2.charCodeAt(0);
      if (d === r2 || d === u)
        return 62;
      if (d === n || d === s)
        return 63;
      if (d < i)
        return -1;
      if (d < i + 10)
        return d - i + 26 + 26;
      if (d < o + 26)
        return d - o;
      if (d < a + 26)
        return d - a + 26;
    }
    function f(p2) {
      var d, D, v, g, y, b;
      if (p2.length % 4 > 0)
        throw new Error("Invalid string. Length must be a multiple of 4");
      var C = p2.length;
      y = p2.charAt(C - 2) === "=" ? 2 : p2.charAt(C - 1) === "=" ? 1 : 0, b = new t(p2.length * 3 / 4 - y), v = y > 0 ? p2.length - 4 : p2.length;
      var k = 0;
      function S(E) {
        b[k++] = E;
      }
      for (d = 0, D = 0; d < v; d += 4, D += 3)
        g = l(p2.charAt(d)) << 18 | l(p2.charAt(d + 1)) << 12 | l(p2.charAt(d + 2)) << 6 | l(p2.charAt(d + 3)), S((g & 16711680) >> 16), S((g & 65280) >> 8), S(g & 255);
      return y === 2 ? (g = l(p2.charAt(d)) << 2 | l(p2.charAt(d + 1)) >> 4, S(g & 255)) : y === 1 && (g = l(p2.charAt(d)) << 10 | l(p2.charAt(d + 1)) << 4 | l(p2.charAt(d + 2)) >> 2, S(g >> 8 & 255), S(g & 255)), b;
    }
    function c(p2) {
      var d, D = p2.length % 3, v = "", g, y;
      function b(k) {
        return wf.charAt(k);
      }
      function C(k) {
        return b(k >> 18 & 63) + b(k >> 12 & 63) + b(k >> 6 & 63) + b(k & 63);
      }
      for (d = 0, y = p2.length - D; d < y; d += 3)
        g = (p2[d] << 16) + (p2[d + 1] << 8) + p2[d + 2], v += C(g);
      switch (D) {
        case 1:
          g = p2[p2.length - 1], v += b(g >> 2), v += b(g << 4 & 63), v += "==";
          break;
        case 2:
          g = (p2[p2.length - 2] << 8) + p2[p2.length - 1], v += b(g >> 10), v += b(g >> 4 & 63), v += b(g << 2 & 63), v += "=";
          break;
      }
      return v;
    }
    e.toByteArray = f, e.fromByteArray = c;
  })(typeof vn > "u" ? vn.base64js = {} : vn);
});
var _o = et((yy, To) => {
  var Fi = 40, Ci = 41, mn = 39, Si = 34, ki = 92, Cr = 47, Ti = 44, _i = 58, Dn = 42, Uf = 117, Bf = 85, Nf = 43, Mf = /^[a-f0-9?-]+$/i;
  To.exports = function(e) {
    for (var t = [], r2 = e, n, i, a, o, u, s, l, f, c = 0, p2 = r2.charCodeAt(c), d = r2.length, D = [{ nodes: t }], v = 0, g, y = "", b = "", C = ""; c < d; )
      if (p2 <= 32) {
        n = c;
        do
          n += 1, p2 = r2.charCodeAt(n);
        while (p2 <= 32);
        o = r2.slice(c, n), a = t[t.length - 1], p2 === Ci && v ? C = o : a && a.type === "div" ? (a.after = o, a.sourceEndIndex += o.length) : p2 === Ti || p2 === _i || p2 === Cr && r2.charCodeAt(n + 1) !== Dn && (!g || g && g.type === "function" && g.value !== "calc") ? b = o : t.push({ type: "space", sourceIndex: c, sourceEndIndex: n, value: o }), c = n;
      } else if (p2 === mn || p2 === Si) {
        n = c, i = p2 === mn ? "'" : '"', o = { type: "string", sourceIndex: c, quote: i };
        do
          if (u = false, n = r2.indexOf(i, n + 1), ~n)
            for (s = n; r2.charCodeAt(s - 1) === ki; )
              s -= 1, u = !u;
          else
            r2 += i, n = r2.length - 1, o.unclosed = true;
        while (u);
        o.value = r2.slice(c + 1, n), o.sourceEndIndex = o.unclosed ? n : n + 1, t.push(o), c = n + 1, p2 = r2.charCodeAt(c);
      } else if (p2 === Cr && r2.charCodeAt(c + 1) === Dn)
        n = r2.indexOf("*/", c), o = { type: "comment", sourceIndex: c, sourceEndIndex: n + 2 }, n === -1 && (o.unclosed = true, n = r2.length, o.sourceEndIndex = n), o.value = r2.slice(c + 2, n), t.push(o), c = n + 2, p2 = r2.charCodeAt(c);
      else if ((p2 === Cr || p2 === Dn) && g && g.type === "function" && g.value === "calc")
        o = r2[c], t.push({ type: "word", sourceIndex: c - b.length, sourceEndIndex: c + o.length, value: o }), c += 1, p2 = r2.charCodeAt(c);
      else if (p2 === Cr || p2 === Ti || p2 === _i)
        o = r2[c], t.push({ type: "div", sourceIndex: c - b.length, sourceEndIndex: c + o.length, value: o, before: b, after: "" }), b = "", c += 1, p2 = r2.charCodeAt(c);
      else if (Fi === p2) {
        n = c;
        do
          n += 1, p2 = r2.charCodeAt(n);
        while (p2 <= 32);
        if (f = c, o = { type: "function", sourceIndex: c - y.length, value: y, before: r2.slice(f + 1, n) }, c = n, y === "url" && p2 !== mn && p2 !== Si) {
          n -= 1;
          do
            if (u = false, n = r2.indexOf(")", n + 1), ~n)
              for (s = n; r2.charCodeAt(s - 1) === ki; )
                s -= 1, u = !u;
            else
              r2 += ")", n = r2.length - 1, o.unclosed = true;
          while (u);
          l = n;
          do
            l -= 1, p2 = r2.charCodeAt(l);
          while (p2 <= 32);
          f < l ? (c !== l + 1 ? o.nodes = [{ type: "word", sourceIndex: c, sourceEndIndex: l + 1, value: r2.slice(c, l + 1) }] : o.nodes = [], o.unclosed && l + 1 !== n ? (o.after = "", o.nodes.push({ type: "space", sourceIndex: l + 1, sourceEndIndex: n, value: r2.slice(l + 1, n) })) : (o.after = r2.slice(l + 1, n), o.sourceEndIndex = n)) : (o.after = "", o.nodes = []), c = n + 1, o.sourceEndIndex = o.unclosed ? n : c, p2 = r2.charCodeAt(c), t.push(o);
        } else
          v += 1, o.after = "", o.sourceEndIndex = c + 1, t.push(o), D.push(o), t = o.nodes = [], g = o;
        y = "";
      } else if (Ci === p2 && v)
        c += 1, p2 = r2.charCodeAt(c), g.after = C, g.sourceEndIndex += C.length, C = "", v -= 1, D[D.length - 1].sourceEndIndex = c, D.pop(), g = D[v], t = g.nodes;
      else {
        n = c;
        do
          p2 === ki && (n += 1), n += 1, p2 = r2.charCodeAt(n);
        while (n < d && !(p2 <= 32 || p2 === mn || p2 === Si || p2 === Ti || p2 === _i || p2 === Cr || p2 === Fi || p2 === Dn && g && g.type === "function" && g.value === "calc" || p2 === Cr && g.type === "function" && g.value === "calc" || p2 === Ci && v));
        o = r2.slice(c, n), Fi === p2 ? y = o : (Uf === o.charCodeAt(0) || Bf === o.charCodeAt(0)) && Nf === o.charCodeAt(1) && Mf.test(o.slice(2)) ? t.push({ type: "unicode-range", sourceIndex: c, sourceEndIndex: n, value: o }) : t.push({ type: "word", sourceIndex: c, sourceEndIndex: n, value: o }), c = n;
      }
    for (c = D.length - 1; c; c -= 1)
      D[c].unclosed = true, D[c].sourceEndIndex = r2.length;
    return D[0].nodes;
  };
});
var Oo = et((by, Ao) => {
  Ao.exports = function e(t, r2, n) {
    var i, a, o, u;
    for (i = 0, a = t.length; i < a; i += 1)
      o = t[i], n || (u = r2(o, i, t)), u !== false && o.type === "function" && Array.isArray(o.nodes) && e(o.nodes, r2, n), n && r2(o, i, t);
  };
});
var Ro = et((xy, Po) => {
  function Lo(e, t) {
    var r2 = e.type, n = e.value, i, a;
    return t && (a = t(e)) !== void 0 ? a : r2 === "word" || r2 === "space" ? n : r2 === "string" ? (i = e.quote || "", i + n + (e.unclosed ? "" : i)) : r2 === "comment" ? "/*" + n + (e.unclosed ? "" : "*/") : r2 === "div" ? (e.before || "") + n + (e.after || "") : Array.isArray(e.nodes) ? (i = Io(e.nodes, t), r2 !== "function" ? i : n + "(" + (e.before || "") + i + (e.after || "") + (e.unclosed ? "" : ")")) : n;
  }
  function Io(e, t) {
    var r2, n;
    if (Array.isArray(e)) {
      for (r2 = "", n = e.length - 1; ~n; n -= 1)
        r2 = Lo(e[n], t) + r2;
      return r2;
    }
    return Lo(e, t);
  }
  Po.exports = Io;
});
var Bo = et((wy, Uo) => {
  var yn = 45, bn = 43, Ai = 46, Gf = 101, Wf = 69;
  function $f(e) {
    var t = e.charCodeAt(0), r2;
    if (t === bn || t === yn) {
      if (r2 = e.charCodeAt(1), r2 >= 48 && r2 <= 57)
        return true;
      var n = e.charCodeAt(2);
      return r2 === Ai && n >= 48 && n <= 57;
    }
    return t === Ai ? (r2 = e.charCodeAt(1), r2 >= 48 && r2 <= 57) : t >= 48 && t <= 57;
  }
  Uo.exports = function(e) {
    var t = 0, r2 = e.length, n, i, a;
    if (r2 === 0 || !$f(e))
      return false;
    for (n = e.charCodeAt(t), (n === bn || n === yn) && t++; t < r2 && (n = e.charCodeAt(t), !(n < 48 || n > 57)); )
      t += 1;
    if (n = e.charCodeAt(t), i = e.charCodeAt(t + 1), n === Ai && i >= 48 && i <= 57)
      for (t += 2; t < r2 && (n = e.charCodeAt(t), !(n < 48 || n > 57)); )
        t += 1;
    if (n = e.charCodeAt(t), i = e.charCodeAt(t + 1), a = e.charCodeAt(t + 2), (n === Gf || n === Wf) && (i >= 48 && i <= 57 || (i === bn || i === yn) && a >= 48 && a <= 57))
      for (t += i === bn || i === yn ? 3 : 2; t < r2 && (n = e.charCodeAt(t), !(n < 48 || n > 57)); )
        t += 1;
    return { number: e.slice(0, t), unit: e.slice(t) };
  };
});
var Oi = et((Ey, Go) => {
  var jf = _o(), No = Oo(), Mo = Ro();
  function nr(e) {
    return this instanceof nr ? (this.nodes = jf(e), this) : new nr(e);
  }
  nr.prototype.toString = function() {
    return Array.isArray(this.nodes) ? Mo(this.nodes) : "";
  };
  nr.prototype.walk = function(e, t) {
    return No(this.nodes, e, t), this;
  };
  nr.unit = Bo();
  nr.walk = No;
  nr.stringify = Mo;
  Go.exports = nr;
});
var jo = et((Fy, $o) => {
  "use strict";
  $o.exports = function(e) {
    return typeof e == "string" ? Wo(e) : Li(e);
  };
  function Li(e) {
    return !e || typeof e != "object" || Vf(e) || Hf(e) ? e : zf(e) ? Yf(e, Li) : Zf(qf(e), function(t, r2) {
      var n = Wo(r2);
      return t[n] = Li(e[r2]), t;
    }, {});
  }
  function Wo(e) {
    return e.replace(/[_.-](\w|$)/g, function(t, r2) {
      return r2.toUpperCase();
    });
  }
  var zf = Array.isArray || function(e) {
    return Object.prototype.toString.call(e) === "[object Array]";
  }, Vf = function(e) {
    return Object.prototype.toString.call(e) === "[object Date]";
  }, Hf = function(e) {
    return Object.prototype.toString.call(e) === "[object RegExp]";
  }, Xf = Object.prototype.hasOwnProperty, qf = Object.keys || function(e) {
    var t = [];
    for (var r2 in e)
      Xf.call(e, r2) && t.push(r2);
    return t;
  };
  function Yf(e, t) {
    if (e.map)
      return e.map(t);
    for (var r2 = [], n = 0; n < e.length; n++)
      r2.push(t(e[n], n));
    return r2;
  }
  function Zf(e, t, r2) {
    if (e.reduce)
      return e.reduce(t, r2);
    for (var n = 0; n < e.length; n++)
      r2 = t(r2, e[n], n);
    return r2;
  }
});
var zo = et((Cy, Jf) => {
  Jf.exports = { black: "#000000", silver: "#c0c0c0", gray: "#808080", white: "#ffffff", maroon: "#800000", red: "#ff0000", purple: "#800080", fuchsia: "#ff00ff", green: "#008000", lime: "#00ff00", olive: "#808000", yellow: "#ffff00", navy: "#000080", blue: "#0000ff", teal: "#008080", aqua: "#00ffff", orange: "#ffa500", aliceblue: "#f0f8ff", antiquewhite: "#faebd7", aquamarine: "#7fffd4", azure: "#f0ffff", beige: "#f5f5dc", bisque: "#ffe4c4", blanchedalmond: "#ffebcd", blueviolet: "#8a2be2", brown: "#a52a2a", burlywood: "#deb887", cadetblue: "#5f9ea0", chartreuse: "#7fff00", chocolate: "#d2691e", coral: "#ff7f50", cornflowerblue: "#6495ed", cornsilk: "#fff8dc", crimson: "#dc143c", darkblue: "#00008b", darkcyan: "#008b8b", darkgoldenrod: "#b8860b", darkgray: "#a9a9a9", darkgreen: "#006400", darkgrey: "#a9a9a9", darkkhaki: "#bdb76b", darkmagenta: "#8b008b", darkolivegreen: "#556b2f", darkorange: "#ff8c00", darkorchid: "#9932cc", darkred: "#8b0000", darksalmon: "#e9967a", darkseagreen: "#8fbc8f", darkslateblue: "#483d8b", darkslategray: "#2f4f4f", darkslategrey: "#2f4f4f", darkturquoise: "#00ced1", darkviolet: "#9400d3", deeppink: "#ff1493", deepskyblue: "#00bfff", dimgray: "#696969", dimgrey: "#696969", dodgerblue: "#1e90ff", firebrick: "#b22222", floralwhite: "#fffaf0", forestgreen: "#228b22", gainsboro: "#dcdcdc", ghostwhite: "#f8f8ff", gold: "#ffd700", goldenrod: "#daa520", greenyellow: "#adff2f", grey: "#808080", honeydew: "#f0fff0", hotpink: "#ff69b4", indianred: "#cd5c5c", indigo: "#4b0082", ivory: "#fffff0", khaki: "#f0e68c", lavender: "#e6e6fa", lavenderblush: "#fff0f5", lawngreen: "#7cfc00", lemonchiffon: "#fffacd", lightblue: "#add8e6", lightcoral: "#f08080", lightcyan: "#e0ffff", lightgoldenrodyellow: "#fafad2", lightgray: "#d3d3d3", lightgreen: "#90ee90", lightgrey: "#d3d3d3", lightpink: "#ffb6c1", lightsalmon: "#ffa07a", lightseagreen: "#20b2aa", lightskyblue: "#87cefa", lightslategray: "#778899", lightslategrey: "#778899", lightsteelblue: "#b0c4de", lightyellow: "#ffffe0", limegreen: "#32cd32", linen: "#faf0e6", mediumaquamarine: "#66cdaa", mediumblue: "#0000cd", mediumorchid: "#ba55d3", mediumpurple: "#9370db", mediumseagreen: "#3cb371", mediumslateblue: "#7b68ee", mediumspringgreen: "#00fa9a", mediumturquoise: "#48d1cc", mediumvioletred: "#c71585", midnightblue: "#191970", mintcream: "#f5fffa", mistyrose: "#ffe4e1", moccasin: "#ffe4b5", navajowhite: "#ffdead", oldlace: "#fdf5e6", olivedrab: "#6b8e23", orangered: "#ff4500", orchid: "#da70d6", palegoldenrod: "#eee8aa", palegreen: "#98fb98", paleturquoise: "#afeeee", palevioletred: "#db7093", papayawhip: "#ffefd5", peachpuff: "#ffdab9", peru: "#cd853f", pink: "#ffc0cb", plum: "#dda0dd", powderblue: "#b0e0e6", rosybrown: "#bc8f8f", royalblue: "#4169e1", saddlebrown: "#8b4513", salmon: "#fa8072", sandybrown: "#f4a460", seagreen: "#2e8b57", seashell: "#fff5ee", sienna: "#a0522d", skyblue: "#87ceeb", slateblue: "#6a5acd", slategray: "#708090", slategrey: "#708090", snow: "#fffafa", springgreen: "#00ff7f", steelblue: "#4682b4", tan: "#d2b48c", thistle: "#d8bfd8", tomato: "#ff6347", turquoise: "#40e0d0", violet: "#ee82ee", wheat: "#f5deb3", whitesmoke: "#f5f5f5", yellowgreen: "#9acd32", rebeccapurple: "#663399" };
});
var Ho = et((Sy, Vo) => {
  "use strict";
  Vo.exports = zo();
});
var wn = et((Tr) => {
  "use strict";
  Object.defineProperty(Tr, "__esModule", { value: true });
  function Bi(e) {
    return e && typeof e == "object" && "default" in e ? e.default : e;
  }
  var Yo = Oi(), Kf = Bi(Yo), Qf = Bi(jo()), ec = Bi(Ho()), tc = function(t) {
    return t.type !== "string" ? null : t.value.replace(/\\([0-9a-f]{1,6})(?:\s|$)/gi, function(r2, n) {
      return String.fromCharCode(parseInt(n, 16));
    }).replace(/\\/g, "");
  }, rc = /^(#(?:[0-9a-f]{3,4}){1,2})$/i, nc = /^(rgba?|hsla?|hwb|lab|lch|gray|color)$/, ic = function(t) {
    return t.type === "word" && (rc.test(t.value) || t.value in ec || t.value === "transparent") ? t.value : t.type === "function" && nc.test(t.value) ? Yo.stringify(t) : null;
  }, ac = /^(none)$/i, oc = /^(auto)$/i, sc = /(^-?[_a-z][_a-z0-9-]*$)/i, uc = /^([+-]?(?:\d*\.)?\d+(?:e[+-]?\d+)?)$/i, lc = /^(0$|(?:[+-]?(?:\d*\.)?\d+(?:e[+-]?\d+)?)(?=px$))/i, fc = /^([+-]?(?:\d*\.)?\d+(?:e[+-]?\d+)?(ch|em|ex|rem|vh|vw|vmin|vmax|cm|mm|in|pc|pt))$/i, cc = /^([+-]?(?:\d*\.)?\d+(?:e[+-]?\d+)?(?:deg|rad))$/i, pc = /^([+-]?(?:\d*\.)?\d+(?:e[+-]?\d+)?%)$/i, Ni = function(t) {
    return function(r2) {
      return t(r2) ? "<token>" : null;
    };
  }, hc = function(t) {
    return function(r2) {
      return r2.type === t ? r2.value : null;
    };
  }, Ve = function(t, r2) {
    return r2 === void 0 && (r2 = String), function(n) {
      if (n.type !== "word")
        return null;
      var i = n.value.match(t);
      if (i === null)
        return null;
      var a = r2(i[1]);
      return a;
    };
  }, Ze = Ni(function(e) {
    return e.type === "space";
  }), Zo = Ni(function(e) {
    return e.type === "div" && e.value === "/";
  }), dc = Ni(function(e) {
    return e.type === "div" && e.value === ",";
  }), vc = hc("word"), Mi = Ve(ac), Ri = Ve(oc), kr = Ve(uc, Number), vt = Ve(lc, Number), Xt = Ve(fc), Jo = Ve(cc, function(e) {
    return e.toLowerCase();
  }), Gi = Ve(pc), xn = Ve(sc), gc = tc, Ur = ic, Ui = Ve(/^(none|underline|line-through)$/i), mc = function(t) {
    var r2 = t.expect(kr);
    return t.hasTokens() && (t.expect(Zo), r2 /= t.expect(kr)), { aspectRatio: r2 };
  }, Dc = Ve(/^(solid|dashed|dotted)$/), yc = 1, bc = "black", xc = "solid", wc = function(t) {
    var r2, n, i;
    if (t.matches(Mi))
      return t.expectEmpty(), { borderWidth: 0, borderColor: "black", borderStyle: "solid" };
    for (var a = 0; a < 3 && t.hasTokens(); )
      a !== 0 && t.expect(Ze), r2 === void 0 && t.matches(vt, Xt) ? r2 = t.lastValue : n === void 0 && t.matches(Ur) ? n = t.lastValue : i === void 0 && t.matches(Dc) ? i = t.lastValue : t.throw(), a += 1;
    return t.expectEmpty(), r2 === void 0 && (r2 = yc), n === void 0 && (n = bc), i === void 0 && (i = xc), { borderWidth: r2, borderColor: n, borderStyle: i };
  }, Br = function(t) {
    var r2 = t.types, n = r2 === void 0 ? [vt, Xt, Gi] : r2, i = t.directions, a = i === void 0 ? ["Top", "Right", "Bottom", "Left"] : i, o = t.prefix, u = o === void 0 ? "" : o, s = t.suffix, l = s === void 0 ? "" : s;
    return function(f) {
      var c, p2 = [];
      for (p2.push(f.expect.apply(f, n)); p2.length < 4 && f.hasTokens(); )
        f.expect(Ze), p2.push(f.expect.apply(f, n));
      f.expectEmpty();
      var d = p2[0], D = p2[1], v = D === void 0 ? d : D, g = p2[2], y = g === void 0 ? d : g, b = p2[3], C = b === void 0 ? v : b, k = function(E) {
        return "" + u + a[E] + l;
      };
      return c = {}, c[k(0)] = d, c[k(1)] = v, c[k(2)] = y, c[k(3)] = C, c;
    };
  }, Ko = function(t) {
    var r2 = t.expect(vt), n = t.matches(Ze) ? t.expect(vt) : r2;
    return t.expectEmpty(), { width: r2, height: n };
  }, Qo = function(t) {
    var r2, n, i, a;
    if (t.matches(Mi))
      return t.expectEmpty(), { offset: { width: 0, height: 0 }, radius: 0, color: "black" };
    for (var o = false; t.hasTokens(); )
      o && t.expect(Ze), r2 === void 0 && t.matches(vt, Xt) ? (r2 = t.lastValue, t.expect(Ze), n = t.expect(vt, Xt), t.saveRewindPoint(), t.matches(Ze) && t.matches(vt, Xt) ? i = t.lastValue : t.rewind()) : a === void 0 && t.matches(Ur) ? a = t.lastValue : t.throw(), o = true;
    return r2 === void 0 && t.throw(), { offset: { width: r2, height: n }, radius: i !== void 0 ? i : 0, color: a !== void 0 ? a : "black" };
  }, Ec = function(t) {
    var r2 = Qo(t), n = r2.offset, i = r2.radius, a = r2.color;
    return { shadowOffset: n, shadowRadius: i, shadowColor: a, shadowOpacity: 1 };
  }, Fc = 1, Cc = 1, Sc = 0, kc = function(t) {
    var r2, n, i;
    if (t.matches(Mi))
      return t.expectEmpty(), { flexGrow: 0, flexShrink: 0, flexBasis: "auto" };
    if (t.saveRewindPoint(), t.matches(Ri) && !t.hasTokens())
      return { flexGrow: 1, flexShrink: 1, flexBasis: "auto" };
    t.rewind();
    for (var a = 0; a < 2 && t.hasTokens(); )
      a !== 0 && t.expect(Ze), r2 === void 0 && t.matches(kr) ? (r2 = t.lastValue, t.saveRewindPoint(), t.matches(Ze) && t.matches(kr) ? n = t.lastValue : t.rewind()) : i === void 0 && t.matches(vt, Xt, Gi) ? i = t.lastValue : i === void 0 && t.matches(Ri) ? i = "auto" : t.throw(), a += 1;
    return t.expectEmpty(), r2 === void 0 && (r2 = Fc), n === void 0 && (n = Cc), i === void 0 && (i = Sc), { flexGrow: r2, flexShrink: n, flexBasis: i };
  }, Tc = Ve(/(nowrap|wrap|wrap-reverse)/), _c = Ve(/(row|row-reverse|column|column-reverse)/), Ac = "nowrap", Oc = "row", Lc = function(t) {
    for (var r2, n, i = 0; i < 2 && t.hasTokens(); )
      i !== 0 && t.expect(Ze), r2 === void 0 && t.matches(Tc) ? r2 = t.lastValue : n === void 0 && t.matches(_c) ? n = t.lastValue : t.throw(), i += 1;
    return t.expectEmpty(), r2 === void 0 && (r2 = Ac), n === void 0 && (n = Oc), { flexWrap: r2, flexDirection: n };
  }, es = function(t) {
    var r2;
    if (t.matches(gc))
      r2 = t.lastValue;
    else
      for (r2 = t.expect(xn); t.hasTokens(); ) {
        t.expect(Ze);
        var n = t.expect(xn);
        r2 += " " + n;
      }
    return t.expectEmpty(), { fontFamily: r2 };
  }, Ic = Ve(/^(normal)$/), Pc = Ve(/^(italic)$/), Rc = Ve(/^([1-9]00|bold)$/), Uc = Ve(/^(small-caps)$/), Bc = "normal", Nc = "normal", Mc = [], Gc = function(t) {
    for (var r2, n, i, a, o = 0; o < 3 && t.hasTokens(); ) {
      if (!t.matches(Ic))
        if (r2 === void 0 && t.matches(Pc))
          r2 = t.lastValue;
        else if (n === void 0 && t.matches(Rc))
          n = t.lastValue;
        else if (i === void 0 && t.matches(Uc))
          i = [t.lastValue];
        else
          break;
      t.expect(Ze), o += 1;
    }
    var u = t.expect(vt, Xt);
    t.matches(Zo) && (a = t.expect(vt, Xt)), t.expect(Ze);
    var s = es(t), l = s.fontFamily;
    r2 === void 0 && (r2 = Bc), n === void 0 && (n = Nc), i === void 0 && (i = Mc);
    var f = { fontStyle: r2, fontWeight: n, fontVariant: i, fontSize: u, fontFamily: l };
    return a !== void 0 && (f.lineHeight = a), f;
  }, Wc = function(t) {
    for (var r2 = [t.expect(xn)]; t.hasTokens(); )
      t.expect(Ze), r2.push(t.expect(xn));
    return { fontVariant: r2 };
  }, $c = Ve(/(flex-(?:start|end)|center|stretch|space-(?:between|around))/), jc = Ve(/(flex-(?:start|end)|center|space-(?:between|around|evenly))/), zc = function(t) {
    var r2 = t.expect($c), n;
    return t.hasTokens() ? (t.expect(Ze), n = t.expect(jc)) : n = "stretch", t.expectEmpty(), { alignContent: r2, justifyContent: n };
  }, Vc = Ve(/^(solid|double|dotted|dashed)$/), Hc = "none", Xc = "solid", qc = "black", Yc = function(t) {
    for (var r2, n, i, a = false; t.hasTokens(); ) {
      if (a && t.expect(Ze), r2 === void 0 && t.matches(Ui)) {
        var o = [t.lastValue.toLowerCase()];
        t.saveRewindPoint(), o[0] !== "none" && t.matches(Ze) && t.matches(Ui) ? (o.push(t.lastValue.toLowerCase()), o.sort().reverse()) : t.rewind(), r2 = o.join(" ");
      } else
        n === void 0 && t.matches(Vc) ? n = t.lastValue : i === void 0 && t.matches(Ur) ? i = t.lastValue : t.throw();
      a = true;
    }
    return { textDecorationLine: r2 !== void 0 ? r2 : Hc, textDecorationColor: i !== void 0 ? i : qc, textDecorationStyle: n !== void 0 ? n : Xc };
  }, Zc = function(t) {
    for (var r2 = [], n = false; t.hasTokens(); )
      n && t.expect(Ze), r2.push(t.expect(Ui).toLowerCase()), n = true;
    return r2.sort().reverse(), { textDecorationLine: r2.join(" ") };
  }, Jc = function(t) {
    var r2 = Qo(t), n = r2.offset, i = r2.radius, a = r2.color;
    return { textShadowOffset: n, textShadowRadius: i, textShadowColor: a };
  }, Wi = function(t) {
    return function(r2) {
      var n = r2.expect(t);
      return r2.expectEmpty(), n;
    };
  }, Ii = Wi(kr), Xo = Wi(vt), Sr = Wi(Jo), $i = function(t) {
    return function(r2, n) {
      return function(i) {
        var a, o, u = i.expect(t), s;
        if (i.hasTokens())
          i.expect(dc), s = i.expect(t);
        else if (n !== void 0)
          s = n;
        else
          return u;
        return i.expectEmpty(), [(a = {}, a[r2 + "Y"] = s, a), (o = {}, o[r2 + "X"] = u, o)];
      };
    };
  }, Kc = $i(kr), Qc = $i(vt), ep = $i(Jo), tp = { perspective: Ii, scale: Kc("scale"), scaleX: Ii, scaleY: Ii, translate: Qc("translate", 0), translateX: Xo, translateY: Xo, rotate: Sr, rotateX: Sr, rotateY: Sr, rotateZ: Sr, skewX: Sr, skewY: Sr, skew: ep("skew", "0deg") }, rp = function(t) {
    for (var r2 = [], n = false; t.hasTokens(); ) {
      n && t.expect(Ze);
      var i = t.expectFunction(), a = i.functionName, o = tp[a](i);
      if (!Array.isArray(o)) {
        var u;
        o = [(u = {}, u[a] = o, u)];
      }
      r2 = o.concat(r2), n = true;
    }
    return { transform: r2 };
  }, np = function(t) {
    return { backgroundColor: t.expect(Ur) };
  }, ip = Br({ types: [Ur], prefix: "border", suffix: "Color" }), ap = Br({ directions: ["TopLeft", "TopRight", "BottomRight", "BottomLeft"], prefix: "border", suffix: "Radius" }), op = Br({ prefix: "border", suffix: "Width" }), sp = Br({ types: [vt, Xt, Gi, Ri], prefix: "margin" }), up = Br({ prefix: "padding" }), lp = function(t) {
    return { fontWeight: t.expect(vc) };
  }, fp = function(t) {
    return { shadowOffset: Ko(t) };
  }, cp = function(t) {
    return { textShadowOffset: Ko(t) };
  }, ts = { aspectRatio: mc, background: np, border: wc, borderColor: ip, borderRadius: ap, borderWidth: op, boxShadow: Ec, flex: kc, flexFlow: Lc, font: Gc, fontFamily: es, fontVariant: Wc, fontWeight: lp, margin: sp, padding: up, placeContent: zc, shadowOffset: fp, textShadow: Jc, textShadowOffset: cp, textDecoration: Yc, textDecorationLine: Zc, transform: rp }, qo, ky = qo != null ? new RegExp(qo.join("|")) : null, Pi = "SYMBOL_MATCH", pp = function() {
    function e(r2, n) {
      this.index = 0, this.nodes = r2, this.functionName = n != null ? n.value : null, this.lastValue = null, this.rewindIndex = -1;
    }
    var t = e.prototype;
    return t.hasTokens = function() {
      return this.index <= this.nodes.length - 1;
    }, t[Pi] = function() {
      if (!this.hasTokens())
        return null;
      for (var r2 = this.nodes[this.index], n = 0; n < arguments.length; n += 1) {
        var i = n < 0 || arguments.length <= n ? void 0 : arguments[n], a = i(r2);
        if (a !== null)
          return this.index += 1, this.lastValue = a, a;
      }
      return null;
    }, t.matches = function() {
      return this[Pi].apply(this, arguments) !== null;
    }, t.expect = function() {
      var n = this[Pi].apply(this, arguments);
      return n !== null ? n : this.throw();
    }, t.matchesFunction = function() {
      var n = this.nodes[this.index];
      if (n.type !== "function")
        return null;
      var i = new e(n.nodes, n);
      return this.index += 1, this.lastValue = null, i;
    }, t.expectFunction = function() {
      var n = this.matchesFunction();
      return n !== null ? n : this.throw();
    }, t.expectEmpty = function() {
      this.hasTokens() && this.throw();
    }, t.throw = function() {
      throw new Error("Unexpected token type: " + this.nodes[this.index].type);
    }, t.saveRewindPoint = function() {
      this.rewindIndex = this.index;
    }, t.rewind = function() {
      if (this.rewindIndex === -1)
        throw new Error("Internal error");
      this.index = this.rewindIndex, this.lastValue = null;
    }, e;
  }(), hp = /^([+-]?(?:\d*\.)?\d+(?:e[+-]?\d+)?)(?:px)?$/i, dp = /^true|false$/i, vp = /^null$/i, gp = /^undefined$/i, rs = function(t, r2) {
    if (0)
      var n, i;
    var a = r2.match(hp);
    if (a !== null)
      return Number(a[1]);
    var o = r2.match(dp);
    if (o !== null)
      return o[0].toLowerCase() === "true";
    var u = r2.match(vp);
    if (u !== null)
      return null;
    var s = r2.match(gp);
    if (s === null)
      return r2;
  }, mp = function(t, r2) {
    var n = Kf(r2), i = new pp(n.nodes);
    return ts[t](i);
  }, Dp = mp, ns = function(t, r2, n) {
    var i, a = n === false || !(t in ts), o = r2.trim(), u = a ? (i = {}, i[t] = rs(t, o), i) : Dp(t, o);
    return u;
  }, is = function(t) {
    var r2 = /^--\w+/.test(t);
    return r2 ? t : Qf(t);
  }, yp = function(t, r2) {
    return r2 === void 0 && (r2 = []), t.reduce(function(n, i) {
      var a = is(i[0]), o = i[1], u = r2.indexOf(a) === -1;
      return Object.assign(n, ns(a, o, u));
    }, {});
  };
  Tr.default = yp;
  Tr.getPropertyName = is;
  Tr.getStylesForProperty = ns;
  Tr.transformRawValue = rs;
});
var os = et((as, En) => {
  (function(e) {
    function t(o) {
      if (!(this instanceof t))
        return new t();
      this.backgrounds = o || [];
    }
    t.prototype.toString = function() {
      return this.backgrounds.join(", ");
    };
    function r2(o) {
      if (!(this instanceof r2))
        return new r2(o);
      o = o || {};
      var u = this;
      function s(l, f) {
        u[l] = l in o ? o[l] : f;
      }
      s("color", ""), s("image", "none"), s("attachment", "scroll"), s("clip", "border-box"), s("origin", "padding-box"), s("position", "0% 0%"), s("repeat", "repeat"), s("size", "auto");
    }
    r2.prototype.toString = function() {
      var o = [this.image, this.repeat, this.attachment, this.position + " / " + this.size, this.origin, this.clip];
      return this.color && o.unshift(this.color), o.join(" ");
    }, e.BackgroundList = t, e.Background = r2;
    function n(o) {
      var u = [], s = /[,\(\)]/, l = 0, f = "";
      if (o == null)
        return u;
      for (; o.length; ) {
        var c = s.exec(o);
        if (!c)
          break;
        var p2 = c[0], d = false;
        switch (p2) {
          case ",":
            l || (u.push(f.trim()), f = "", d = true);
            break;
          case "(":
            l++;
            break;
          case ")":
            l--;
            break;
        }
        var D = c.index + 1;
        f += o.slice(0, d ? D - 1 : D), o = o.slice(D);
      }
      return (f.length || o.length) && u.push((f + o).trim()), u;
    }
    function i(o) {
      return o.trim();
    }
    function a(o) {
      return (o || "").split(",").map(i);
    }
    e.parseElementStyle = function(o) {
      var u = new t();
      if (o == null)
        return u;
      for (var s = n(o.backgroundImage), l = o.backgroundColor, f = a(o.backgroundAttachment), c = a(o.backgroundClip), p2 = a(o.backgroundOrigin), d = a(o.backgroundPosition), D = a(o.backgroundRepeat), v = a(o.backgroundSize), g, y = 0, b = s.length; y < b; y++)
        g = new r2({ image: s[y], attachment: f[y % f.length], clip: c[y % c.length], origin: p2[y % p2.length], position: d[y % d.length], repeat: D[y % D.length], size: v[y % v.length] }), y === b - 1 && (g.color = l), u.backgrounds.push(g);
      return u;
    };
  })(function(e) {
    return typeof En < "u" && En.exports !== void 0 ? En.exports : e.cssBgParser = {};
  }(as));
});
var us = et((_y, ss) => {
  var bp = /,(?![^\(]*\))/, xp = /\s(?![^(]*\))/, wp = /^[0-9]+[a-zA-Z%]+?$/, Ep = (e) => {
    let t = e.split(xp), r2 = t.includes("inset"), n = t.slice(-1)[0], i = Cp(n) ? void 0 : n, a = t.filter((f) => f !== "inset").filter((f) => f !== i).map(Sp), [o, u, s, l] = a;
    return { inset: r2, offsetX: o, offsetY: u, blurRadius: s, spreadRadius: l, color: i };
  }, Fp = (e) => {
    let { inset: t, offsetX: r2 = 0, offsetY: n = 0, blurRadius: i = 0, spreadRadius: a, color: o } = e || {};
    return [t ? "inset" : null, r2, n, i, a, o].filter((u) => u != null).map(kp).map((u) => ("" + u).trim()).join(" ");
  }, Cp = (e) => e === "0" || wp.test(e), Sp = (e) => {
    if (!/px$/.test(e) && e !== "0")
      return e;
    let t = parseFloat(e);
    return isNaN(t) ? e : t;
  }, kp = (e) => typeof e == "number" && e !== 0 ? e + "px" : e, Tp = (e) => e.split(bp).map((t) => t.trim()).map(Ep), _p = (e) => e.map(Fp).join(", ");
  ss.exports = { parse: Tp, stringify: _p };
});
var Vi = et((ji, zi) => {
  (function(e, t) {
    typeof ji == "object" && typeof zi < "u" ? zi.exports = t() : typeof define == "function" && define.amd ? define(t) : (e = e || self).parseCssColor = t();
  })(ji, function() {
    "use strict";
    var e = { aliceblue: [240, 248, 255], antiquewhite: [250, 235, 215], aqua: [0, 255, 255], aquamarine: [127, 255, 212], azure: [240, 255, 255], beige: [245, 245, 220], bisque: [255, 228, 196], black: [0, 0, 0], blanchedalmond: [255, 235, 205], blue: [0, 0, 255], blueviolet: [138, 43, 226], brown: [165, 42, 42], burlywood: [222, 184, 135], cadetblue: [95, 158, 160], chartreuse: [127, 255, 0], chocolate: [210, 105, 30], coral: [255, 127, 80], cornflowerblue: [100, 149, 237], cornsilk: [255, 248, 220], crimson: [220, 20, 60], cyan: [0, 255, 255], darkblue: [0, 0, 139], darkcyan: [0, 139, 139], darkgoldenrod: [184, 134, 11], darkgray: [169, 169, 169], darkgreen: [0, 100, 0], darkgrey: [169, 169, 169], darkkhaki: [189, 183, 107], darkmagenta: [139, 0, 139], darkolivegreen: [85, 107, 47], darkorange: [255, 140, 0], darkorchid: [153, 50, 204], darkred: [139, 0, 0], darksalmon: [233, 150, 122], darkseagreen: [143, 188, 143], darkslateblue: [72, 61, 139], darkslategray: [47, 79, 79], darkslategrey: [47, 79, 79], darkturquoise: [0, 206, 209], darkviolet: [148, 0, 211], deeppink: [255, 20, 147], deepskyblue: [0, 191, 255], dimgray: [105, 105, 105], dimgrey: [105, 105, 105], dodgerblue: [30, 144, 255], firebrick: [178, 34, 34], floralwhite: [255, 250, 240], forestgreen: [34, 139, 34], fuchsia: [255, 0, 255], gainsboro: [220, 220, 220], ghostwhite: [248, 248, 255], gold: [255, 215, 0], goldenrod: [218, 165, 32], gray: [128, 128, 128], green: [0, 128, 0], greenyellow: [173, 255, 47], grey: [128, 128, 128], honeydew: [240, 255, 240], hotpink: [255, 105, 180], indianred: [205, 92, 92], indigo: [75, 0, 130], ivory: [255, 255, 240], khaki: [240, 230, 140], lavender: [230, 230, 250], lavenderblush: [255, 240, 245], lawngreen: [124, 252, 0], lemonchiffon: [255, 250, 205], lightblue: [173, 216, 230], lightcoral: [240, 128, 128], lightcyan: [224, 255, 255], lightgoldenrodyellow: [250, 250, 210], lightgray: [211, 211, 211], lightgreen: [144, 238, 144], lightgrey: [211, 211, 211], lightpink: [255, 182, 193], lightsalmon: [255, 160, 122], lightseagreen: [32, 178, 170], lightskyblue: [135, 206, 250], lightslategray: [119, 136, 153], lightslategrey: [119, 136, 153], lightsteelblue: [176, 196, 222], lightyellow: [255, 255, 224], lime: [0, 255, 0], limegreen: [50, 205, 50], linen: [250, 240, 230], magenta: [255, 0, 255], maroon: [128, 0, 0], mediumaquamarine: [102, 205, 170], mediumblue: [0, 0, 205], mediumorchid: [186, 85, 211], mediumpurple: [147, 112, 219], mediumseagreen: [60, 179, 113], mediumslateblue: [123, 104, 238], mediumspringgreen: [0, 250, 154], mediumturquoise: [72, 209, 204], mediumvioletred: [199, 21, 133], midnightblue: [25, 25, 112], mintcream: [245, 255, 250], mistyrose: [255, 228, 225], moccasin: [255, 228, 181], navajowhite: [255, 222, 173], navy: [0, 0, 128], oldlace: [253, 245, 230], olive: [128, 128, 0], olivedrab: [107, 142, 35], orange: [255, 165, 0], orangered: [255, 69, 0], orchid: [218, 112, 214], palegoldenrod: [238, 232, 170], palegreen: [152, 251, 152], paleturquoise: [175, 238, 238], palevioletred: [219, 112, 147], papayawhip: [255, 239, 213], peachpuff: [255, 218, 185], peru: [205, 133, 63], pink: [255, 192, 203], plum: [221, 160, 221], powderblue: [176, 224, 230], purple: [128, 0, 128], rebeccapurple: [102, 51, 153], red: [255, 0, 0], rosybrown: [188, 143, 143], royalblue: [65, 105, 225], saddlebrown: [139, 69, 19], salmon: [250, 128, 114], sandybrown: [244, 164, 96], seagreen: [46, 139, 87], seashell: [255, 245, 238], sienna: [160, 82, 45], silver: [192, 192, 192], skyblue: [135, 206, 235], slateblue: [106, 90, 205], slategray: [112, 128, 144], slategrey: [112, 128, 144], snow: [255, 250, 250], springgreen: [0, 255, 127], steelblue: [70, 130, 180], tan: [210, 180, 140], teal: [0, 128, 128], thistle: [216, 191, 216], tomato: [255, 99, 71], turquoise: [64, 224, 208], violet: [238, 130, 238], wheat: [245, 222, 179], white: [255, 255, 255], whitesmoke: [245, 245, 245], yellow: [255, 255, 0], yellowgreen: [154, 205, 50] }, t = new RegExp(/^#([a-f0-9]{3,4}|[a-f0-9]{4}(?:[a-f0-9]{2}){1,2})\b$/, "i"), r2 = "-?\\d*(?:\\.\\d+)", n = "(" + r2 + "?)", i = "(" + r2 + "?%)", a = (`^
  hsla?\\(
    \\s*(-?\\d*(?:\\.\\d+)?(?:deg|rad|turn)?)\\s*,
    \\s*` + i + `\\s*,
    \\s*` + i + `\\s*
    (?:,\\s*(-?\\d*(?:\\.\\d+)?%?)\\s*)?
  \\)
  $
`).replace(/\n|\s/g, ""), o = new RegExp(a), u = (`^
  hsla?\\(
    \\s*(-?\\d*(?:\\.\\d+)?(?:deg|rad|turn)?)\\s*
    \\s+` + i + `
    \\s+` + i + `
    \\s*(?:\\s*\\/\\s*(-?\\d*(?:\\.\\d+)?%?)\\s*)?
  \\)
  $
`).replace(/\n|\s/g, ""), s = new RegExp(u), l = (`^
  rgba?\\(
    \\s*` + n + `\\s*,
    \\s*` + n + `\\s*,
    \\s*` + n + `\\s*
    (?:,\\s*(-?\\d*(?:\\.\\d+)?%?)\\s*)?
  \\)
  $
`).replace(/\n|\s/g, ""), f = new RegExp(l), c = (`^
  rgba?\\(
    \\s*` + i + `\\s*,
    \\s*` + i + `\\s*,
    \\s*` + i + `\\s*
    (?:,\\s*(-?\\d*(?:\\.\\d+)?%?)\\s*)?
  \\)
  $
`).replace(/\n|\s/g, ""), p2 = new RegExp(c), d = (`^
  rgba?\\(
    \\s*` + n + `
    \\s+` + n + `
    \\s+` + n + `
    \\s*(?:\\s*\\/\\s*(-?\\d*(?:\\.\\d+)?%?)\\s*)?
  \\)
$
`).replace(/\n|\s/g, ""), D = new RegExp(d), v = (`^
  rgba?\\(
    \\s*` + i + `
    \\s+` + i + `
    \\s+` + i + `
    \\s*(?:\\s*\\/\\s*(-?\\d*(?:\\.\\d+)?%?)\\s*)?
  \\)
$
`).replace(/\n|\s/g, ""), g = new RegExp(v), y = new RegExp(/^transparent$/, "i"), b = new RegExp("[^#a-f\\d]", "gi"), C = new RegExp("^#?[a-f\\d]{3}[a-f\\d]?$|^#?[a-f\\d]{6}([a-f\\d]{2})?$", "i"), k = function(M, H, q) {
      return Math.min(Math.max(H, M), q);
    }, S = function(M) {
      var H = M;
      return typeof H != "number" && (H = H.endsWith("%") ? 255 * parseFloat(H) / 100 : parseFloat(H)), k(Math.round(H), 0, 255);
    }, E = function(M) {
      return k(parseFloat(M), 0, 100);
    };
    function L(M) {
      var H = M;
      return typeof H != "number" && (H = H.endsWith("%") ? parseFloat(H) / 100 : parseFloat(H)), k(H, 0, 1);
    }
    function T(M) {
      var H = function(q, ee) {
        if (ee === void 0 && (ee = {}), typeof q != "string" || b.test(q) || !C.test(q))
          throw new TypeError("Expected a valid hex string");
        var A = 1;
        (q = q.replace(/^#/, "")).length === 8 && (A = Number.parseInt(q.slice(6, 8), 16) / 255, q = q.slice(0, 6)), q.length === 4 && (A = Number.parseInt(q.slice(3, 4).repeat(2), 16) / 255, q = q.slice(0, 3)), q.length === 3 && (q = q[0] + q[0] + q[1] + q[1] + q[2] + q[2]);
        var R = Number.parseInt(q, 16), O = R >> 16, Y = R >> 8 & 255, Z = 255 & R, te = typeof ee.alpha == "number" ? ee.alpha : A;
        return ee.format === "array" ? [O, Y, Z, te] : ee.format === "css" ? "rgb(" + O + " " + Y + " " + Z + (te === 1 ? "" : " / " + Number((100 * te).toFixed(2)) + "%") + ")" : { red: O, green: Y, blue: Z, alpha: te };
      }(M, { format: "array" });
      return U([null, H[0], H[1], H[2], H[3]]);
    }
    function U(M) {
      var H = M[1], q = M[2], ee = M[3], A = M[4];
      return A === void 0 && (A = 1), { type: "rgb", values: [H, q, ee].map(S), alpha: L(A === null ? 1 : A) };
    }
    return function(M) {
      if (typeof M != "string")
        return null;
      var H = t.exec(M);
      if (H)
        return T(H[0]);
      var q = s.exec(M) || o.exec(M);
      if (q)
        return function(R) {
          var O = R[1], Y = R[2], Z = R[3], te = R[4];
          te === void 0 && (te = 1);
          var ie = O;
          return { type: "hsl", values: [ie = ie.endsWith("turn") ? 360 * parseFloat(ie) / 1 : ie.endsWith("rad") ? Math.round(180 * parseFloat(ie) / Math.PI) : parseFloat(ie), E(Y), E(Z)], alpha: L(te === null ? 1 : te) };
        }(q);
      var ee = D.exec(M) || g.exec(M) || f.exec(M) || p2.exec(M);
      if (ee)
        return U(ee);
      if (y.exec(M))
        return U([null, 0, 0, 0, 0]);
      var A = e[M.toLowerCase()];
      return A ? U([null, A[0], A[1], A[2], 1]) : null;
    };
  });
});
var fs = et((Ay, ls) => {
  "use strict";
  var Ap = /["'&<>]/;
  ls.exports = Op;
  function Op(e) {
    var t = "" + e, r2 = Ap.exec(t);
    if (!r2)
      return t;
    var n, i = "", a = 0, o = 0;
    for (a = r2.index; a < t.length; a++) {
      switch (t.charCodeAt(a)) {
        case 34:
          n = "&quot;";
          break;
        case 38:
          n = "&amp;";
          break;
        case 39:
          n = "&#39;";
          break;
        case 60:
          n = "&lt;";
          break;
        case 62:
          n = "&gt;";
          break;
        default:
          continue;
      }
      o !== a && (i += t.substring(o, a)), o = a + 1, i += n;
    }
    return o !== a ? i + t.substring(o, a) : i;
  }
});
var Fo = St(mo(), 1);
var Co = St(Do(), 1);
var Ei = {};
var Ef = 5;
var yo = 12;
var Ff = 13;
var Cf = 16;
var Sf = 17;
var kf = 22;
var bo = 28;
var xo = 31;
var Tf = 33;
var gn = 34;
var _f = 35;
var bi = 36;
var xi = 37;
var So = 38;
var Af = 39;
var Of = 40;
var Pr = 41;
var Lf = 42;
var h = 0;
var m = 1;
var Ee = 2;
var ko = 3;
var F = 4;
var If = [[F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, ko, F, F, F, F, F, F, F, F, F, F, F], [h, F, F, m, m, F, F, F, F, m, m, h, h, h, h, m, m, m, h, h, F, Ee, F, h, h, h, h, h, h, h, h, m, h], [h, F, F, m, m, F, F, F, F, m, m, m, m, m, h, m, m, m, h, h, F, Ee, F, h, h, h, h, h, h, h, h, m, h], [F, F, F, m, m, m, F, F, F, m, m, m, m, m, m, m, m, m, m, m, F, Ee, F, m, m, m, m, m, m, m, m, m, m], [m, F, F, m, m, m, F, F, F, m, m, m, m, m, m, m, m, m, m, m, F, Ee, F, m, m, m, m, m, m, m, m, m, m], [h, F, F, m, m, m, F, F, F, h, h, h, h, h, h, m, m, m, h, h, F, Ee, F, h, h, h, h, h, h, h, h, m, h], [h, F, F, m, m, m, F, F, F, h, h, h, h, h, h, m, m, m, h, h, F, Ee, F, h, h, h, h, h, h, h, h, m, h], [h, F, F, m, m, m, F, F, F, h, h, m, h, m, h, m, m, m, h, h, F, Ee, F, h, h, h, h, h, h, h, h, m, h], [h, F, F, m, m, m, F, F, F, h, h, m, m, m, h, m, m, m, h, h, F, Ee, F, h, h, h, h, h, h, h, h, m, h], [m, F, F, m, m, m, F, F, F, h, h, m, m, m, m, m, m, m, h, h, F, Ee, F, m, m, m, m, m, h, m, m, m, h], [m, F, F, m, m, m, F, F, F, h, h, m, m, m, h, m, m, m, h, h, F, Ee, F, h, h, h, h, h, h, h, h, m, h], [m, F, F, m, m, m, F, F, F, m, m, m, m, m, h, m, m, m, h, h, F, Ee, F, h, h, h, h, h, h, h, h, m, h], [m, F, F, m, m, m, F, F, F, m, m, m, m, m, h, m, m, m, h, h, F, Ee, F, h, h, h, h, h, h, h, h, m, h], [m, F, F, m, m, m, F, F, F, m, m, m, m, m, h, m, m, m, h, h, F, Ee, F, h, h, h, h, h, h, h, h, m, h], [h, F, F, m, m, m, F, F, F, h, m, h, h, h, h, m, m, m, h, h, F, Ee, F, h, h, h, h, h, h, h, h, m, h], [h, F, F, m, m, m, F, F, F, h, h, h, h, h, h, m, m, m, h, h, F, Ee, F, h, h, h, h, h, h, h, h, m, h], [h, F, F, m, h, m, F, F, F, h, h, m, h, h, h, m, m, m, h, h, F, Ee, F, h, h, h, h, h, h, h, h, m, h], [h, F, F, m, h, m, F, F, F, h, h, h, h, h, h, m, m, m, h, h, F, Ee, F, h, h, h, h, h, h, h, h, m, h], [m, F, F, m, m, m, F, F, F, m, m, m, m, m, m, m, m, m, m, m, F, Ee, F, m, m, m, m, m, m, m, m, m, h], [h, F, F, m, m, m, F, F, F, h, h, h, h, h, h, m, m, m, h, F, F, Ee, F, h, h, h, h, h, h, h, h, m, h], [h, h, h, h, h, h, h, h, h, h, h, h, h, h, h, h, h, h, h, h, F, h, h, h, h, h, h, h, h, h, h, h, h], [m, F, F, m, m, m, F, F, F, m, m, m, m, m, h, m, m, m, h, h, F, Ee, F, h, h, h, h, h, h, h, h, m, h], [m, F, F, m, m, m, F, F, F, m, m, m, m, m, m, m, m, m, m, m, F, Ee, F, m, m, m, m, m, m, m, m, m, m], [h, F, F, m, m, m, F, F, F, h, m, h, h, h, h, m, m, m, h, h, F, Ee, F, h, h, h, m, m, h, h, h, m, h], [h, F, F, m, m, m, F, F, F, h, m, h, h, h, h, m, m, m, h, h, F, Ee, F, h, h, h, h, m, h, h, h, m, h], [h, F, F, m, m, m, F, F, F, h, m, h, h, h, h, m, m, m, h, h, F, Ee, F, m, m, m, m, h, h, h, h, m, h], [h, F, F, m, m, m, F, F, F, h, m, h, h, h, h, m, m, m, h, h, F, Ee, F, h, h, h, m, m, h, h, h, m, h], [h, F, F, m, m, m, F, F, F, h, m, h, h, h, h, m, m, m, h, h, F, Ee, F, h, h, h, h, m, h, h, h, m, h], [h, F, F, m, m, m, F, F, F, h, h, h, h, h, h, m, m, m, h, h, F, Ee, F, h, h, h, h, h, m, h, h, m, h], [h, F, F, m, m, m, F, F, F, h, m, h, h, h, h, m, m, m, h, h, F, Ee, F, h, h, h, h, h, h, h, m, m, h], [h, F, F, m, m, m, F, F, F, h, m, h, h, h, h, m, m, m, h, h, F, Ee, F, h, h, h, h, h, h, h, h, m, h], [m, F, F, m, m, m, F, F, F, m, m, m, m, m, h, m, m, m, h, h, F, Ee, F, h, h, h, h, h, h, h, h, m, h], [h, F, F, m, m, h, F, F, F, h, h, h, h, h, h, h, h, h, h, h, F, Ee, F, h, h, h, h, h, h, h, h, m, h]];
var Pf = Co.default.toByteArray("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");
var Rf = new Fo.default(Pf);
var wo = function(e) {
  switch (e) {
    case Tf:
      return yo;
    case Af:
    case Of:
    case Lf:
      return yo;
    case _f:
      return Ef;
    default:
      return e;
  }
};
var Eo = function(e) {
  switch (e) {
    case xi:
    case So:
      return gn;
    case Pr:
      return kf;
    default:
      return e;
  }
};
var Rr = class {
  constructor(t, r2 = false) {
    this.position = t, this.required = r2;
  }
};
var wi = class {
  nextCodePoint() {
    let t = this.string.charCodeAt(this.pos++), r2 = this.string.charCodeAt(this.pos);
    return 55296 <= t && t <= 56319 && 56320 <= r2 && r2 <= 57343 ? (this.pos++, (t - 55296) * 1024 + (r2 - 56320) + 65536) : t;
  }
  nextCharClass() {
    return wo(Rf.get(this.nextCodePoint()));
  }
  getSimpleBreak() {
    switch (this.nextClass) {
      case Pr:
        return false;
      case gn:
      case xi:
      case So:
        return this.curClass = gn, false;
      case bi:
        return this.curClass = bi, false;
    }
    return null;
  }
  getPairTableBreak(t) {
    let r2 = false;
    switch (If[this.curClass][this.nextClass]) {
      case h:
        r2 = true;
        break;
      case m:
        r2 = t === Pr;
        break;
      case Ee:
        if (r2 = t === Pr, !r2)
          return r2 = false, r2;
        break;
      case ko:
        if (t !== Pr)
          return r2;
        break;
      case F:
        break;
    }
    return this.LB8a && (r2 = false), this.LB21a && (this.curClass === Cf || this.curClass === Sf) ? (r2 = false, this.LB21a = false) : this.LB21a = this.curClass === Ff, this.curClass === bo ? (this.LB30a++, this.LB30a == 2 && this.nextClass === bo && (r2 = true, this.LB30a = 0)) : this.LB30a = 0, this.curClass = this.nextClass, r2;
  }
  nextBreak() {
    if (this.curClass == null) {
      let t = this.nextCharClass();
      this.curClass = Eo(t), this.nextClass = t, this.LB8a = t === xo, this.LB30a = 0;
    }
    for (; this.pos < this.string.length; ) {
      this.lastPos = this.pos;
      let t = this.nextClass;
      if (this.nextClass = this.nextCharClass(), this.curClass === gn || this.curClass === bi && this.nextClass !== xi)
        return this.curClass = Eo(wo(this.nextClass)), new Rr(this.lastPos, true);
      let r2 = this.getSimpleBreak();
      if (r2 === null && (r2 = this.getPairTableBreak(t)), this.LB8a = this.nextClass === xo, r2)
        return new Rr(this.lastPos);
    }
    return this.lastPos < this.string.length ? (this.lastPos = this.string.length, new Rr(this.string.length)) : null;
  }
  constructor(t) {
    this.string = t, this.pos = 0, this.lastPos = 0, this.curClass = null, this.nextClass = null, this.LB8a = false, this.LB21a = false, this.LB30a = 0;
  }
};
Ei = wi;
var It = St(wn(), 1);
var gl = St(os(), 1);
var ml = St(us(), 1);
var Dl = St(Vi(), 1);
var yl = St(Oi(), 1);
var bl = St(wn(), 1);
var Fa = St(fs(), 1);
var Fl = St(Vi(), 1);
var Ca = St(wn(), 1);
var wt = Uint8Array;
var mr = Uint16Array;
var Ns = Uint32Array;
var Ms = new wt([0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0, 0, 0, 0]);
var Gs = new wt([0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13, 0, 0]);
var Lp = new wt([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]);
var Ws = function(e, t) {
  for (var r2 = new mr(31), n = 0; n < 31; ++n)
    r2[n] = t += 1 << e[n - 1];
  for (var i = new Ns(r2[30]), n = 1; n < 30; ++n)
    for (var a = r2[n]; a < r2[n + 1]; ++a)
      i[a] = a - r2[n] << 5 | n;
  return [r2, i];
};
var $s = Ws(Ms, 2);
var js = $s[0];
var Ip = $s[1];
js[28] = 258, Ip[258] = 28;
var Pp = Ws(Gs, 0);
var Rp = Pp[0];
var ta = new mr(32768);
for (ke = 0; ke < 32768; ++ke)
  qt = (ke & 43690) >>> 1 | (ke & 21845) << 1, qt = (qt & 52428) >>> 2 | (qt & 13107) << 2, qt = (qt & 61680) >>> 4 | (qt & 3855) << 4, ta[ke] = ((qt & 65280) >>> 8 | (qt & 255) << 8) >>> 1;
var qt;
var ke;
var Mr = function(e, t, r2) {
  for (var n = e.length, i = 0, a = new mr(t); i < n; ++i)
    e[i] && ++a[e[i] - 1];
  var o = new mr(t);
  for (i = 0; i < t; ++i)
    o[i] = o[i - 1] + a[i - 1] << 1;
  var u;
  if (r2) {
    u = new mr(1 << t);
    var s = 15 - t;
    for (i = 0; i < n; ++i)
      if (e[i])
        for (var l = i << 4 | e[i], f = t - e[i], c = o[e[i] - 1]++ << f, p2 = c | (1 << f) - 1; c <= p2; ++c)
          u[ta[c] >>> s] = l;
  } else
    for (u = new mr(n), i = 0; i < n; ++i)
      e[i] && (u[i] = ta[o[e[i] - 1]++] >>> 15 - e[i]);
  return u;
};
var $r = new wt(288);
for (ke = 0; ke < 144; ++ke)
  $r[ke] = 8;
var ke;
for (ke = 144; ke < 256; ++ke)
  $r[ke] = 9;
var ke;
for (ke = 256; ke < 280; ++ke)
  $r[ke] = 7;
var ke;
for (ke = 280; ke < 288; ++ke)
  $r[ke] = 8;
var ke;
var zs = new wt(32);
for (ke = 0; ke < 32; ++ke)
  zs[ke] = 5;
var ke;
var Up = Mr($r, 9, 1);
var Bp = Mr(zs, 5, 1);
var Hi = function(e) {
  for (var t = e[0], r2 = 1; r2 < e.length; ++r2)
    e[r2] > t && (t = e[r2]);
  return t;
};
var kt = function(e, t, r2) {
  var n = t / 8 | 0;
  return (e[n] | e[n + 1] << 8) >> (t & 7) & r2;
};
var Xi = function(e, t) {
  var r2 = t / 8 | 0;
  return (e[r2] | e[r2 + 1] << 8 | e[r2 + 2] << 16) >> (t & 7);
};
var Np = function(e) {
  return (e + 7) / 8 | 0;
};
var Mp = function(e, t, r2) {
  (t == null || t < 0) && (t = 0), (r2 == null || r2 > e.length) && (r2 = e.length);
  var n = new (e.BYTES_PER_ELEMENT == 2 ? mr : e.BYTES_PER_ELEMENT == 4 ? Ns : wt)(r2 - t);
  return n.set(e.subarray(t, r2)), n;
};
var Gp = ["unexpected EOF", "invalid block type", "invalid length/literal", "invalid distance", "stream finished", "no stream handler", , "no callback", "invalid UTF-8 data", "extra field too long", "date not in range 1980-2099", "filename too long", "stream finishing", "invalid zip data"];
var or = function(e, t, r2) {
  var n = new Error(t || Gp[e]);
  if (n.code = e, Error.captureStackTrace && Error.captureStackTrace(n, or), !r2)
    throw n;
  return n;
};
var Wp = function(e, t, r2) {
  var n = e.length;
  if (!n || r2 && r2.f && !r2.l)
    return t || new wt(0);
  var i = !t || r2, a = !r2 || r2.i;
  r2 || (r2 = {}), t || (t = new wt(n * 3));
  var o = function(W) {
    var fe = t.length;
    if (W > fe) {
      var ce = new wt(Math.max(fe * 2, W));
      ce.set(t), t = ce;
    }
  }, u = r2.f || 0, s = r2.p || 0, l = r2.b || 0, f = r2.l, c = r2.d, p2 = r2.m, d = r2.n, D = n * 8;
  do {
    if (!f) {
      u = kt(e, s, 1);
      var v = kt(e, s + 1, 3);
      if (s += 3, v)
        if (v == 1)
          f = Up, c = Bp, p2 = 9, d = 5;
        else if (v == 2) {
          var C = kt(e, s, 31) + 257, k = kt(e, s + 10, 15) + 4, S = C + kt(e, s + 5, 31) + 1;
          s += 14;
          for (var E = new wt(S), L = new wt(19), T = 0; T < k; ++T)
            L[Lp[T]] = kt(e, s + T * 3, 7);
          s += k * 3;
          for (var U = Hi(L), M = (1 << U) - 1, H = Mr(L, U, 1), T = 0; T < S; ) {
            var q = H[kt(e, s, M)];
            s += q & 15;
            var g = q >>> 4;
            if (g < 16)
              E[T++] = g;
            else {
              var ee = 0, A = 0;
              for (g == 16 ? (A = 3 + kt(e, s, 3), s += 2, ee = E[T - 1]) : g == 17 ? (A = 3 + kt(e, s, 7), s += 3) : g == 18 && (A = 11 + kt(e, s, 127), s += 7); A--; )
                E[T++] = ee;
            }
          }
          var R = E.subarray(0, C), O = E.subarray(C);
          p2 = Hi(R), d = Hi(O), f = Mr(R, p2, 1), c = Mr(O, d, 1);
        } else
          or(1);
      else {
        var g = Np(s) + 4, y = e[g - 4] | e[g - 3] << 8, b = g + y;
        if (b > n) {
          a && or(0);
          break;
        }
        i && o(l + y), t.set(e.subarray(g, b), l), r2.b = l += y, r2.p = s = b * 8, r2.f = u;
        continue;
      }
      if (s > D) {
        a && or(0);
        break;
      }
    }
    i && o(l + 131072);
    for (var Y = (1 << p2) - 1, Z = (1 << d) - 1, te = s; ; te = s) {
      var ee = f[Xi(e, s) & Y], ie = ee >>> 4;
      if (s += ee & 15, s > D) {
        a && or(0);
        break;
      }
      if (ee || or(2), ie < 256)
        t[l++] = ie;
      else if (ie == 256) {
        te = s, f = null;
        break;
      } else {
        var B = ie - 254;
        if (ie > 264) {
          var T = ie - 257, z = Ms[T];
          B = kt(e, s, (1 << z) - 1) + js[T], s += z;
        }
        var _ = c[Xi(e, s) & Z], N = _ >>> 4;
        _ || or(3), s += _ & 15;
        var O = Rp[N];
        if (N > 3) {
          var z = Gs[N];
          O += Xi(e, s) & (1 << z) - 1, s += z;
        }
        if (s > D) {
          a && or(0);
          break;
        }
        i && o(l + 131072);
        for (var ae = l + B; l < ae; l += 4)
          t[l] = t[l - O], t[l + 1] = t[l + 1 - O], t[l + 2] = t[l + 2 - O], t[l + 3] = t[l + 3 - O];
        l = ae;
      }
    }
    r2.l = f, r2.p = te, r2.b = l, r2.f = u, f && (u = 1, r2.m = p2, r2.d = c, r2.n = d);
  } while (!u);
  return l == t.length ? t : Mp(t, 0, l);
};
var $p = new wt(0);
function jp(e, t) {
  return Wp(e, t);
}
var zp = typeof TextDecoder < "u" && new TextDecoder();
var Vp = 0;
try {
  zp.decode($p, { stream: true }), Vp = 1;
} catch {
}
function ot() {
  this.commands = [], this.fill = "black", this.stroke = null, this.strokeWidth = 1;
}
ot.prototype.moveTo = function(e, t) {
  this.commands.push({ type: "M", x: e, y: t });
};
ot.prototype.lineTo = function(e, t) {
  this.commands.push({ type: "L", x: e, y: t });
};
ot.prototype.curveTo = ot.prototype.bezierCurveTo = function(e, t, r2, n, i, a) {
  this.commands.push({ type: "C", x1: e, y1: t, x2: r2, y2: n, x: i, y: a });
};
ot.prototype.quadTo = ot.prototype.quadraticCurveTo = function(e, t, r2, n) {
  this.commands.push({ type: "Q", x1: e, y1: t, x: r2, y: n });
};
ot.prototype.close = ot.prototype.closePath = function() {
  this.commands.push({ type: "Z" });
};
ot.prototype.extend = function(e) {
  e.commands && (e = e.commands), Array.prototype.push.apply(this.commands, e);
};
ot.prototype.toPathData = function(e) {
  e = e !== void 0 ? e : 2;
  function t(o) {
    return Math.round(o) === o ? "" + Math.round(o) : o.toFixed(e);
  }
  function r2() {
    for (var o = arguments, u = "", s = 0; s < arguments.length; s += 1) {
      var l = o[s];
      l >= 0 && s > 0 && (u += " "), u += t(l);
    }
    return u;
  }
  for (var n = "", i = 0; i < this.commands.length; i += 1) {
    var a = this.commands[i];
    a.type === "M" ? n += "M" + r2(a.x, a.y) : a.type === "L" ? n += "L" + r2(a.x, a.y) : a.type === "C" ? n += "C" + r2(a.x1, a.y1, a.x2, a.y2, a.x, a.y) : a.type === "Q" ? n += "Q" + r2(a.x1, a.y1, a.x, a.y) : a.type === "Z" && (n += "Z");
  }
  return n;
};
var Hp = [".notdef", "space", "exclam", "quotedbl", "numbersign", "dollar", "percent", "ampersand", "quoteright", "parenleft", "parenright", "asterisk", "plus", "comma", "hyphen", "period", "slash", "zero", "one", "two", "three", "four", "five", "six", "seven", "eight", "nine", "colon", "semicolon", "less", "equal", "greater", "question", "at", "A", "B", "C", "D", "E", "F", "G", "H", "I", "J", "K", "L", "M", "N", "O", "P", "Q", "R", "S", "T", "U", "V", "W", "X", "Y", "Z", "bracketleft", "backslash", "bracketright", "asciicircum", "underscore", "quoteleft", "a", "b", "c", "d", "e", "f", "g", "h", "i", "j", "k", "l", "m", "n", "o", "p", "q", "r", "s", "t", "u", "v", "w", "x", "y", "z", "braceleft", "bar", "braceright", "asciitilde", "exclamdown", "cent", "sterling", "fraction", "yen", "florin", "section", "currency", "quotesingle", "quotedblleft", "guillemotleft", "guilsinglleft", "guilsinglright", "fi", "fl", "endash", "dagger", "daggerdbl", "periodcentered", "paragraph", "bullet", "quotesinglbase", "quotedblbase", "quotedblright", "guillemotright", "ellipsis", "perthousand", "questiondown", "grave", "acute", "circumflex", "tilde", "macron", "breve", "dotaccent", "dieresis", "ring", "cedilla", "hungarumlaut", "ogonek", "caron", "emdash", "AE", "ordfeminine", "Lslash", "Oslash", "OE", "ordmasculine", "ae", "dotlessi", "lslash", "oslash", "oe", "germandbls", "onesuperior", "logicalnot", "mu", "trademark", "Eth", "onehalf", "plusminus", "Thorn", "onequarter", "divide", "brokenbar", "degree", "thorn", "threequarters", "twosuperior", "registered", "minus", "eth", "multiply", "threesuperior", "copyright", "Aacute", "Acircumflex", "Adieresis", "Agrave", "Aring", "Atilde", "Ccedilla", "Eacute", "Ecircumflex", "Edieresis", "Egrave", "Iacute", "Icircumflex", "Idieresis", "Igrave", "Ntilde", "Oacute", "Ocircumflex", "Odieresis", "Ograve", "Otilde", "Scaron", "Uacute", "Ucircumflex", "Udieresis", "Ugrave", "Yacute", "Ydieresis", "Zcaron", "aacute", "acircumflex", "adieresis", "agrave", "aring", "atilde", "ccedilla", "eacute", "ecircumflex", "edieresis", "egrave", "iacute", "icircumflex", "idieresis", "igrave", "ntilde", "oacute", "ocircumflex", "odieresis", "ograve", "otilde", "scaron", "uacute", "ucircumflex", "udieresis", "ugrave", "yacute", "ydieresis", "zcaron", "exclamsmall", "Hungarumlautsmall", "dollaroldstyle", "dollarsuperior", "ampersandsmall", "Acutesmall", "parenleftsuperior", "parenrightsuperior", "266 ff", "onedotenleader", "zerooldstyle", "oneoldstyle", "twooldstyle", "threeoldstyle", "fouroldstyle", "fiveoldstyle", "sixoldstyle", "sevenoldstyle", "eightoldstyle", "nineoldstyle", "commasuperior", "threequartersemdash", "periodsuperior", "questionsmall", "asuperior", "bsuperior", "centsuperior", "dsuperior", "esuperior", "isuperior", "lsuperior", "msuperior", "nsuperior", "osuperior", "rsuperior", "ssuperior", "tsuperior", "ff", "ffi", "ffl", "parenleftinferior", "parenrightinferior", "Circumflexsmall", "hyphensuperior", "Gravesmall", "Asmall", "Bsmall", "Csmall", "Dsmall", "Esmall", "Fsmall", "Gsmall", "Hsmall", "Ismall", "Jsmall", "Ksmall", "Lsmall", "Msmall", "Nsmall", "Osmall", "Psmall", "Qsmall", "Rsmall", "Ssmall", "Tsmall", "Usmall", "Vsmall", "Wsmall", "Xsmall", "Ysmall", "Zsmall", "colonmonetary", "onefitted", "rupiah", "Tildesmall", "exclamdownsmall", "centoldstyle", "Lslashsmall", "Scaronsmall", "Zcaronsmall", "Dieresissmall", "Brevesmall", "Caronsmall", "Dotaccentsmall", "Macronsmall", "figuredash", "hypheninferior", "Ogoneksmall", "Ringsmall", "Cedillasmall", "questiondownsmall", "oneeighth", "threeeighths", "fiveeighths", "seveneighths", "onethird", "twothirds", "zerosuperior", "foursuperior", "fivesuperior", "sixsuperior", "sevensuperior", "eightsuperior", "ninesuperior", "zeroinferior", "oneinferior", "twoinferior", "threeinferior", "fourinferior", "fiveinferior", "sixinferior", "seveninferior", "eightinferior", "nineinferior", "centinferior", "dollarinferior", "periodinferior", "commainferior", "Agravesmall", "Aacutesmall", "Acircumflexsmall", "Atildesmall", "Adieresissmall", "Aringsmall", "AEsmall", "Ccedillasmall", "Egravesmall", "Eacutesmall", "Ecircumflexsmall", "Edieresissmall", "Igravesmall", "Iacutesmall", "Icircumflexsmall", "Idieresissmall", "Ethsmall", "Ntildesmall", "Ogravesmall", "Oacutesmall", "Ocircumflexsmall", "Otildesmall", "Odieresissmall", "OEsmall", "Oslashsmall", "Ugravesmall", "Uacutesmall", "Ucircumflexsmall", "Udieresissmall", "Yacutesmall", "Thornsmall", "Ydieresissmall", "001.000", "001.001", "001.002", "001.003", "Black", "Bold", "Book", "Light", "Medium", "Regular", "Roman", "Semibold"];
var Xp = ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "space", "exclam", "quotedbl", "numbersign", "dollar", "percent", "ampersand", "quoteright", "parenleft", "parenright", "asterisk", "plus", "comma", "hyphen", "period", "slash", "zero", "one", "two", "three", "four", "five", "six", "seven", "eight", "nine", "colon", "semicolon", "less", "equal", "greater", "question", "at", "A", "B", "C", "D", "E", "F", "G", "H", "I", "J", "K", "L", "M", "N", "O", "P", "Q", "R", "S", "T", "U", "V", "W", "X", "Y", "Z", "bracketleft", "backslash", "bracketright", "asciicircum", "underscore", "quoteleft", "a", "b", "c", "d", "e", "f", "g", "h", "i", "j", "k", "l", "m", "n", "o", "p", "q", "r", "s", "t", "u", "v", "w", "x", "y", "z", "braceleft", "bar", "braceright", "asciitilde", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "exclamdown", "cent", "sterling", "fraction", "yen", "florin", "section", "currency", "quotesingle", "quotedblleft", "guillemotleft", "guilsinglleft", "guilsinglright", "fi", "fl", "", "endash", "dagger", "daggerdbl", "periodcentered", "", "paragraph", "bullet", "quotesinglbase", "quotedblbase", "quotedblright", "guillemotright", "ellipsis", "perthousand", "", "questiondown", "", "grave", "acute", "circumflex", "tilde", "macron", "breve", "dotaccent", "dieresis", "", "ring", "cedilla", "", "hungarumlaut", "ogonek", "caron", "emdash", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "AE", "", "ordfeminine", "", "", "", "", "Lslash", "Oslash", "OE", "ordmasculine", "", "", "", "", "", "ae", "", "", "", "dotlessi", "", "", "lslash", "oslash", "oe", "germandbls"];
var qp = ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "space", "exclamsmall", "Hungarumlautsmall", "", "dollaroldstyle", "dollarsuperior", "ampersandsmall", "Acutesmall", "parenleftsuperior", "parenrightsuperior", "twodotenleader", "onedotenleader", "comma", "hyphen", "period", "fraction", "zerooldstyle", "oneoldstyle", "twooldstyle", "threeoldstyle", "fouroldstyle", "fiveoldstyle", "sixoldstyle", "sevenoldstyle", "eightoldstyle", "nineoldstyle", "colon", "semicolon", "commasuperior", "threequartersemdash", "periodsuperior", "questionsmall", "", "asuperior", "bsuperior", "centsuperior", "dsuperior", "esuperior", "", "", "isuperior", "", "", "lsuperior", "msuperior", "nsuperior", "osuperior", "", "", "rsuperior", "ssuperior", "tsuperior", "", "ff", "fi", "fl", "ffi", "ffl", "parenleftinferior", "", "parenrightinferior", "Circumflexsmall", "hyphensuperior", "Gravesmall", "Asmall", "Bsmall", "Csmall", "Dsmall", "Esmall", "Fsmall", "Gsmall", "Hsmall", "Ismall", "Jsmall", "Ksmall", "Lsmall", "Msmall", "Nsmall", "Osmall", "Psmall", "Qsmall", "Rsmall", "Ssmall", "Tsmall", "Usmall", "Vsmall", "Wsmall", "Xsmall", "Ysmall", "Zsmall", "colonmonetary", "onefitted", "rupiah", "Tildesmall", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "exclamdownsmall", "centoldstyle", "Lslashsmall", "", "", "Scaronsmall", "Zcaronsmall", "Dieresissmall", "Brevesmall", "Caronsmall", "", "Dotaccentsmall", "", "", "Macronsmall", "", "", "figuredash", "hypheninferior", "", "", "Ogoneksmall", "Ringsmall", "Cedillasmall", "", "", "", "onequarter", "onehalf", "threequarters", "questiondownsmall", "oneeighth", "threeeighths", "fiveeighths", "seveneighths", "onethird", "twothirds", "", "", "zerosuperior", "onesuperior", "twosuperior", "threesuperior", "foursuperior", "fivesuperior", "sixsuperior", "sevensuperior", "eightsuperior", "ninesuperior", "zeroinferior", "oneinferior", "twoinferior", "threeinferior", "fourinferior", "fiveinferior", "sixinferior", "seveninferior", "eightinferior", "nineinferior", "centinferior", "dollarinferior", "periodinferior", "commainferior", "Agravesmall", "Aacutesmall", "Acircumflexsmall", "Atildesmall", "Adieresissmall", "Aringsmall", "AEsmall", "Ccedillasmall", "Egravesmall", "Eacutesmall", "Ecircumflexsmall", "Edieresissmall", "Igravesmall", "Iacutesmall", "Icircumflexsmall", "Idieresissmall", "Ethsmall", "Ntildesmall", "Ogravesmall", "Oacutesmall", "Ocircumflexsmall", "Otildesmall", "Odieresissmall", "OEsmall", "Oslashsmall", "Ugravesmall", "Uacutesmall", "Ucircumflexsmall", "Udieresissmall", "Yacutesmall", "Thornsmall", "Ydieresissmall"];
function Vs(e) {
  this.font = e;
}
Vs.prototype.charToGlyphIndex = function(e) {
  var t = e.codePointAt(0), r2 = this.font.glyphs;
  if (r2) {
    for (var n = 0; n < r2.length; n += 1)
      for (var i = r2.get(n), a = 0; a < i.unicodes.length; a += 1)
        if (i.unicodes[a] === t)
          return n;
  }
  return null;
};
function Hs(e) {
  this.cmap = e;
}
Hs.prototype.charToGlyphIndex = function(e) {
  return this.cmap.glyphIndexMap[e.codePointAt(0)] || 0;
};
function kn(e, t) {
  this.encoding = e, this.charset = t;
}
kn.prototype.charToGlyphIndex = function(e) {
  var t = e.codePointAt(0), r2 = this.encoding[t];
  return this.charset.indexOf(r2);
};
function Yp(e) {
  for (var t, r2 = e.tables.cmap.glyphIndexMap, n = Object.keys(r2), i = 0; i < n.length; i += 1) {
    var a = n[i], o = r2[a];
    t = e.glyphs.get(o), t.addUnicode(parseInt(a));
  }
}
function Zp(e) {
  e._IndexToUnicodeMap = {};
  for (var t = e.tables.cmap.glyphIndexMap, r2 = Object.keys(t), n = 0; n < r2.length; n += 1) {
    var i = r2[n], a = t[i];
    e._IndexToUnicodeMap[a] === void 0 ? e._IndexToUnicodeMap[a] = { unicodes: [parseInt(i)] } : e._IndexToUnicodeMap[a].unicodes.push(parseInt(i));
  }
}
function Jp(e, t) {
  t.lowMemory ? Zp(e) : Yp(e);
}
function Xs(e) {
  throw new Error(e);
}
function cs(e, t) {
  e || Xs(t);
}
var Te = { fail: Xs, argument: cs, assert: cs };
function Kp(e, t) {
  var r2 = t || new ot();
  return { configurable: true, get: function() {
    return typeof r2 == "function" && (r2 = r2()), r2;
  }, set: function(n) {
    r2 = n;
  } };
}
function Jt(e) {
  this.bindConstructorValues(e);
}
Jt.prototype.bindConstructorValues = function(e) {
  this.index = e.index || 0, this.name = e.name || null, this.unicode = e.unicode || void 0, this.unicodes = e.unicodes || e.unicode !== void 0 ? [e.unicode] : [], "xMin" in e && (this.xMin = e.xMin), "yMin" in e && (this.yMin = e.yMin), "xMax" in e && (this.xMax = e.xMax), "yMax" in e && (this.yMax = e.yMax), "advanceWidth" in e && (this.advanceWidth = e.advanceWidth), Object.defineProperty(this, "path", Kp(this, e.path));
};
Jt.prototype.addUnicode = function(e) {
  this.unicodes.length === 0 && (this.unicode = e), this.unicodes.push(e);
};
Jt.prototype.getPath = function(e, t, r2, n, i) {
  e = e !== void 0 ? e : 0, t = t !== void 0 ? t : 0, r2 = r2 !== void 0 ? r2 : 72;
  var a, o;
  n || (n = {});
  var u = n.xScale, s = n.yScale;
  if (n.hinting && i && i.hinting && (o = this.path && i.hinting.exec(this, r2)), o)
    a = i.hinting.getCommands(o), e = Math.round(e), t = Math.round(t), u = s = 1;
  else {
    a = this.path.commands;
    var l = 1 / (this.path.unitsPerEm || 1e3) * r2;
    u === void 0 && (u = l), s === void 0 && (s = l);
  }
  for (var f = new ot(), c = 0; c < a.length; c += 1) {
    var p2 = a[c];
    p2.type === "M" ? f.moveTo(e + p2.x * u, t + -p2.y * s) : p2.type === "L" ? f.lineTo(e + p2.x * u, t + -p2.y * s) : p2.type === "Q" ? f.quadraticCurveTo(e + p2.x1 * u, t + -p2.y1 * s, e + p2.x * u, t + -p2.y * s) : p2.type === "C" ? f.curveTo(e + p2.x1 * u, t + -p2.y1 * s, e + p2.x2 * u, t + -p2.y2 * s, e + p2.x * u, t + -p2.y * s) : p2.type === "Z" && f.closePath();
  }
  return f;
};
Jt.prototype.getContours = function() {
  if (this.points === void 0)
    return [];
  for (var e = [], t = [], r2 = 0; r2 < this.points.length; r2 += 1) {
    var n = this.points[r2];
    t.push(n), n.lastPointOfContour && (e.push(t), t = []);
  }
  return Te.argument(t.length === 0, "There are still points left in the current contour."), e;
};
Jt.prototype.getMetrics = function() {
  for (var e = this.path.commands, t = [], r2 = [], n = 0; n < e.length; n += 1) {
    var i = e[n];
    i.type !== "Z" && (t.push(i.x), r2.push(i.y)), (i.type === "Q" || i.type === "C") && (t.push(i.x1), r2.push(i.y1)), i.type === "C" && (t.push(i.x2), r2.push(i.y2));
  }
  var a = { xMin: Math.min.apply(null, t), yMin: Math.min.apply(null, r2), xMax: Math.max.apply(null, t), yMax: Math.max.apply(null, r2), leftSideBearing: this.leftSideBearing };
  return isFinite(a.xMin) || (a.xMin = 0), isFinite(a.xMax) || (a.xMax = this.advanceWidth), isFinite(a.yMin) || (a.yMin = 0), isFinite(a.yMax) || (a.yMax = 0), a.rightSideBearing = this.advanceWidth - a.leftSideBearing - (a.xMax - a.xMin), a;
};
function Fn(e, t, r2) {
  Object.defineProperty(e, t, { get: function() {
    return e.path, e[r2];
  }, set: function(n) {
    e[r2] = n;
  }, enumerable: true, configurable: true });
}
function ia(e, t) {
  if (this.font = e, this.glyphs = {}, Array.isArray(t))
    for (var r2 = 0; r2 < t.length; r2++) {
      var n = t[r2];
      n.path.unitsPerEm = e.unitsPerEm, this.glyphs[r2] = n;
    }
  this.length = t && t.length || 0;
}
ia.prototype.get = function(e) {
  if (this.glyphs[e] === void 0) {
    this.font._push(e), typeof this.glyphs[e] == "function" && (this.glyphs[e] = this.glyphs[e]());
    var t = this.glyphs[e], r2 = this.font._IndexToUnicodeMap[e];
    if (r2)
      for (var n = 0; n < r2.unicodes.length; n++)
        t.addUnicode(r2.unicodes[n]);
    this.glyphs[e].advanceWidth = this.font._hmtxTableData[e].advanceWidth, this.glyphs[e].leftSideBearing = this.font._hmtxTableData[e].leftSideBearing;
  } else
    typeof this.glyphs[e] == "function" && (this.glyphs[e] = this.glyphs[e]());
  return this.glyphs[e];
};
ia.prototype.push = function(e, t) {
  this.glyphs[e] = t, this.length++;
};
function Qp(e, t) {
  return new Jt({ index: t, font: e });
}
function eh(e, t, r2, n, i, a) {
  return function() {
    var o = new Jt({ index: t, font: e });
    return o.path = function() {
      r2(o, n, i);
      var u = a(e.glyphs, o);
      return u.unitsPerEm = e.unitsPerEm, u;
    }, Fn(o, "xMin", "_xMin"), Fn(o, "xMax", "_xMax"), Fn(o, "yMin", "_yMin"), Fn(o, "yMax", "_yMax"), o;
  };
}
function th(e, t, r2, n) {
  return function() {
    var i = new Jt({ index: t, font: e });
    return i.path = function() {
      var a = r2(e, i, n);
      return a.unitsPerEm = e.unitsPerEm, a;
    }, i;
  };
}
var $t = { GlyphSet: ia, glyphLoader: Qp, ttfGlyphLoader: eh, cffGlyphLoader: th };
function qi(e, t) {
  for (var r2 = 0, n = e.length - 1; r2 <= n; ) {
    var i = r2 + n >>> 1, a = e[i].tag;
    if (a === t)
      return i;
    a < t ? r2 = i + 1 : n = i - 1;
  }
  return -r2 - 1;
}
function ps(e, t) {
  for (var r2 = 0, n = e.length - 1; r2 <= n; ) {
    var i = r2 + n >>> 1, a = e[i];
    if (a === t)
      return i;
    a < t ? r2 = i + 1 : n = i - 1;
  }
  return -r2 - 1;
}
function hs(e, t) {
  for (var r2, n = 0, i = e.length - 1; n <= i; ) {
    var a = n + i >>> 1;
    r2 = e[a];
    var o = r2.start;
    if (o === t)
      return r2;
    o < t ? n = a + 1 : i = a - 1;
  }
  if (n > 0)
    return r2 = e[n - 1], t > r2.end ? 0 : r2;
}
function jr(e, t) {
  this.font = e, this.tableName = t;
}
jr.prototype = { searchTag: qi, binSearch: ps, getTable: function(e) {
  var t = this.font.tables[this.tableName];
  return !t && e && (t = this.font.tables[this.tableName] = this.createDefaultTable()), t;
}, getDefaultScriptName: function() {
  var e = this.getTable();
  if (e) {
    for (var t = false, r2 = 0; r2 < e.scripts.length; r2++) {
      var n = e.scripts[r2].tag;
      if (n === "DFLT")
        return n;
      n === "latn" && (t = true);
    }
    if (t)
      return "latn";
  }
}, getScriptTable: function(e, t) {
  var r2 = this.getTable(t);
  if (r2) {
    e = e || "DFLT";
    var n = r2.scripts, i = qi(r2.scripts, e);
    if (i >= 0)
      return n[i].script;
    if (t) {
      var a = { tag: e, script: { defaultLangSys: { reserved: 0, reqFeatureIndex: 65535, featureIndexes: [] }, langSysRecords: [] } };
      return n.splice(-1 - i, 0, a), a.script;
    }
  }
}, getLangSysTable: function(e, t, r2) {
  var n = this.getScriptTable(e, r2);
  if (n) {
    if (!t || t === "dflt" || t === "DFLT")
      return n.defaultLangSys;
    var i = qi(n.langSysRecords, t);
    if (i >= 0)
      return n.langSysRecords[i].langSys;
    if (r2) {
      var a = { tag: t, langSys: { reserved: 0, reqFeatureIndex: 65535, featureIndexes: [] } };
      return n.langSysRecords.splice(-1 - i, 0, a), a.langSys;
    }
  }
}, getFeatureTable: function(e, t, r2, n) {
  var i = this.getLangSysTable(e, t, n);
  if (i) {
    for (var a, o = i.featureIndexes, u = this.font.tables[this.tableName].features, s = 0; s < o.length; s++)
      if (a = u[o[s]], a.tag === r2)
        return a.feature;
    if (n) {
      var l = u.length;
      return Te.assert(l === 0 || r2 >= u[l - 1].tag, "Features must be added in alphabetical order."), a = { tag: r2, feature: { params: 0, lookupListIndexes: [] } }, u.push(a), o.push(l), a.feature;
    }
  }
}, getLookupTables: function(e, t, r2, n, i) {
  var a = this.getFeatureTable(e, t, r2, i), o = [];
  if (a) {
    for (var u, s = a.lookupListIndexes, l = this.font.tables[this.tableName].lookups, f = 0; f < s.length; f++)
      u = l[s[f]], u.lookupType === n && o.push(u);
    if (o.length === 0 && i) {
      u = { lookupType: n, lookupFlag: 0, subtables: [], markFilteringSet: void 0 };
      var c = l.length;
      return l.push(u), s.push(c), [u];
    }
  }
  return o;
}, getGlyphClass: function(e, t) {
  switch (e.format) {
    case 1:
      return e.startGlyph <= t && t < e.startGlyph + e.classes.length ? e.classes[t - e.startGlyph] : 0;
    case 2:
      var r2 = hs(e.ranges, t);
      return r2 ? r2.classId : 0;
  }
}, getCoverageIndex: function(e, t) {
  switch (e.format) {
    case 1:
      var r2 = ps(e.glyphs, t);
      return r2 >= 0 ? r2 : -1;
    case 2:
      var n = hs(e.ranges, t);
      return n ? n.index + t - n.start : -1;
  }
}, expandCoverage: function(e) {
  if (e.format === 1)
    return e.glyphs;
  for (var t = [], r2 = e.ranges, n = 0; n < r2.length; n++)
    for (var i = r2[n], a = i.start, o = i.end, u = a; u <= o; u++)
      t.push(u);
  return t;
} };
function zr(e) {
  jr.call(this, e, "gpos");
}
zr.prototype = jr.prototype;
zr.prototype.init = function() {
  var e = this.getDefaultScriptName();
  this.defaultKerningTables = this.getKerningTables(e);
};
zr.prototype.getKerningValue = function(e, t, r2) {
  for (var n = 0; n < e.length; n++)
    for (var i = e[n].subtables, a = 0; a < i.length; a++) {
      var o = i[a], u = this.getCoverageIndex(o.coverage, t);
      if (!(u < 0))
        switch (o.posFormat) {
          case 1:
            for (var s = o.pairSets[u], l = 0; l < s.length; l++) {
              var f = s[l];
              if (f.secondGlyph === r2)
                return f.value1 && f.value1.xAdvance || 0;
            }
            break;
          case 2:
            var c = this.getGlyphClass(o.classDef1, t), p2 = this.getGlyphClass(o.classDef2, r2), d = o.classRecords[c][p2];
            return d.value1 && d.value1.xAdvance || 0;
        }
    }
  return 0;
};
zr.prototype.getKerningTables = function(e, t) {
  if (this.font.tables.gpos)
    return this.getLookupTables(e, t, "kern", 2);
};
function gt(e) {
  jr.call(this, e, "gsub");
}
function rh(e, t) {
  var r2 = e.length;
  if (r2 !== t.length)
    return false;
  for (var n = 0; n < r2; n++)
    if (e[n] !== t[n])
      return false;
  return true;
}
function aa(e, t, r2) {
  for (var n = e.subtables, i = 0; i < n.length; i++) {
    var a = n[i];
    if (a.substFormat === t)
      return a;
  }
  if (r2)
    return n.push(r2), r2;
}
gt.prototype = jr.prototype;
gt.prototype.createDefaultTable = function() {
  return { version: 1, scripts: [{ tag: "DFLT", script: { defaultLangSys: { reserved: 0, reqFeatureIndex: 65535, featureIndexes: [] }, langSysRecords: [] } }], features: [], lookups: [] };
};
gt.prototype.getSingle = function(e, t, r2) {
  for (var n = [], i = this.getLookupTables(t, r2, e, 1), a = 0; a < i.length; a++)
    for (var o = i[a].subtables, u = 0; u < o.length; u++) {
      var s = o[u], l = this.expandCoverage(s.coverage), f = void 0;
      if (s.substFormat === 1) {
        var c = s.deltaGlyphId;
        for (f = 0; f < l.length; f++) {
          var p2 = l[f];
          n.push({ sub: p2, by: p2 + c });
        }
      } else {
        var d = s.substitute;
        for (f = 0; f < l.length; f++)
          n.push({ sub: l[f], by: d[f] });
      }
    }
  return n;
};
gt.prototype.getMultiple = function(e, t, r2) {
  for (var n = [], i = this.getLookupTables(t, r2, e, 2), a = 0; a < i.length; a++)
    for (var o = i[a].subtables, u = 0; u < o.length; u++) {
      var s = o[u], l = this.expandCoverage(s.coverage), f = void 0;
      for (f = 0; f < l.length; f++) {
        var c = l[f], p2 = s.sequences[f];
        n.push({ sub: c, by: p2 });
      }
    }
  return n;
};
gt.prototype.getAlternates = function(e, t, r2) {
  for (var n = [], i = this.getLookupTables(t, r2, e, 3), a = 0; a < i.length; a++)
    for (var o = i[a].subtables, u = 0; u < o.length; u++)
      for (var s = o[u], l = this.expandCoverage(s.coverage), f = s.alternateSets, c = 0; c < l.length; c++)
        n.push({ sub: l[c], by: f[c] });
  return n;
};
gt.prototype.getLigatures = function(e, t, r2) {
  for (var n = [], i = this.getLookupTables(t, r2, e, 4), a = 0; a < i.length; a++)
    for (var o = i[a].subtables, u = 0; u < o.length; u++)
      for (var s = o[u], l = this.expandCoverage(s.coverage), f = s.ligatureSets, c = 0; c < l.length; c++)
        for (var p2 = l[c], d = f[c], D = 0; D < d.length; D++) {
          var v = d[D];
          n.push({ sub: [p2].concat(v.components), by: v.ligGlyph });
        }
  return n;
};
gt.prototype.addSingle = function(e, t, r2, n) {
  var i = this.getLookupTables(r2, n, e, 1, true)[0], a = aa(i, 2, { substFormat: 2, coverage: { format: 1, glyphs: [] }, substitute: [] });
  Te.assert(a.coverage.format === 1, "Single: unable to modify coverage table format " + a.coverage.format);
  var o = t.sub, u = this.binSearch(a.coverage.glyphs, o);
  u < 0 && (u = -1 - u, a.coverage.glyphs.splice(u, 0, o), a.substitute.splice(u, 0, 0)), a.substitute[u] = t.by;
};
gt.prototype.addMultiple = function(e, t, r2, n) {
  Te.assert(t.by instanceof Array && t.by.length > 1, 'Multiple: "by" must be an array of two or more ids');
  var i = this.getLookupTables(r2, n, e, 2, true)[0], a = aa(i, 1, { substFormat: 1, coverage: { format: 1, glyphs: [] }, sequences: [] });
  Te.assert(a.coverage.format === 1, "Multiple: unable to modify coverage table format " + a.coverage.format);
  var o = t.sub, u = this.binSearch(a.coverage.glyphs, o);
  u < 0 && (u = -1 - u, a.coverage.glyphs.splice(u, 0, o), a.sequences.splice(u, 0, 0)), a.sequences[u] = t.by;
};
gt.prototype.addAlternate = function(e, t, r2, n) {
  var i = this.getLookupTables(r2, n, e, 3, true)[0], a = aa(i, 1, { substFormat: 1, coverage: { format: 1, glyphs: [] }, alternateSets: [] });
  Te.assert(a.coverage.format === 1, "Alternate: unable to modify coverage table format " + a.coverage.format);
  var o = t.sub, u = this.binSearch(a.coverage.glyphs, o);
  u < 0 && (u = -1 - u, a.coverage.glyphs.splice(u, 0, o), a.alternateSets.splice(u, 0, 0)), a.alternateSets[u] = t.by;
};
gt.prototype.addLigature = function(e, t, r2, n) {
  var i = this.getLookupTables(r2, n, e, 4, true)[0], a = i.subtables[0];
  a || (a = { substFormat: 1, coverage: { format: 1, glyphs: [] }, ligatureSets: [] }, i.subtables[0] = a), Te.assert(a.coverage.format === 1, "Ligature: unable to modify coverage table format " + a.coverage.format);
  var o = t.sub[0], u = t.sub.slice(1), s = { ligGlyph: t.by, components: u }, l = this.binSearch(a.coverage.glyphs, o);
  if (l >= 0) {
    for (var f = a.ligatureSets[l], c = 0; c < f.length; c++)
      if (rh(f[c].components, u))
        return;
    f.push(s);
  } else
    l = -1 - l, a.coverage.glyphs.splice(l, 0, o), a.ligatureSets.splice(l, 0, [s]);
};
gt.prototype.getFeature = function(e, t, r2) {
  if (/ss\d\d/.test(e))
    return this.getSingle(e, t, r2);
  switch (e) {
    case "aalt":
    case "salt":
      return this.getSingle(e, t, r2).concat(this.getAlternates(e, t, r2));
    case "dlig":
    case "liga":
    case "rlig":
      return this.getLigatures(e, t, r2);
    case "ccmp":
      return this.getMultiple(e, t, r2).concat(this.getLigatures(e, t, r2));
    case "stch":
      return this.getMultiple(e, t, r2);
  }
};
gt.prototype.add = function(e, t, r2, n) {
  if (/ss\d\d/.test(e))
    return this.addSingle(e, t, r2, n);
  switch (e) {
    case "aalt":
    case "salt":
      return typeof t.by == "number" ? this.addSingle(e, t, r2, n) : this.addAlternate(e, t, r2, n);
    case "dlig":
    case "liga":
    case "rlig":
      return this.addLigature(e, t, r2, n);
    case "ccmp":
      return t.by instanceof Array ? this.addMultiple(e, t, r2, n) : this.addLigature(e, t, r2, n);
  }
};
function Nr(e, t) {
  if (!e)
    throw t;
}
function ds(e, t) {
  return e.getUint8(t);
}
function Tn(e, t) {
  return e.getUint16(t, false);
}
function nh(e, t) {
  return e.getInt16(t, false);
}
function oa(e, t) {
  return e.getUint32(t, false);
}
function qs(e, t) {
  var r2 = e.getInt16(t, false), n = e.getUint16(t + 2, false);
  return r2 + n / 65535;
}
function ih(e, t) {
  for (var r2 = "", n = t; n < t + 4; n += 1)
    r2 += String.fromCharCode(e.getInt8(n));
  return r2;
}
function ah(e, t, r2) {
  for (var n = 0, i = 0; i < r2; i += 1)
    n <<= 8, n += e.getUint8(t + i);
  return n;
}
function oh(e, t, r2) {
  for (var n = [], i = t; i < r2; i += 1)
    n.push(e.getUint8(i));
  return n;
}
function sh(e) {
  for (var t = "", r2 = 0; r2 < e.length; r2 += 1)
    t += String.fromCharCode(e[r2]);
  return t;
}
var uh = { byte: 1, uShort: 2, short: 2, uLong: 4, fixed: 4, longDateTime: 8, tag: 4 };
function $(e, t) {
  this.data = e, this.offset = t, this.relativeOffset = 0;
}
$.prototype.parseByte = function() {
  var e = this.data.getUint8(this.offset + this.relativeOffset);
  return this.relativeOffset += 1, e;
};
$.prototype.parseChar = function() {
  var e = this.data.getInt8(this.offset + this.relativeOffset);
  return this.relativeOffset += 1, e;
};
$.prototype.parseCard8 = $.prototype.parseByte;
$.prototype.parseUShort = function() {
  var e = this.data.getUint16(this.offset + this.relativeOffset);
  return this.relativeOffset += 2, e;
};
$.prototype.parseCard16 = $.prototype.parseUShort;
$.prototype.parseSID = $.prototype.parseUShort;
$.prototype.parseOffset16 = $.prototype.parseUShort;
$.prototype.parseShort = function() {
  var e = this.data.getInt16(this.offset + this.relativeOffset);
  return this.relativeOffset += 2, e;
};
$.prototype.parseF2Dot14 = function() {
  var e = this.data.getInt16(this.offset + this.relativeOffset) / 16384;
  return this.relativeOffset += 2, e;
};
$.prototype.parseULong = function() {
  var e = oa(this.data, this.offset + this.relativeOffset);
  return this.relativeOffset += 4, e;
};
$.prototype.parseOffset32 = $.prototype.parseULong;
$.prototype.parseFixed = function() {
  var e = qs(this.data, this.offset + this.relativeOffset);
  return this.relativeOffset += 4, e;
};
$.prototype.parseString = function(e) {
  var t = this.data, r2 = this.offset + this.relativeOffset, n = "";
  this.relativeOffset += e;
  for (var i = 0; i < e; i++)
    n += String.fromCharCode(t.getUint8(r2 + i));
  return n;
};
$.prototype.parseTag = function() {
  return this.parseString(4);
};
$.prototype.parseLongDateTime = function() {
  var e = oa(this.data, this.offset + this.relativeOffset + 4);
  return e -= 2082844800, this.relativeOffset += 8, e;
};
$.prototype.parseVersion = function(e) {
  var t = Tn(this.data, this.offset + this.relativeOffset), r2 = Tn(this.data, this.offset + this.relativeOffset + 2);
  return this.relativeOffset += 4, e === void 0 && (e = 4096), t + r2 / e / 10;
};
$.prototype.skip = function(e, t) {
  t === void 0 && (t = 1), this.relativeOffset += uh[e] * t;
};
$.prototype.parseULongList = function(e) {
  e === void 0 && (e = this.parseULong());
  for (var t = new Array(e), r2 = this.data, n = this.offset + this.relativeOffset, i = 0; i < e; i++)
    t[i] = r2.getUint32(n), n += 4;
  return this.relativeOffset += e * 4, t;
};
$.prototype.parseOffset16List = $.prototype.parseUShortList = function(e) {
  e === void 0 && (e = this.parseUShort());
  for (var t = new Array(e), r2 = this.data, n = this.offset + this.relativeOffset, i = 0; i < e; i++)
    t[i] = r2.getUint16(n), n += 2;
  return this.relativeOffset += e * 2, t;
};
$.prototype.parseShortList = function(e) {
  for (var t = new Array(e), r2 = this.data, n = this.offset + this.relativeOffset, i = 0; i < e; i++)
    t[i] = r2.getInt16(n), n += 2;
  return this.relativeOffset += e * 2, t;
};
$.prototype.parseByteList = function(e) {
  for (var t = new Array(e), r2 = this.data, n = this.offset + this.relativeOffset, i = 0; i < e; i++)
    t[i] = r2.getUint8(n++);
  return this.relativeOffset += e, t;
};
$.prototype.parseList = function(e, t) {
  t || (t = e, e = this.parseUShort());
  for (var r2 = new Array(e), n = 0; n < e; n++)
    r2[n] = t.call(this);
  return r2;
};
$.prototype.parseList32 = function(e, t) {
  t || (t = e, e = this.parseULong());
  for (var r2 = new Array(e), n = 0; n < e; n++)
    r2[n] = t.call(this);
  return r2;
};
$.prototype.parseRecordList = function(e, t) {
  t || (t = e, e = this.parseUShort());
  for (var r2 = new Array(e), n = Object.keys(t), i = 0; i < e; i++) {
    for (var a = {}, o = 0; o < n.length; o++) {
      var u = n[o], s = t[u];
      a[u] = s.call(this);
    }
    r2[i] = a;
  }
  return r2;
};
$.prototype.parseRecordList32 = function(e, t) {
  t || (t = e, e = this.parseULong());
  for (var r2 = new Array(e), n = Object.keys(t), i = 0; i < e; i++) {
    for (var a = {}, o = 0; o < n.length; o++) {
      var u = n[o], s = t[u];
      a[u] = s.call(this);
    }
    r2[i] = a;
  }
  return r2;
};
$.prototype.parseStruct = function(e) {
  if (typeof e == "function")
    return e.call(this);
  for (var t = Object.keys(e), r2 = {}, n = 0; n < t.length; n++) {
    var i = t[n], a = e[i];
    r2[i] = a.call(this);
  }
  return r2;
};
$.prototype.parseValueRecord = function(e) {
  if (e === void 0 && (e = this.parseUShort()), e !== 0) {
    var t = {};
    return e & 1 && (t.xPlacement = this.parseShort()), e & 2 && (t.yPlacement = this.parseShort()), e & 4 && (t.xAdvance = this.parseShort()), e & 8 && (t.yAdvance = this.parseShort()), e & 16 && (t.xPlaDevice = void 0, this.parseShort()), e & 32 && (t.yPlaDevice = void 0, this.parseShort()), e & 64 && (t.xAdvDevice = void 0, this.parseShort()), e & 128 && (t.yAdvDevice = void 0, this.parseShort()), t;
  }
};
$.prototype.parseValueRecordList = function() {
  for (var e = this.parseUShort(), t = this.parseUShort(), r2 = new Array(t), n = 0; n < t; n++)
    r2[n] = this.parseValueRecord(e);
  return r2;
};
$.prototype.parsePointer = function(e) {
  var t = this.parseOffset16();
  if (t > 0)
    return new $(this.data, this.offset + t).parseStruct(e);
};
$.prototype.parsePointer32 = function(e) {
  var t = this.parseOffset32();
  if (t > 0)
    return new $(this.data, this.offset + t).parseStruct(e);
};
$.prototype.parseListOfLists = function(e) {
  for (var t = this.parseOffset16List(), r2 = t.length, n = this.relativeOffset, i = new Array(r2), a = 0; a < r2; a++) {
    var o = t[a];
    if (o === 0) {
      i[a] = void 0;
      continue;
    }
    if (this.relativeOffset = o, e) {
      for (var u = this.parseOffset16List(), s = new Array(u.length), l = 0; l < u.length; l++)
        this.relativeOffset = o + u[l], s[l] = e.call(this);
      i[a] = s;
    } else
      i[a] = this.parseUShortList();
  }
  return this.relativeOffset = n, i;
};
$.prototype.parseCoverage = function() {
  var e = this.offset + this.relativeOffset, t = this.parseUShort(), r2 = this.parseUShort();
  if (t === 1)
    return { format: 1, glyphs: this.parseUShortList(r2) };
  if (t === 2) {
    for (var n = new Array(r2), i = 0; i < r2; i++)
      n[i] = { start: this.parseUShort(), end: this.parseUShort(), index: this.parseUShort() };
    return { format: 2, ranges: n };
  }
  throw new Error("0x" + e.toString(16) + ": Coverage format must be 1 or 2.");
};
$.prototype.parseClassDef = function() {
  var e = this.offset + this.relativeOffset, t = this.parseUShort();
  if (t === 1)
    return { format: 1, startGlyph: this.parseUShort(), classes: this.parseUShortList() };
  if (t === 2)
    return { format: 2, ranges: this.parseRecordList({ start: $.uShort, end: $.uShort, classId: $.uShort }) };
  throw new Error("0x" + e.toString(16) + ": ClassDef format must be 1 or 2.");
};
$.list = function(e, t) {
  return function() {
    return this.parseList(e, t);
  };
};
$.list32 = function(e, t) {
  return function() {
    return this.parseList32(e, t);
  };
};
$.recordList = function(e, t) {
  return function() {
    return this.parseRecordList(e, t);
  };
};
$.recordList32 = function(e, t) {
  return function() {
    return this.parseRecordList32(e, t);
  };
};
$.pointer = function(e) {
  return function() {
    return this.parsePointer(e);
  };
};
$.pointer32 = function(e) {
  return function() {
    return this.parsePointer32(e);
  };
};
$.tag = $.prototype.parseTag;
$.byte = $.prototype.parseByte;
$.uShort = $.offset16 = $.prototype.parseUShort;
$.uShortList = $.prototype.parseUShortList;
$.uLong = $.offset32 = $.prototype.parseULong;
$.uLongList = $.prototype.parseULongList;
$.struct = $.prototype.parseStruct;
$.coverage = $.prototype.parseCoverage;
$.classDef = $.prototype.parseClassDef;
var vs = { reserved: $.uShort, reqFeatureIndex: $.uShort, featureIndexes: $.uShortList };
$.prototype.parseScriptList = function() {
  return this.parsePointer($.recordList({ tag: $.tag, script: $.pointer({ defaultLangSys: $.pointer(vs), langSysRecords: $.recordList({ tag: $.tag, langSys: $.pointer(vs) }) }) })) || [];
};
$.prototype.parseFeatureList = function() {
  return this.parsePointer($.recordList({ tag: $.tag, feature: $.pointer({ featureParams: $.offset16, lookupListIndexes: $.uShortList }) })) || [];
};
$.prototype.parseLookupList = function(e) {
  return this.parsePointer($.list($.pointer(function() {
    var t = this.parseUShort();
    Te.argument(1 <= t && t <= 9, "GPOS/GSUB lookup type " + t + " unknown.");
    var r2 = this.parseUShort(), n = r2 & 16;
    return { lookupType: t, lookupFlag: r2, subtables: this.parseList($.pointer(e[t])), markFilteringSet: n ? this.parseUShort() : void 0 };
  }))) || [];
};
$.prototype.parseFeatureVariationsList = function() {
  return this.parsePointer32(function() {
    var e = this.parseUShort(), t = this.parseUShort();
    Te.argument(e === 1 && t < 1, "GPOS/GSUB feature variations table unknown.");
    var r2 = this.parseRecordList32({ conditionSetOffset: $.offset32, featureTableSubstitutionOffset: $.offset32 });
    return r2;
  }) || [];
};
var se = { getByte: ds, getCard8: ds, getUShort: Tn, getCard16: Tn, getShort: nh, getULong: oa, getFixed: qs, getTag: ih, getOffset: ah, getBytes: oh, bytesToString: sh, Parser: $ };
function gs(e, t, r2, n, i) {
  var a;
  return (t & n) > 0 ? (a = e.parseByte(), t & i || (a = -a), a = r2 + a) : (t & i) > 0 ? a = r2 : a = r2 + e.parseShort(), a;
}
function Ys(e, t, r2) {
  var n = new se.Parser(t, r2);
  e.numberOfContours = n.parseShort(), e._xMin = n.parseShort(), e._yMin = n.parseShort(), e._xMax = n.parseShort(), e._yMax = n.parseShort();
  var i, a;
  if (e.numberOfContours > 0) {
    for (var o = e.endPointIndices = [], u = 0; u < e.numberOfContours; u += 1)
      o.push(n.parseUShort());
    e.instructionLength = n.parseUShort(), e.instructions = [];
    for (var s = 0; s < e.instructionLength; s += 1)
      e.instructions.push(n.parseByte());
    var l = o[o.length - 1] + 1;
    i = [];
    for (var f = 0; f < l; f += 1)
      if (a = n.parseByte(), i.push(a), (a & 8) > 0)
        for (var c = n.parseByte(), p2 = 0; p2 < c; p2 += 1)
          i.push(a), f += 1;
    if (Te.argument(i.length === l, "Bad flags."), o.length > 0) {
      var d = [], D;
      if (l > 0) {
        for (var v = 0; v < l; v += 1)
          a = i[v], D = {}, D.onCurve = !!(a & 1), D.lastPointOfContour = o.indexOf(v) >= 0, d.push(D);
        for (var g = 0, y = 0; y < l; y += 1)
          a = i[y], D = d[y], D.x = gs(n, a, g, 2, 16), g = D.x;
        for (var b = 0, C = 0; C < l; C += 1)
          a = i[C], D = d[C], D.y = gs(n, a, b, 4, 32), b = D.y;
      }
      e.points = d;
    } else
      e.points = [];
  } else if (e.numberOfContours === 0)
    e.points = [];
  else {
    e.isComposite = true, e.points = [], e.components = [];
    for (var k = true; k; ) {
      i = n.parseUShort();
      var S = { glyphIndex: n.parseUShort(), xScale: 1, scale01: 0, scale10: 0, yScale: 1, dx: 0, dy: 0 };
      (i & 1) > 0 ? (i & 2) > 0 ? (S.dx = n.parseShort(), S.dy = n.parseShort()) : S.matchedPoints = [n.parseUShort(), n.parseUShort()] : (i & 2) > 0 ? (S.dx = n.parseChar(), S.dy = n.parseChar()) : S.matchedPoints = [n.parseByte(), n.parseByte()], (i & 8) > 0 ? S.xScale = S.yScale = n.parseF2Dot14() : (i & 64) > 0 ? (S.xScale = n.parseF2Dot14(), S.yScale = n.parseF2Dot14()) : (i & 128) > 0 && (S.xScale = n.parseF2Dot14(), S.scale01 = n.parseF2Dot14(), S.scale10 = n.parseF2Dot14(), S.yScale = n.parseF2Dot14()), e.components.push(S), k = !!(i & 32);
    }
    if (i & 256) {
      e.instructionLength = n.parseUShort(), e.instructions = [];
      for (var E = 0; E < e.instructionLength; E += 1)
        e.instructions.push(n.parseByte());
    }
  }
}
function Yi(e, t) {
  for (var r2 = [], n = 0; n < e.length; n += 1) {
    var i = e[n], a = { x: t.xScale * i.x + t.scale01 * i.y + t.dx, y: t.scale10 * i.x + t.yScale * i.y + t.dy, onCurve: i.onCurve, lastPointOfContour: i.lastPointOfContour };
    r2.push(a);
  }
  return r2;
}
function lh(e) {
  for (var t = [], r2 = [], n = 0; n < e.length; n += 1) {
    var i = e[n];
    r2.push(i), i.lastPointOfContour && (t.push(r2), r2 = []);
  }
  return Te.argument(r2.length === 0, "There are still points left in the current contour."), t;
}
function Zs(e) {
  var t = new ot();
  if (!e)
    return t;
  for (var r2 = lh(e), n = 0; n < r2.length; ++n) {
    var i = r2[n], a = null, o = i[i.length - 1], u = i[0];
    if (o.onCurve)
      t.moveTo(o.x, o.y);
    else if (u.onCurve)
      t.moveTo(u.x, u.y);
    else {
      var s = { x: (o.x + u.x) * 0.5, y: (o.y + u.y) * 0.5 };
      t.moveTo(s.x, s.y);
    }
    for (var l = 0; l < i.length; ++l)
      if (a = o, o = u, u = i[(l + 1) % i.length], o.onCurve)
        t.lineTo(o.x, o.y);
      else {
        var f = a, c = u;
        a.onCurve || (f = { x: (o.x + a.x) * 0.5, y: (o.y + a.y) * 0.5 }), u.onCurve || (c = { x: (o.x + u.x) * 0.5, y: (o.y + u.y) * 0.5 }), t.quadraticCurveTo(o.x, o.y, c.x, c.y);
      }
    t.closePath();
  }
  return t;
}
function Js(e, t) {
  if (t.isComposite)
    for (var r2 = 0; r2 < t.components.length; r2 += 1) {
      var n = t.components[r2], i = e.get(n.glyphIndex);
      if (i.getPath(), i.points) {
        var a = void 0;
        if (n.matchedPoints === void 0)
          a = Yi(i.points, n);
        else {
          if (n.matchedPoints[0] > t.points.length - 1 || n.matchedPoints[1] > i.points.length - 1)
            throw Error("Matched points out of range in " + t.name);
          var o = t.points[n.matchedPoints[0]], u = i.points[n.matchedPoints[1]], s = { xScale: n.xScale, scale01: n.scale01, scale10: n.scale10, yScale: n.yScale, dx: 0, dy: 0 };
          u = Yi([u], s)[0], s.dx = o.x - u.x, s.dy = o.y - u.y, a = Yi(i.points, s);
        }
        t.points = t.points.concat(a);
      }
    }
  return Zs(t.points);
}
function fh(e, t, r2, n) {
  for (var i = new $t.GlyphSet(n), a = 0; a < r2.length - 1; a += 1) {
    var o = r2[a], u = r2[a + 1];
    o !== u ? i.push(a, $t.ttfGlyphLoader(n, a, Ys, e, t + o, Js)) : i.push(a, $t.glyphLoader(n, a));
  }
  return i;
}
function ch(e, t, r2, n) {
  var i = new $t.GlyphSet(n);
  return n._push = function(a) {
    var o = r2[a], u = r2[a + 1];
    o !== u ? i.push(a, $t.ttfGlyphLoader(n, a, Ys, e, t + o, Js)) : i.push(a, $t.glyphLoader(n, a));
  }, i;
}
function ph(e, t, r2, n, i) {
  return i.lowMemory ? ch(e, t, r2, n) : fh(e, t, r2, n);
}
var Ks = { getPath: Zs, parse: ph };
var Qs;
var Dr;
var eu;
var ra;
function tu(e) {
  this.font = e, this.getCommands = function(t) {
    return Ks.getPath(t).commands;
  }, this._fpgmState = this._prepState = void 0, this._errorState = 0;
}
function hh(e) {
  return e;
}
function ru(e) {
  return Math.sign(e) * Math.round(Math.abs(e));
}
function dh(e) {
  return Math.sign(e) * Math.round(Math.abs(e * 2)) / 2;
}
function vh(e) {
  return Math.sign(e) * (Math.round(Math.abs(e) + 0.5) - 0.5);
}
function gh(e) {
  return Math.sign(e) * Math.ceil(Math.abs(e));
}
function mh(e) {
  return Math.sign(e) * Math.floor(Math.abs(e));
}
var nu = function(e) {
  var t = this.srPeriod, r2 = this.srPhase, n = this.srThreshold, i = 1;
  return e < 0 && (e = -e, i = -1), e += n - r2, e = Math.trunc(e / t) * t, e += r2, e < 0 ? r2 * i : e * i;
};
var Wt = { x: 1, y: 0, axis: "x", distance: function(e, t, r2, n) {
  return (r2 ? e.xo : e.x) - (n ? t.xo : t.x);
}, interpolate: function(e, t, r2, n) {
  var i, a, o, u, s, l, f;
  if (!n || n === this) {
    if (i = e.xo - t.xo, a = e.xo - r2.xo, s = t.x - t.xo, l = r2.x - r2.xo, o = Math.abs(i), u = Math.abs(a), f = o + u, f === 0) {
      e.x = e.xo + (s + l) / 2;
      return;
    }
    e.x = e.xo + (s * u + l * o) / f;
    return;
  }
  if (i = n.distance(e, t, true, true), a = n.distance(e, r2, true, true), s = n.distance(t, t, false, true), l = n.distance(r2, r2, false, true), o = Math.abs(i), u = Math.abs(a), f = o + u, f === 0) {
    Wt.setRelative(e, e, (s + l) / 2, n, true);
    return;
  }
  Wt.setRelative(e, e, (s * u + l * o) / f, n, true);
}, normalSlope: Number.NEGATIVE_INFINITY, setRelative: function(e, t, r2, n, i) {
  if (!n || n === this) {
    e.x = (i ? t.xo : t.x) + r2;
    return;
  }
  var a = i ? t.xo : t.x, o = i ? t.yo : t.y, u = a + r2 * n.x, s = o + r2 * n.y;
  e.x = u + (e.y - s) / n.normalSlope;
}, slope: 0, touch: function(e) {
  e.xTouched = true;
}, touched: function(e) {
  return e.xTouched;
}, untouch: function(e) {
  e.xTouched = false;
} };
var Yt = { x: 0, y: 1, axis: "y", distance: function(e, t, r2, n) {
  return (r2 ? e.yo : e.y) - (n ? t.yo : t.y);
}, interpolate: function(e, t, r2, n) {
  var i, a, o, u, s, l, f;
  if (!n || n === this) {
    if (i = e.yo - t.yo, a = e.yo - r2.yo, s = t.y - t.yo, l = r2.y - r2.yo, o = Math.abs(i), u = Math.abs(a), f = o + u, f === 0) {
      e.y = e.yo + (s + l) / 2;
      return;
    }
    e.y = e.yo + (s * u + l * o) / f;
    return;
  }
  if (i = n.distance(e, t, true, true), a = n.distance(e, r2, true, true), s = n.distance(t, t, false, true), l = n.distance(r2, r2, false, true), o = Math.abs(i), u = Math.abs(a), f = o + u, f === 0) {
    Yt.setRelative(e, e, (s + l) / 2, n, true);
    return;
  }
  Yt.setRelative(e, e, (s * u + l * o) / f, n, true);
}, normalSlope: 0, setRelative: function(e, t, r2, n, i) {
  if (!n || n === this) {
    e.y = (i ? t.yo : t.y) + r2;
    return;
  }
  var a = i ? t.xo : t.x, o = i ? t.yo : t.y, u = a + r2 * n.x, s = o + r2 * n.y;
  e.y = s + n.normalSlope * (e.x - u);
}, slope: Number.POSITIVE_INFINITY, touch: function(e) {
  e.yTouched = true;
}, touched: function(e) {
  return e.yTouched;
}, untouch: function(e) {
  e.yTouched = false;
} };
Object.freeze(Wt);
Object.freeze(Yt);
function Vr(e, t) {
  this.x = e, this.y = t, this.axis = void 0, this.slope = t / e, this.normalSlope = -e / t, Object.freeze(this);
}
Vr.prototype.distance = function(e, t, r2, n) {
  return this.x * Wt.distance(e, t, r2, n) + this.y * Yt.distance(e, t, r2, n);
};
Vr.prototype.interpolate = function(e, t, r2, n) {
  var i, a, o, u, s, l, f;
  if (o = n.distance(e, t, true, true), u = n.distance(e, r2, true, true), i = n.distance(t, t, false, true), a = n.distance(r2, r2, false, true), s = Math.abs(o), l = Math.abs(u), f = s + l, f === 0) {
    this.setRelative(e, e, (i + a) / 2, n, true);
    return;
  }
  this.setRelative(e, e, (i * l + a * s) / f, n, true);
};
Vr.prototype.setRelative = function(e, t, r2, n, i) {
  n = n || this;
  var a = i ? t.xo : t.x, o = i ? t.yo : t.y, u = a + r2 * n.x, s = o + r2 * n.y, l = n.normalSlope, f = this.slope, c = e.x, p2 = e.y;
  e.x = (f * c - l * u + s - p2) / (f - l), e.y = f * (e.x - c) + p2;
};
Vr.prototype.touch = function(e) {
  e.xTouched = true, e.yTouched = true;
};
function Hr(e, t) {
  var r2 = Math.sqrt(e * e + t * t);
  return e /= r2, t /= r2, e === 1 && t === 0 ? Wt : e === 0 && t === 1 ? Yt : new Vr(e, t);
}
function Zt(e, t, r2, n) {
  this.x = this.xo = Math.round(e * 64) / 64, this.y = this.yo = Math.round(t * 64) / 64, this.lastPointOfContour = r2, this.onCurve = n, this.prevPointOnContour = void 0, this.nextPointOnContour = void 0, this.xTouched = false, this.yTouched = false, Object.preventExtensions(this);
}
Zt.prototype.nextTouched = function(e) {
  for (var t = this.nextPointOnContour; !e.touched(t) && t !== this; )
    t = t.nextPointOnContour;
  return t;
};
Zt.prototype.prevTouched = function(e) {
  for (var t = this.prevPointOnContour; !e.touched(t) && t !== this; )
    t = t.prevPointOnContour;
  return t;
};
var Wr = Object.freeze(new Zt(0, 0));
var Dh = { cvCutIn: 17 / 16, deltaBase: 9, deltaShift: 0.125, loop: 1, minDis: 1, autoFlip: true };
function ur(e, t) {
  switch (this.env = e, this.stack = [], this.prog = t, e) {
    case "glyf":
      this.zp0 = this.zp1 = this.zp2 = 1, this.rp0 = this.rp1 = this.rp2 = 0;
    case "prep":
      this.fv = this.pv = this.dpv = Wt, this.round = ru;
  }
}
tu.prototype.exec = function(e, t) {
  if (typeof t != "number")
    throw new Error("Point size is not a number!");
  if (!(this._errorState > 2)) {
    var r2 = this.font, n = this._prepState;
    if (!n || n.ppem !== t) {
      var i = this._fpgmState;
      if (!i) {
        ur.prototype = Dh, i = this._fpgmState = new ur("fpgm", r2.tables.fpgm), i.funcs = [], i.font = r2, exports.DEBUG && (console.log("---EXEC FPGM---"), i.step = -1);
        try {
          Dr(i);
        } catch (l) {
          console.log("Hinting error in FPGM:" + l), this._errorState = 3;
          return;
        }
      }
      ur.prototype = i, n = this._prepState = new ur("prep", r2.tables.prep), n.ppem = t;
      var a = r2.tables.cvt;
      if (a)
        for (var o = n.cvt = new Array(a.length), u = t / r2.unitsPerEm, s = 0; s < a.length; s++)
          o[s] = a[s] * u;
      else
        n.cvt = [];
      exports.DEBUG && (console.log("---EXEC PREP---"), n.step = -1);
      try {
        Dr(n);
      } catch (l) {
        this._errorState < 2 && console.log("Hinting error in PREP:" + l), this._errorState = 2;
      }
    }
    if (!(this._errorState > 1))
      try {
        return eu(e, n);
      } catch (l) {
        this._errorState < 1 && (console.log("Hinting error:" + l), console.log("Note: further hinting errors are silenced")), this._errorState = 1;
        return;
      }
  }
};
eu = function(e, t) {
  var r2 = t.ppem / t.font.unitsPerEm, n = r2, i = e.components, a, o, u;
  if (ur.prototype = t, !i)
    u = new ur("glyf", e.instructions), exports.DEBUG && (console.log("---EXEC GLYPH---"), u.step = -1), ra(e, u, r2, n), o = u.gZone;
  else {
    var s = t.font;
    o = [], a = [];
    for (var l = 0; l < i.length; l++) {
      var f = i[l], c = s.glyphs.get(f.glyphIndex);
      u = new ur("glyf", c.instructions), exports.DEBUG && (console.log("---EXEC COMP " + l + "---"), u.step = -1), ra(c, u, r2, n);
      for (var p2 = Math.round(f.dx * r2), d = Math.round(f.dy * n), D = u.gZone, v = u.contours, g = 0; g < D.length; g++) {
        var y = D[g];
        y.xTouched = y.yTouched = false, y.xo = y.x = y.x + p2, y.yo = y.y = y.y + d;
      }
      var b = o.length;
      o.push.apply(o, D);
      for (var C = 0; C < v.length; C++)
        a.push(v[C] + b);
    }
    e.instructions && !u.inhibitGridFit && (u = new ur("glyf", e.instructions), u.gZone = u.z0 = u.z1 = u.z2 = o, u.contours = a, o.push(new Zt(0, 0), new Zt(Math.round(e.advanceWidth * r2), 0)), exports.DEBUG && (console.log("---EXEC COMPOSITE---"), u.step = -1), Dr(u), o.length -= 2);
  }
  return o;
};
ra = function(e, t, r2, n) {
  for (var i = e.points || [], a = i.length, o = t.gZone = t.z0 = t.z1 = t.z2 = [], u = t.contours = [], s, l = 0; l < a; l++)
    s = i[l], o[l] = new Zt(s.x * r2, s.y * n, s.lastPointOfContour, s.onCurve);
  for (var f, c, p2 = 0; p2 < a; p2++)
    s = o[p2], f || (f = s, u.push(p2)), s.lastPointOfContour ? (s.nextPointOnContour = f, f.prevPointOnContour = s, f = void 0) : (c = o[p2 + 1], s.nextPointOnContour = c, c.prevPointOnContour = s);
  if (!t.inhibitGridFit) {
    if (exports.DEBUG) {
      console.log("PROCESSING GLYPH", t.stack);
      for (var d = 0; d < a; d++)
        console.log(d, o[d].x, o[d].y);
    }
    if (o.push(new Zt(0, 0), new Zt(Math.round(e.advanceWidth * r2), 0)), Dr(t), o.length -= 2, exports.DEBUG) {
      console.log("FINISHED GLYPH", t.stack);
      for (var D = 0; D < a; D++)
        console.log(D, o[D].x, o[D].y);
    }
  }
};
Dr = function(e) {
  var t = e.prog;
  if (t) {
    var r2 = t.length, n;
    for (e.ip = 0; e.ip < r2; e.ip++) {
      if (exports.DEBUG && e.step++, n = Qs[t[e.ip]], !n)
        throw new Error("unknown instruction: 0x" + Number(t[e.ip]).toString(16));
      n(e);
    }
  }
};
function _n(e) {
  for (var t = e.tZone = new Array(e.gZone.length), r2 = 0; r2 < t.length; r2++)
    t[r2] = new Zt(0, 0);
}
function iu(e, t) {
  var r2 = e.prog, n = e.ip, i = 1, a;
  do
    if (a = r2[++n], a === 88)
      i++;
    else if (a === 89)
      i--;
    else if (a === 64)
      n += r2[n + 1] + 1;
    else if (a === 65)
      n += 2 * r2[n + 1] + 1;
    else if (a >= 176 && a <= 183)
      n += a - 176 + 1;
    else if (a >= 184 && a <= 191)
      n += (a - 184 + 1) * 2;
    else if (t && i === 1 && a === 27)
      break;
  while (i > 0);
  e.ip = n;
}
function ms(e, t) {
  exports.DEBUG && console.log(t.step, "SVTCA[" + e.axis + "]"), t.fv = t.pv = t.dpv = e;
}
function Ds(e, t) {
  exports.DEBUG && console.log(t.step, "SPVTCA[" + e.axis + "]"), t.pv = t.dpv = e;
}
function ys(e, t) {
  exports.DEBUG && console.log(t.step, "SFVTCA[" + e.axis + "]"), t.fv = e;
}
function bs(e, t) {
  var r2 = t.stack, n = r2.pop(), i = r2.pop(), a = t.z2[n], o = t.z1[i];
  exports.DEBUG && console.log("SPVTL[" + e + "]", n, i);
  var u, s;
  e ? (u = a.y - o.y, s = o.x - a.x) : (u = o.x - a.x, s = o.y - a.y), t.pv = t.dpv = Hr(u, s);
}
function xs(e, t) {
  var r2 = t.stack, n = r2.pop(), i = r2.pop(), a = t.z2[n], o = t.z1[i];
  exports.DEBUG && console.log("SFVTL[" + e + "]", n, i);
  var u, s;
  e ? (u = a.y - o.y, s = o.x - a.x) : (u = o.x - a.x, s = o.y - a.y), t.fv = Hr(u, s);
}
function yh(e) {
  var t = e.stack, r2 = t.pop(), n = t.pop();
  exports.DEBUG && console.log(e.step, "SPVFS[]", r2, n), e.pv = e.dpv = Hr(n, r2);
}
function bh(e) {
  var t = e.stack, r2 = t.pop(), n = t.pop();
  exports.DEBUG && console.log(e.step, "SPVFS[]", r2, n), e.fv = Hr(n, r2);
}
function xh(e) {
  var t = e.stack, r2 = e.pv;
  exports.DEBUG && console.log(e.step, "GPV[]"), t.push(r2.x * 16384), t.push(r2.y * 16384);
}
function wh(e) {
  var t = e.stack, r2 = e.fv;
  exports.DEBUG && console.log(e.step, "GFV[]"), t.push(r2.x * 16384), t.push(r2.y * 16384);
}
function Eh(e) {
  e.fv = e.pv, exports.DEBUG && console.log(e.step, "SFVTPV[]");
}
function Fh(e) {
  var t = e.stack, r2 = t.pop(), n = t.pop(), i = t.pop(), a = t.pop(), o = t.pop(), u = e.z0, s = e.z1, l = u[r2], f = u[n], c = s[i], p2 = s[a], d = e.z2[o];
  exports.DEBUG && console.log("ISECT[], ", r2, n, i, a, o);
  var D = l.x, v = l.y, g = f.x, y = f.y, b = c.x, C = c.y, k = p2.x, S = p2.y, E = (D - g) * (C - S) - (v - y) * (b - k), L = D * y - v * g, T = b * S - C * k;
  d.x = (L * (b - k) - T * (D - g)) / E, d.y = (L * (C - S) - T * (v - y)) / E;
}
function Ch(e) {
  e.rp0 = e.stack.pop(), exports.DEBUG && console.log(e.step, "SRP0[]", e.rp0);
}
function Sh(e) {
  e.rp1 = e.stack.pop(), exports.DEBUG && console.log(e.step, "SRP1[]", e.rp1);
}
function kh(e) {
  e.rp2 = e.stack.pop(), exports.DEBUG && console.log(e.step, "SRP2[]", e.rp2);
}
function Th(e) {
  var t = e.stack.pop();
  switch (exports.DEBUG && console.log(e.step, "SZP0[]", t), e.zp0 = t, t) {
    case 0:
      e.tZone || _n(e), e.z0 = e.tZone;
      break;
    case 1:
      e.z0 = e.gZone;
      break;
    default:
      throw new Error("Invalid zone pointer");
  }
}
function _h(e) {
  var t = e.stack.pop();
  switch (exports.DEBUG && console.log(e.step, "SZP1[]", t), e.zp1 = t, t) {
    case 0:
      e.tZone || _n(e), e.z1 = e.tZone;
      break;
    case 1:
      e.z1 = e.gZone;
      break;
    default:
      throw new Error("Invalid zone pointer");
  }
}
function Ah(e) {
  var t = e.stack.pop();
  switch (exports.DEBUG && console.log(e.step, "SZP2[]", t), e.zp2 = t, t) {
    case 0:
      e.tZone || _n(e), e.z2 = e.tZone;
      break;
    case 1:
      e.z2 = e.gZone;
      break;
    default:
      throw new Error("Invalid zone pointer");
  }
}
function Oh(e) {
  var t = e.stack.pop();
  switch (exports.DEBUG && console.log(e.step, "SZPS[]", t), e.zp0 = e.zp1 = e.zp2 = t, t) {
    case 0:
      e.tZone || _n(e), e.z0 = e.z1 = e.z2 = e.tZone;
      break;
    case 1:
      e.z0 = e.z1 = e.z2 = e.gZone;
      break;
    default:
      throw new Error("Invalid zone pointer");
  }
}
function Lh(e) {
  e.loop = e.stack.pop(), exports.DEBUG && console.log(e.step, "SLOOP[]", e.loop);
}
function Ih(e) {
  exports.DEBUG && console.log(e.step, "RTG[]"), e.round = ru;
}
function Ph(e) {
  exports.DEBUG && console.log(e.step, "RTHG[]"), e.round = vh;
}
function Rh(e) {
  var t = e.stack.pop();
  exports.DEBUG && console.log(e.step, "SMD[]", t), e.minDis = t / 64;
}
function Uh(e) {
  exports.DEBUG && console.log(e.step, "ELSE[]"), iu(e, false);
}
function Bh(e) {
  var t = e.stack.pop();
  exports.DEBUG && console.log(e.step, "JMPR[]", t), e.ip += t - 1;
}
function Nh(e) {
  var t = e.stack.pop();
  exports.DEBUG && console.log(e.step, "SCVTCI[]", t), e.cvCutIn = t / 64;
}
function Mh(e) {
  var t = e.stack;
  exports.DEBUG && console.log(e.step, "DUP[]"), t.push(t[t.length - 1]);
}
function Zi(e) {
  exports.DEBUG && console.log(e.step, "POP[]"), e.stack.pop();
}
function Gh(e) {
  exports.DEBUG && console.log(e.step, "CLEAR[]"), e.stack.length = 0;
}
function Wh(e) {
  var t = e.stack, r2 = t.pop(), n = t.pop();
  exports.DEBUG && console.log(e.step, "SWAP[]"), t.push(r2), t.push(n);
}
function $h(e) {
  var t = e.stack;
  exports.DEBUG && console.log(e.step, "DEPTH[]"), t.push(t.length);
}
function jh(e) {
  var t = e.stack, r2 = t.pop(), n = t.pop();
  exports.DEBUG && console.log(e.step, "LOOPCALL[]", r2, n);
  var i = e.ip, a = e.prog;
  e.prog = e.funcs[r2];
  for (var o = 0; o < n; o++)
    Dr(e), exports.DEBUG && console.log(++e.step, o + 1 < n ? "next loopcall" : "done loopcall", o);
  e.ip = i, e.prog = a;
}
function zh(e) {
  var t = e.stack.pop();
  exports.DEBUG && console.log(e.step, "CALL[]", t);
  var r2 = e.ip, n = e.prog;
  e.prog = e.funcs[t], Dr(e), e.ip = r2, e.prog = n, exports.DEBUG && console.log(++e.step, "returning from", t);
}
function Vh(e) {
  var t = e.stack, r2 = t.pop();
  exports.DEBUG && console.log(e.step, "CINDEX[]", r2), t.push(t[t.length - r2]);
}
function Hh(e) {
  var t = e.stack, r2 = t.pop();
  exports.DEBUG && console.log(e.step, "MINDEX[]", r2), t.push(t.splice(t.length - r2, 1)[0]);
}
function Xh(e) {
  if (e.env !== "fpgm")
    throw new Error("FDEF not allowed here");
  var t = e.stack, r2 = e.prog, n = e.ip, i = t.pop(), a = n;
  for (exports.DEBUG && console.log(e.step, "FDEF[]", i); r2[++n] !== 45; )
    ;
  e.ip = n, e.funcs[i] = r2.slice(a + 1, n);
}
function ws(e, t) {
  var r2 = t.stack.pop(), n = t.z0[r2], i = t.fv, a = t.pv;
  exports.DEBUG && console.log(t.step, "MDAP[" + e + "]", r2);
  var o = a.distance(n, Wr);
  e && (o = t.round(o)), i.setRelative(n, Wr, o, a), i.touch(n), t.rp0 = t.rp1 = r2;
}
function Es(e, t) {
  var r2 = t.z2, n = r2.length - 2, i, a, o;
  exports.DEBUG && console.log(t.step, "IUP[" + e.axis + "]");
  for (var u = 0; u < n; u++)
    i = r2[u], !e.touched(i) && (a = i.prevTouched(e), a !== i && (o = i.nextTouched(e), a === o && e.setRelative(i, i, e.distance(a, a, false, true), e, true), e.interpolate(i, a, o, e)));
}
function Fs(e, t) {
  for (var r2 = t.stack, n = e ? t.rp1 : t.rp2, i = (e ? t.z0 : t.z1)[n], a = t.fv, o = t.pv, u = t.loop, s = t.z2; u--; ) {
    var l = r2.pop(), f = s[l], c = o.distance(i, i, false, true);
    a.setRelative(f, f, c, o), a.touch(f), exports.DEBUG && console.log(t.step, (t.loop > 1 ? "loop " + (t.loop - u) + ": " : "") + "SHP[" + (e ? "rp1" : "rp2") + "]", l);
  }
  t.loop = 1;
}
function Cs(e, t) {
  var r2 = t.stack, n = e ? t.rp1 : t.rp2, i = (e ? t.z0 : t.z1)[n], a = t.fv, o = t.pv, u = r2.pop(), s = t.z2[t.contours[u]], l = s;
  exports.DEBUG && console.log(t.step, "SHC[" + e + "]", u);
  var f = o.distance(i, i, false, true);
  do
    l !== i && a.setRelative(l, l, f, o), l = l.nextPointOnContour;
  while (l !== s);
}
function Ss(e, t) {
  var r2 = t.stack, n = e ? t.rp1 : t.rp2, i = (e ? t.z0 : t.z1)[n], a = t.fv, o = t.pv, u = r2.pop();
  exports.DEBUG && console.log(t.step, "SHZ[" + e + "]", u);
  var s;
  switch (u) {
    case 0:
      s = t.tZone;
      break;
    case 1:
      s = t.gZone;
      break;
    default:
      throw new Error("Invalid zone");
  }
  for (var l, f = o.distance(i, i, false, true), c = s.length - 2, p2 = 0; p2 < c; p2++)
    l = s[p2], a.setRelative(l, l, f, o);
}
function qh(e) {
  for (var t = e.stack, r2 = e.loop, n = e.fv, i = t.pop() / 64, a = e.z2; r2--; ) {
    var o = t.pop(), u = a[o];
    exports.DEBUG && console.log(e.step, (e.loop > 1 ? "loop " + (e.loop - r2) + ": " : "") + "SHPIX[]", o, i), n.setRelative(u, u, i), n.touch(u);
  }
  e.loop = 1;
}
function Yh(e) {
  for (var t = e.stack, r2 = e.rp1, n = e.rp2, i = e.loop, a = e.z0[r2], o = e.z1[n], u = e.fv, s = e.dpv, l = e.z2; i--; ) {
    var f = t.pop(), c = l[f];
    exports.DEBUG && console.log(e.step, (e.loop > 1 ? "loop " + (e.loop - i) + ": " : "") + "IP[]", f, r2, "<->", n), u.interpolate(c, a, o, s), u.touch(c);
  }
  e.loop = 1;
}
function ks(e, t) {
  var r2 = t.stack, n = r2.pop() / 64, i = r2.pop(), a = t.z1[i], o = t.z0[t.rp0], u = t.fv, s = t.pv;
  u.setRelative(a, o, n, s), u.touch(a), exports.DEBUG && console.log(t.step, "MSIRP[" + e + "]", n, i), t.rp1 = t.rp0, t.rp2 = i, e && (t.rp0 = i);
}
function Zh(e) {
  for (var t = e.stack, r2 = e.rp0, n = e.z0[r2], i = e.loop, a = e.fv, o = e.pv, u = e.z1; i--; ) {
    var s = t.pop(), l = u[s];
    exports.DEBUG && console.log(e.step, (e.loop > 1 ? "loop " + (e.loop - i) + ": " : "") + "ALIGNRP[]", s), a.setRelative(l, n, 0, o), a.touch(l);
  }
  e.loop = 1;
}
function Jh(e) {
  exports.DEBUG && console.log(e.step, "RTDG[]"), e.round = dh;
}
function Ts(e, t) {
  var r2 = t.stack, n = r2.pop(), i = r2.pop(), a = t.z0[i], o = t.fv, u = t.pv, s = t.cvt[n];
  exports.DEBUG && console.log(t.step, "MIAP[" + e + "]", n, "(", s, ")", i);
  var l = u.distance(a, Wr);
  e && (Math.abs(l - s) < t.cvCutIn && (l = s), l = t.round(l)), o.setRelative(a, Wr, l, u), t.zp0 === 0 && (a.xo = a.x, a.yo = a.y), o.touch(a), t.rp0 = t.rp1 = i;
}
function Kh(e) {
  var t = e.prog, r2 = e.ip, n = e.stack, i = t[++r2];
  exports.DEBUG && console.log(e.step, "NPUSHB[]", i);
  for (var a = 0; a < i; a++)
    n.push(t[++r2]);
  e.ip = r2;
}
function Qh(e) {
  var t = e.ip, r2 = e.prog, n = e.stack, i = r2[++t];
  exports.DEBUG && console.log(e.step, "NPUSHW[]", i);
  for (var a = 0; a < i; a++) {
    var o = r2[++t] << 8 | r2[++t];
    o & 32768 && (o = -((o ^ 65535) + 1)), n.push(o);
  }
  e.ip = t;
}
function ed(e) {
  var t = e.stack, r2 = e.store;
  r2 || (r2 = e.store = []);
  var n = t.pop(), i = t.pop();
  exports.DEBUG && console.log(e.step, "WS", n, i), r2[i] = n;
}
function td(e) {
  var t = e.stack, r2 = e.store, n = t.pop();
  exports.DEBUG && console.log(e.step, "RS", n);
  var i = r2 && r2[n] || 0;
  t.push(i);
}
function rd(e) {
  var t = e.stack, r2 = t.pop(), n = t.pop();
  exports.DEBUG && console.log(e.step, "WCVTP", r2, n), e.cvt[n] = r2 / 64;
}
function nd(e) {
  var t = e.stack, r2 = t.pop();
  exports.DEBUG && console.log(e.step, "RCVT", r2), t.push(e.cvt[r2] * 64);
}
function _s(e, t) {
  var r2 = t.stack, n = r2.pop(), i = t.z2[n];
  exports.DEBUG && console.log(t.step, "GC[" + e + "]", n), r2.push(t.dpv.distance(i, Wr, e, false) * 64);
}
function As(e, t) {
  var r2 = t.stack, n = r2.pop(), i = r2.pop(), a = t.z1[n], o = t.z0[i], u = t.dpv.distance(o, a, e, e);
  exports.DEBUG && console.log(t.step, "MD[" + e + "]", n, i, "->", u), t.stack.push(Math.round(u * 64));
}
function id(e) {
  exports.DEBUG && console.log(e.step, "MPPEM[]"), e.stack.push(e.ppem);
}
function ad(e) {
  exports.DEBUG && console.log(e.step, "FLIPON[]"), e.autoFlip = true;
}
function od(e) {
  var t = e.stack, r2 = t.pop(), n = t.pop();
  exports.DEBUG && console.log(e.step, "LT[]", r2, n), t.push(n < r2 ? 1 : 0);
}
function sd(e) {
  var t = e.stack, r2 = t.pop(), n = t.pop();
  exports.DEBUG && console.log(e.step, "LTEQ[]", r2, n), t.push(n <= r2 ? 1 : 0);
}
function ud(e) {
  var t = e.stack, r2 = t.pop(), n = t.pop();
  exports.DEBUG && console.log(e.step, "GT[]", r2, n), t.push(n > r2 ? 1 : 0);
}
function ld(e) {
  var t = e.stack, r2 = t.pop(), n = t.pop();
  exports.DEBUG && console.log(e.step, "GTEQ[]", r2, n), t.push(n >= r2 ? 1 : 0);
}
function fd(e) {
  var t = e.stack, r2 = t.pop(), n = t.pop();
  exports.DEBUG && console.log(e.step, "EQ[]", r2, n), t.push(r2 === n ? 1 : 0);
}
function cd(e) {
  var t = e.stack, r2 = t.pop(), n = t.pop();
  exports.DEBUG && console.log(e.step, "NEQ[]", r2, n), t.push(r2 !== n ? 1 : 0);
}
function pd(e) {
  var t = e.stack, r2 = t.pop();
  exports.DEBUG && console.log(e.step, "ODD[]", r2), t.push(Math.trunc(r2) % 2 ? 1 : 0);
}
function hd(e) {
  var t = e.stack, r2 = t.pop();
  exports.DEBUG && console.log(e.step, "EVEN[]", r2), t.push(Math.trunc(r2) % 2 ? 0 : 1);
}
function dd(e) {
  var t = e.stack.pop();
  exports.DEBUG && console.log(e.step, "IF[]", t), t || (iu(e, true), exports.DEBUG && console.log(e.step, "EIF[]"));
}
function vd(e) {
  exports.DEBUG && console.log(e.step, "EIF[]");
}
function gd(e) {
  var t = e.stack, r2 = t.pop(), n = t.pop();
  exports.DEBUG && console.log(e.step, "AND[]", r2, n), t.push(r2 && n ? 1 : 0);
}
function md(e) {
  var t = e.stack, r2 = t.pop(), n = t.pop();
  exports.DEBUG && console.log(e.step, "OR[]", r2, n), t.push(r2 || n ? 1 : 0);
}
function Dd(e) {
  var t = e.stack, r2 = t.pop();
  exports.DEBUG && console.log(e.step, "NOT[]", r2), t.push(r2 ? 0 : 1);
}
function Ji(e, t) {
  var r2 = t.stack, n = r2.pop(), i = t.fv, a = t.pv, o = t.ppem, u = t.deltaBase + (e - 1) * 16, s = t.deltaShift, l = t.z0;
  exports.DEBUG && console.log(t.step, "DELTAP[" + e + "]", n, r2);
  for (var f = 0; f < n; f++) {
    var c = r2.pop(), p2 = r2.pop(), d = u + ((p2 & 240) >> 4);
    if (d === o) {
      var D = (p2 & 15) - 8;
      D >= 0 && D++, exports.DEBUG && console.log(t.step, "DELTAPFIX", c, "by", D * s);
      var v = l[c];
      i.setRelative(v, v, D * s, a);
    }
  }
}
function yd(e) {
  var t = e.stack, r2 = t.pop();
  exports.DEBUG && console.log(e.step, "SDB[]", r2), e.deltaBase = r2;
}
function bd(e) {
  var t = e.stack, r2 = t.pop();
  exports.DEBUG && console.log(e.step, "SDS[]", r2), e.deltaShift = Math.pow(0.5, r2);
}
function xd(e) {
  var t = e.stack, r2 = t.pop(), n = t.pop();
  exports.DEBUG && console.log(e.step, "ADD[]", r2, n), t.push(n + r2);
}
function wd(e) {
  var t = e.stack, r2 = t.pop(), n = t.pop();
  exports.DEBUG && console.log(e.step, "SUB[]", r2, n), t.push(n - r2);
}
function Ed(e) {
  var t = e.stack, r2 = t.pop(), n = t.pop();
  exports.DEBUG && console.log(e.step, "DIV[]", r2, n), t.push(n * 64 / r2);
}
function Fd(e) {
  var t = e.stack, r2 = t.pop(), n = t.pop();
  exports.DEBUG && console.log(e.step, "MUL[]", r2, n), t.push(n * r2 / 64);
}
function Cd(e) {
  var t = e.stack, r2 = t.pop();
  exports.DEBUG && console.log(e.step, "ABS[]", r2), t.push(Math.abs(r2));
}
function Sd(e) {
  var t = e.stack, r2 = t.pop();
  exports.DEBUG && console.log(e.step, "NEG[]", r2), t.push(-r2);
}
function kd(e) {
  var t = e.stack, r2 = t.pop();
  exports.DEBUG && console.log(e.step, "FLOOR[]", r2), t.push(Math.floor(r2 / 64) * 64);
}
function Td(e) {
  var t = e.stack, r2 = t.pop();
  exports.DEBUG && console.log(e.step, "CEILING[]", r2), t.push(Math.ceil(r2 / 64) * 64);
}
function Cn(e, t) {
  var r2 = t.stack, n = r2.pop();
  exports.DEBUG && console.log(t.step, "ROUND[]"), r2.push(t.round(n / 64) * 64);
}
function _d(e) {
  var t = e.stack, r2 = t.pop(), n = t.pop();
  exports.DEBUG && console.log(e.step, "WCVTF[]", r2, n), e.cvt[n] = r2 * e.ppem / e.font.unitsPerEm;
}
function Ki(e, t) {
  var r2 = t.stack, n = r2.pop(), i = t.ppem, a = t.deltaBase + (e - 1) * 16, o = t.deltaShift;
  exports.DEBUG && console.log(t.step, "DELTAC[" + e + "]", n, r2);
  for (var u = 0; u < n; u++) {
    var s = r2.pop(), l = r2.pop(), f = a + ((l & 240) >> 4);
    if (f === i) {
      var c = (l & 15) - 8;
      c >= 0 && c++;
      var p2 = c * o;
      exports.DEBUG && console.log(t.step, "DELTACFIX", s, "by", p2), t.cvt[s] += p2;
    }
  }
}
function Ad(e) {
  var t = e.stack.pop();
  exports.DEBUG && console.log(e.step, "SROUND[]", t), e.round = nu;
  var r2;
  switch (t & 192) {
    case 0:
      r2 = 0.5;
      break;
    case 64:
      r2 = 1;
      break;
    case 128:
      r2 = 2;
      break;
    default:
      throw new Error("invalid SROUND value");
  }
  switch (e.srPeriod = r2, t & 48) {
    case 0:
      e.srPhase = 0;
      break;
    case 16:
      e.srPhase = 0.25 * r2;
      break;
    case 32:
      e.srPhase = 0.5 * r2;
      break;
    case 48:
      e.srPhase = 0.75 * r2;
      break;
    default:
      throw new Error("invalid SROUND value");
  }
  t &= 15, t === 0 ? e.srThreshold = 0 : e.srThreshold = (t / 8 - 0.5) * r2;
}
function Od(e) {
  var t = e.stack.pop();
  exports.DEBUG && console.log(e.step, "S45ROUND[]", t), e.round = nu;
  var r2;
  switch (t & 192) {
    case 0:
      r2 = Math.sqrt(2) / 2;
      break;
    case 64:
      r2 = Math.sqrt(2);
      break;
    case 128:
      r2 = 2 * Math.sqrt(2);
      break;
    default:
      throw new Error("invalid S45ROUND value");
  }
  switch (e.srPeriod = r2, t & 48) {
    case 0:
      e.srPhase = 0;
      break;
    case 16:
      e.srPhase = 0.25 * r2;
      break;
    case 32:
      e.srPhase = 0.5 * r2;
      break;
    case 48:
      e.srPhase = 0.75 * r2;
      break;
    default:
      throw new Error("invalid S45ROUND value");
  }
  t &= 15, t === 0 ? e.srThreshold = 0 : e.srThreshold = (t / 8 - 0.5) * r2;
}
function Ld(e) {
  exports.DEBUG && console.log(e.step, "ROFF[]"), e.round = hh;
}
function Id(e) {
  exports.DEBUG && console.log(e.step, "RUTG[]"), e.round = gh;
}
function Pd(e) {
  exports.DEBUG && console.log(e.step, "RDTG[]"), e.round = mh;
}
function Rd(e) {
  var t = e.stack.pop();
  exports.DEBUG && console.log(e.step, "SCANCTRL[]", t);
}
function Os(e, t) {
  var r2 = t.stack, n = r2.pop(), i = r2.pop(), a = t.z2[n], o = t.z1[i];
  exports.DEBUG && console.log(t.step, "SDPVTL[" + e + "]", n, i);
  var u, s;
  e ? (u = a.y - o.y, s = o.x - a.x) : (u = o.x - a.x, s = o.y - a.y), t.dpv = Hr(u, s);
}
function Ud(e) {
  var t = e.stack, r2 = t.pop(), n = 0;
  exports.DEBUG && console.log(e.step, "GETINFO[]", r2), r2 & 1 && (n = 35), r2 & 32 && (n |= 4096), t.push(n);
}
function Bd(e) {
  var t = e.stack, r2 = t.pop(), n = t.pop(), i = t.pop();
  exports.DEBUG && console.log(e.step, "ROLL[]"), t.push(n), t.push(r2), t.push(i);
}
function Nd(e) {
  var t = e.stack, r2 = t.pop(), n = t.pop();
  exports.DEBUG && console.log(e.step, "MAX[]", r2, n), t.push(Math.max(n, r2));
}
function Md(e) {
  var t = e.stack, r2 = t.pop(), n = t.pop();
  exports.DEBUG && console.log(e.step, "MIN[]", r2, n), t.push(Math.min(n, r2));
}
function Gd(e) {
  var t = e.stack.pop();
  exports.DEBUG && console.log(e.step, "SCANTYPE[]", t);
}
function Wd(e) {
  var t = e.stack.pop(), r2 = e.stack.pop();
  switch (exports.DEBUG && console.log(e.step, "INSTCTRL[]", t, r2), t) {
    case 1:
      e.inhibitGridFit = !!r2;
      return;
    case 2:
      e.ignoreCvt = !!r2;
      return;
    default:
      throw new Error("invalid INSTCTRL[] selector");
  }
}
function ir(e, t) {
  var r2 = t.stack, n = t.prog, i = t.ip;
  exports.DEBUG && console.log(t.step, "PUSHB[" + e + "]");
  for (var a = 0; a < e; a++)
    r2.push(n[++i]);
  t.ip = i;
}
function ar(e, t) {
  var r2 = t.ip, n = t.prog, i = t.stack;
  exports.DEBUG && console.log(t.ip, "PUSHW[" + e + "]");
  for (var a = 0; a < e; a++) {
    var o = n[++r2] << 8 | n[++r2];
    o & 32768 && (o = -((o ^ 65535) + 1)), i.push(o);
  }
  t.ip = r2;
}
function oe(e, t, r2, n, i, a) {
  var o = a.stack, u = e && o.pop(), s = o.pop(), l = a.rp0, f = a.z0[l], c = a.z1[s], p2 = a.minDis, d = a.fv, D = a.dpv, v, g, y, b;
  g = v = D.distance(c, f, true, true), y = g >= 0 ? 1 : -1, g = Math.abs(g), e && (b = a.cvt[u], n && Math.abs(g - b) < a.cvCutIn && (g = b)), r2 && g < p2 && (g = p2), n && (g = a.round(g)), d.setRelative(c, f, y * g, D), d.touch(c), exports.DEBUG && console.log(a.step, (e ? "MIRP[" : "MDRP[") + (t ? "M" : "m") + (r2 ? ">" : "_") + (n ? "R" : "_") + (i === 0 ? "Gr" : i === 1 ? "Bl" : i === 2 ? "Wh" : "") + "]", e ? u + "(" + a.cvt[u] + "," + b + ")" : "", s, "(d =", v, "->", y * g, ")"), a.rp1 = a.rp0, a.rp2 = s, t && (a.rp0 = s);
}
Qs = [ms.bind(void 0, Yt), ms.bind(void 0, Wt), Ds.bind(void 0, Yt), Ds.bind(void 0, Wt), ys.bind(void 0, Yt), ys.bind(void 0, Wt), bs.bind(void 0, 0), bs.bind(void 0, 1), xs.bind(void 0, 0), xs.bind(void 0, 1), yh, bh, xh, wh, Eh, Fh, Ch, Sh, kh, Th, _h, Ah, Oh, Lh, Ih, Ph, Rh, Uh, Bh, Nh, void 0, void 0, Mh, Zi, Gh, Wh, $h, Vh, Hh, void 0, void 0, void 0, jh, zh, Xh, void 0, ws.bind(void 0, 0), ws.bind(void 0, 1), Es.bind(void 0, Yt), Es.bind(void 0, Wt), Fs.bind(void 0, 0), Fs.bind(void 0, 1), Cs.bind(void 0, 0), Cs.bind(void 0, 1), Ss.bind(void 0, 0), Ss.bind(void 0, 1), qh, Yh, ks.bind(void 0, 0), ks.bind(void 0, 1), Zh, Jh, Ts.bind(void 0, 0), Ts.bind(void 0, 1), Kh, Qh, ed, td, rd, nd, _s.bind(void 0, 0), _s.bind(void 0, 1), void 0, As.bind(void 0, 0), As.bind(void 0, 1), id, void 0, ad, void 0, void 0, od, sd, ud, ld, fd, cd, pd, hd, dd, vd, gd, md, Dd, Ji.bind(void 0, 1), yd, bd, xd, wd, Ed, Fd, Cd, Sd, kd, Td, Cn.bind(void 0, 0), Cn.bind(void 0, 1), Cn.bind(void 0, 2), Cn.bind(void 0, 3), void 0, void 0, void 0, void 0, _d, Ji.bind(void 0, 2), Ji.bind(void 0, 3), Ki.bind(void 0, 1), Ki.bind(void 0, 2), Ki.bind(void 0, 3), Ad, Od, void 0, void 0, Ld, void 0, Id, Pd, Zi, Zi, void 0, void 0, void 0, void 0, void 0, Rd, Os.bind(void 0, 0), Os.bind(void 0, 1), Ud, void 0, Bd, Nd, Md, Gd, Wd, void 0, void 0, void 0, void 0, void 0, void 0, void 0, void 0, void 0, void 0, void 0, void 0, void 0, void 0, void 0, void 0, void 0, void 0, void 0, void 0, void 0, void 0, void 0, void 0, void 0, void 0, void 0, void 0, void 0, void 0, void 0, void 0, void 0, ir.bind(void 0, 1), ir.bind(void 0, 2), ir.bind(void 0, 3), ir.bind(void 0, 4), ir.bind(void 0, 5), ir.bind(void 0, 6), ir.bind(void 0, 7), ir.bind(void 0, 8), ar.bind(void 0, 1), ar.bind(void 0, 2), ar.bind(void 0, 3), ar.bind(void 0, 4), ar.bind(void 0, 5), ar.bind(void 0, 6), ar.bind(void 0, 7), ar.bind(void 0, 8), oe.bind(void 0, 0, 0, 0, 0, 0), oe.bind(void 0, 0, 0, 0, 0, 1), oe.bind(void 0, 0, 0, 0, 0, 2), oe.bind(void 0, 0, 0, 0, 0, 3), oe.bind(void 0, 0, 0, 0, 1, 0), oe.bind(void 0, 0, 0, 0, 1, 1), oe.bind(void 0, 0, 0, 0, 1, 2), oe.bind(void 0, 0, 0, 0, 1, 3), oe.bind(void 0, 0, 0, 1, 0, 0), oe.bind(void 0, 0, 0, 1, 0, 1), oe.bind(void 0, 0, 0, 1, 0, 2), oe.bind(void 0, 0, 0, 1, 0, 3), oe.bind(void 0, 0, 0, 1, 1, 0), oe.bind(void 0, 0, 0, 1, 1, 1), oe.bind(void 0, 0, 0, 1, 1, 2), oe.bind(void 0, 0, 0, 1, 1, 3), oe.bind(void 0, 0, 1, 0, 0, 0), oe.bind(void 0, 0, 1, 0, 0, 1), oe.bind(void 0, 0, 1, 0, 0, 2), oe.bind(void 0, 0, 1, 0, 0, 3), oe.bind(void 0, 0, 1, 0, 1, 0), oe.bind(void 0, 0, 1, 0, 1, 1), oe.bind(void 0, 0, 1, 0, 1, 2), oe.bind(void 0, 0, 1, 0, 1, 3), oe.bind(void 0, 0, 1, 1, 0, 0), oe.bind(void 0, 0, 1, 1, 0, 1), oe.bind(void 0, 0, 1, 1, 0, 2), oe.bind(void 0, 0, 1, 1, 0, 3), oe.bind(void 0, 0, 1, 1, 1, 0), oe.bind(void 0, 0, 1, 1, 1, 1), oe.bind(void 0, 0, 1, 1, 1, 2), oe.bind(void 0, 0, 1, 1, 1, 3), oe.bind(void 0, 1, 0, 0, 0, 0), oe.bind(void 0, 1, 0, 0, 0, 1), oe.bind(void 0, 1, 0, 0, 0, 2), oe.bind(void 0, 1, 0, 0, 0, 3), oe.bind(void 0, 1, 0, 0, 1, 0), oe.bind(void 0, 1, 0, 0, 1, 1), oe.bind(void 0, 1, 0, 0, 1, 2), oe.bind(void 0, 1, 0, 0, 1, 3), oe.bind(void 0, 1, 0, 1, 0, 0), oe.bind(void 0, 1, 0, 1, 0, 1), oe.bind(void 0, 1, 0, 1, 0, 2), oe.bind(void 0, 1, 0, 1, 0, 3), oe.bind(void 0, 1, 0, 1, 1, 0), oe.bind(void 0, 1, 0, 1, 1, 1), oe.bind(void 0, 1, 0, 1, 1, 2), oe.bind(void 0, 1, 0, 1, 1, 3), oe.bind(void 0, 1, 1, 0, 0, 0), oe.bind(void 0, 1, 1, 0, 0, 1), oe.bind(void 0, 1, 1, 0, 0, 2), oe.bind(void 0, 1, 1, 0, 0, 3), oe.bind(void 0, 1, 1, 0, 1, 0), oe.bind(void 0, 1, 1, 0, 1, 1), oe.bind(void 0, 1, 1, 0, 1, 2), oe.bind(void 0, 1, 1, 0, 1, 3), oe.bind(void 0, 1, 1, 1, 0, 0), oe.bind(void 0, 1, 1, 1, 0, 1), oe.bind(void 0, 1, 1, 1, 0, 2), oe.bind(void 0, 1, 1, 1, 0, 3), oe.bind(void 0, 1, 1, 1, 1, 0), oe.bind(void 0, 1, 1, 1, 1, 1), oe.bind(void 0, 1, 1, 1, 1, 2), oe.bind(void 0, 1, 1, 1, 1, 3)];
function Ar(e) {
  this.char = e, this.state = {}, this.activeState = null;
}
function sa(e, t, r2) {
  this.contextName = r2, this.startIndex = e, this.endOffset = t;
}
function $d(e, t, r2) {
  this.contextName = e, this.openRange = null, this.ranges = [], this.checkStart = t, this.checkEnd = r2;
}
function Tt(e, t) {
  this.context = e, this.index = t, this.length = e.length, this.current = e[t], this.backtrack = e.slice(0, t), this.lookahead = e.slice(t + 1);
}
function An(e) {
  this.eventId = e, this.subscribers = [];
}
function jd(e) {
  var t = this, r2 = ["start", "end", "next", "newToken", "contextStart", "contextEnd", "insertToken", "removeToken", "removeRange", "replaceToken", "replaceRange", "composeRUD", "updateContextsRanges"];
  r2.forEach(function(i) {
    Object.defineProperty(t.events, i, { value: new An(i) });
  }), e && r2.forEach(function(i) {
    var a = e[i];
    typeof a == "function" && t.events[i].subscribe(a);
  });
  var n = ["insertToken", "removeToken", "removeRange", "replaceToken", "replaceRange", "composeRUD"];
  n.forEach(function(i) {
    t.events[i].subscribe(t.updateContextsRanges);
  });
}
function Me(e) {
  this.tokens = [], this.registeredContexts = {}, this.contextCheckers = [], this.events = {}, this.registeredModifiers = [], jd.call(this, e);
}
Ar.prototype.setState = function(e, t) {
  return this.state[e] = t, this.activeState = { key: e, value: this.state[e] }, this.activeState;
};
Ar.prototype.getState = function(e) {
  return this.state[e] || null;
};
Me.prototype.inboundIndex = function(e) {
  return e >= 0 && e < this.tokens.length;
};
Me.prototype.composeRUD = function(e) {
  var t = this, r2 = true, n = e.map(function(a) {
    return t[a[0]].apply(t, a.slice(1).concat(r2));
  }), i = function(a) {
    return typeof a == "object" && a.hasOwnProperty("FAIL");
  };
  if (n.every(i))
    return { FAIL: "composeRUD: one or more operations hasn't completed successfully", report: n.filter(i) };
  this.dispatch("composeRUD", [n.filter(function(a) {
    return !i(a);
  })]);
};
Me.prototype.replaceRange = function(e, t, r2, n) {
  t = t !== null ? t : this.tokens.length;
  var i = r2.every(function(o) {
    return o instanceof Ar;
  });
  if (!isNaN(e) && this.inboundIndex(e) && i) {
    var a = this.tokens.splice.apply(this.tokens, [e, t].concat(r2));
    return n || this.dispatch("replaceToken", [e, t, r2]), [a, r2];
  } else
    return { FAIL: "replaceRange: invalid tokens or startIndex." };
};
Me.prototype.replaceToken = function(e, t, r2) {
  if (!isNaN(e) && this.inboundIndex(e) && t instanceof Ar) {
    var n = this.tokens.splice(e, 1, t);
    return r2 || this.dispatch("replaceToken", [e, t]), [n[0], t];
  } else
    return { FAIL: "replaceToken: invalid token or index." };
};
Me.prototype.removeRange = function(e, t, r2) {
  t = isNaN(t) ? this.tokens.length : t;
  var n = this.tokens.splice(e, t);
  return r2 || this.dispatch("removeRange", [n, e, t]), n;
};
Me.prototype.removeToken = function(e, t) {
  if (!isNaN(e) && this.inboundIndex(e)) {
    var r2 = this.tokens.splice(e, 1);
    return t || this.dispatch("removeToken", [r2, e]), r2;
  } else
    return { FAIL: "removeToken: invalid token index." };
};
Me.prototype.insertToken = function(e, t, r2) {
  var n = e.every(function(i) {
    return i instanceof Ar;
  });
  return n ? (this.tokens.splice.apply(this.tokens, [t, 0].concat(e)), r2 || this.dispatch("insertToken", [e, t]), e) : { FAIL: "insertToken: invalid token(s)." };
};
Me.prototype.registerModifier = function(e, t, r2) {
  this.events.newToken.subscribe(function(n, i) {
    var a = [n, i], o = t === null || t.apply(this, a) === true, u = [n, i];
    if (o) {
      var s = r2.apply(this, u);
      n.setState(e, s);
    }
  }), this.registeredModifiers.push(e);
};
An.prototype.subscribe = function(e) {
  return typeof e == "function" ? this.subscribers.push(e) - 1 : { FAIL: "invalid '" + this.eventId + "' event handler" };
};
An.prototype.unsubscribe = function(e) {
  this.subscribers.splice(e, 1);
};
Tt.prototype.setCurrentIndex = function(e) {
  this.index = e, this.current = this.context[e], this.backtrack = this.context.slice(0, e), this.lookahead = this.context.slice(e + 1);
};
Tt.prototype.get = function(e) {
  switch (true) {
    case e === 0:
      return this.current;
    case (e < 0 && Math.abs(e) <= this.backtrack.length):
      return this.backtrack.slice(e)[0];
    case (e > 0 && e <= this.lookahead.length):
      return this.lookahead[e - 1];
    default:
      return null;
  }
};
Me.prototype.rangeToText = function(e) {
  if (e instanceof sa)
    return this.getRangeTokens(e).map(function(t) {
      return t.char;
    }).join("");
};
Me.prototype.getText = function() {
  return this.tokens.map(function(e) {
    return e.char;
  }).join("");
};
Me.prototype.getContext = function(e) {
  var t = this.registeredContexts[e];
  return t || null;
};
Me.prototype.on = function(e, t) {
  var r2 = this.events[e];
  return r2 ? r2.subscribe(t) : null;
};
Me.prototype.dispatch = function(e, t) {
  var r2 = this, n = this.events[e];
  n instanceof An && n.subscribers.forEach(function(i) {
    i.apply(r2, t || []);
  });
};
Me.prototype.registerContextChecker = function(e, t, r2) {
  if (this.getContext(e))
    return { FAIL: "context name '" + e + "' is already registered." };
  if (typeof t != "function")
    return { FAIL: "missing context start check." };
  if (typeof r2 != "function")
    return { FAIL: "missing context end check." };
  var n = new $d(e, t, r2);
  return this.registeredContexts[e] = n, this.contextCheckers.push(n), n;
};
Me.prototype.getRangeTokens = function(e) {
  var t = e.startIndex + e.endOffset;
  return [].concat(this.tokens.slice(e.startIndex, t));
};
Me.prototype.getContextRanges = function(e) {
  var t = this.getContext(e);
  return t ? t.ranges : { FAIL: "context checker '" + e + "' is not registered." };
};
Me.prototype.resetContextsRanges = function() {
  var e = this.registeredContexts;
  for (var t in e)
    if (e.hasOwnProperty(t)) {
      var r2 = e[t];
      r2.ranges = [];
    }
};
Me.prototype.updateContextsRanges = function() {
  this.resetContextsRanges();
  for (var e = this.tokens.map(function(n) {
    return n.char;
  }), t = 0; t < e.length; t++) {
    var r2 = new Tt(e, t);
    this.runContextCheck(r2);
  }
  this.dispatch("updateContextsRanges", [this.registeredContexts]);
};
Me.prototype.setEndOffset = function(e, t) {
  var r2 = this.getContext(t).openRange.startIndex, n = new sa(r2, e, t), i = this.getContext(t).ranges;
  return n.rangeId = t + "." + i.length, i.push(n), this.getContext(t).openRange = null, n;
};
Me.prototype.runContextCheck = function(e) {
  var t = this, r2 = e.index;
  this.contextCheckers.forEach(function(n) {
    var i = n.contextName, a = t.getContext(i).openRange;
    if (!a && n.checkStart(e) && (a = new sa(r2, null, i), t.getContext(i).openRange = a, t.dispatch("contextStart", [i, r2])), a && n.checkEnd(e)) {
      var o = r2 - a.startIndex + 1, u = t.setEndOffset(o, i);
      t.dispatch("contextEnd", [i, u]);
    }
  });
};
Me.prototype.tokenize = function(e) {
  this.tokens = [], this.resetContextsRanges();
  var t = Array.from(e);
  this.dispatch("start");
  for (var r2 = 0; r2 < t.length; r2++) {
    var n = t[r2], i = new Tt(t, r2);
    this.dispatch("next", [i]), this.runContextCheck(i);
    var a = new Ar(n);
    this.tokens.push(a), this.dispatch("newToken", [a, i]);
  }
  return this.dispatch("end", [this.tokens]), this.tokens;
};
function lr(e) {
  return /[\u0600-\u065F\u066A-\u06D2\u06FA-\u06FF]/.test(e);
}
function au(e) {
  return /[\u0630\u0690\u0621\u0631\u0661\u0671\u0622\u0632\u0672\u0692\u06C2\u0623\u0673\u0693\u06C3\u0624\u0694\u06C4\u0625\u0675\u0695\u06C5\u06E5\u0676\u0696\u06C6\u0627\u0677\u0697\u06C7\u0648\u0688\u0698\u06C8\u0689\u0699\u06C9\u068A\u06CA\u066B\u068B\u06CB\u068C\u068D\u06CD\u06FD\u068E\u06EE\u06FE\u062F\u068F\u06CF\u06EF]/.test(e);
}
function fr(e) {
  return /[\u0600-\u0605\u060C-\u060E\u0610-\u061B\u061E\u064B-\u065F\u0670\u06D6-\u06DC\u06DF-\u06E4\u06E7\u06E8\u06EA-\u06ED]/.test(e);
}
function Sn(e) {
  return /[A-z]/.test(e);
}
function zd(e) {
  return /\s/.test(e);
}
function mt(e) {
  this.font = e, this.features = {};
}
function gr(e) {
  this.id = e.id, this.tag = e.tag, this.substitution = e.substitution;
}
function Xr(e, t) {
  if (!e)
    return -1;
  switch (t.format) {
    case 1:
      return t.glyphs.indexOf(e);
    case 2:
      for (var r2 = t.ranges, n = 0; n < r2.length; n++) {
        var i = r2[n];
        if (e >= i.start && e <= i.end) {
          var a = e - i.start;
          return i.index + a;
        }
      }
      break;
    default:
      return -1;
  }
  return -1;
}
function Vd(e, t) {
  var r2 = Xr(e, t.coverage);
  return r2 === -1 ? null : e + t.deltaGlyphId;
}
function Hd(e, t) {
  var r2 = Xr(e, t.coverage);
  return r2 === -1 ? null : t.substitute[r2];
}
function Qi(e, t) {
  for (var r2 = [], n = 0; n < e.length; n++) {
    var i = e[n], a = t.current;
    a = Array.isArray(a) ? a[0] : a;
    var o = Xr(a, i);
    o !== -1 && r2.push(o);
  }
  return r2.length !== e.length ? -1 : r2;
}
function Xd(e, t) {
  var r2 = t.inputCoverage.length + t.lookaheadCoverage.length + t.backtrackCoverage.length;
  if (e.context.length < r2)
    return [];
  var n = Qi(t.inputCoverage, e);
  if (n === -1)
    return [];
  var i = t.inputCoverage.length - 1;
  if (e.lookahead.length < t.lookaheadCoverage.length)
    return [];
  for (var a = e.lookahead.slice(i); a.length && fr(a[0].char); )
    a.shift();
  var o = new Tt(a, 0), u = Qi(t.lookaheadCoverage, o), s = [].concat(e.backtrack);
  for (s.reverse(); s.length && fr(s[0].char); )
    s.shift();
  if (s.length < t.backtrackCoverage.length)
    return [];
  var l = new Tt(s, 0), f = Qi(t.backtrackCoverage, l), c = n.length === t.inputCoverage.length && u.length === t.lookaheadCoverage.length && f.length === t.backtrackCoverage.length, p2 = [];
  if (c)
    for (var d = 0; d < t.lookupRecords.length; d++)
      for (var D = t.lookupRecords[d], v = D.lookupListIndex, g = this.getLookupByIndex(v), y = 0; y < g.subtables.length; y++) {
        var b = g.subtables[y], C = this.getLookupMethod(g, b), k = this.getSubstitutionType(g, b);
        if (k === "12")
          for (var S = 0; S < n.length; S++) {
            var E = e.get(S), L = C(E);
            L && p2.push(L);
          }
      }
  return p2;
}
function qd(e, t) {
  var r2 = e.current, n = Xr(r2, t.coverage);
  if (n === -1)
    return null;
  for (var i, a = t.ligatureSets[n], o = 0; o < a.length; o++) {
    i = a[o];
    for (var u = 0; u < i.components.length; u++) {
      var s = e.lookahead[u], l = i.components[u];
      if (s !== l)
        break;
      if (u === i.components.length - 1)
        return i;
    }
  }
  return null;
}
function Yd(e, t) {
  var r2 = Xr(e, t.coverage);
  return r2 === -1 ? null : t.sequences[r2];
}
mt.prototype.getDefaultScriptFeaturesIndexes = function() {
  for (var e = this.font.tables.gsub.scripts, t = 0; t < e.length; t++) {
    var r2 = e[t];
    if (r2.tag === "DFLT")
      return r2.script.defaultLangSys.featureIndexes;
  }
  return [];
};
mt.prototype.getScriptFeaturesIndexes = function(e) {
  var t = this.font.tables;
  if (!t.gsub)
    return [];
  if (!e)
    return this.getDefaultScriptFeaturesIndexes();
  for (var r2 = this.font.tables.gsub.scripts, n = 0; n < r2.length; n++) {
    var i = r2[n];
    if (i.tag === e && i.script.defaultLangSys)
      return i.script.defaultLangSys.featureIndexes;
    var a = i.langSysRecords;
    if (a)
      for (var o = 0; o < a.length; o++) {
        var u = a[o];
        if (u.tag === e) {
          var s = u.langSys;
          return s.featureIndexes;
        }
      }
  }
  return this.getDefaultScriptFeaturesIndexes();
};
mt.prototype.mapTagsToFeatures = function(e, t) {
  for (var r2 = {}, n = 0; n < e.length; n++) {
    var i = e[n].tag, a = e[n].feature;
    r2[i] = a;
  }
  this.features[t].tags = r2;
};
mt.prototype.getScriptFeatures = function(e) {
  var t = this.features[e];
  if (this.features.hasOwnProperty(e))
    return t;
  var r2 = this.getScriptFeaturesIndexes(e);
  if (!r2)
    return null;
  var n = this.font.tables.gsub;
  return t = r2.map(function(i) {
    return n.features[i];
  }), this.features[e] = t, this.mapTagsToFeatures(t, e), t;
};
mt.prototype.getSubstitutionType = function(e, t) {
  var r2 = e.lookupType.toString(), n = t.substFormat.toString();
  return r2 + n;
};
mt.prototype.getLookupMethod = function(e, t) {
  var r2 = this, n = this.getSubstitutionType(e, t);
  switch (n) {
    case "11":
      return function(i) {
        return Vd.apply(r2, [i, t]);
      };
    case "12":
      return function(i) {
        return Hd.apply(r2, [i, t]);
      };
    case "63":
      return function(i) {
        return Xd.apply(r2, [i, t]);
      };
    case "41":
      return function(i) {
        return qd.apply(r2, [i, t]);
      };
    case "21":
      return function(i) {
        return Yd.apply(r2, [i, t]);
      };
    default:
      throw new Error("lookupType: " + e.lookupType + " - substFormat: " + t.substFormat + " is not yet supported");
  }
};
mt.prototype.lookupFeature = function(e) {
  var t = e.contextParams, r2 = t.index, n = this.getFeature({ tag: e.tag, script: e.script });
  if (!n)
    return new Error("font '" + this.font.names.fullName.en + "' doesn't support feature '" + e.tag + "' for script '" + e.script + "'.");
  for (var i = this.getFeatureLookups(n), a = [].concat(t.context), o = 0; o < i.length; o++)
    for (var u = i[o], s = this.getLookupSubtables(u), l = 0; l < s.length; l++) {
      var f = s[l], c = this.getSubstitutionType(u, f), p2 = this.getLookupMethod(u, f), d = void 0;
      switch (c) {
        case "11":
          d = p2(t.current), d && a.splice(r2, 1, new gr({ id: 11, tag: e.tag, substitution: d }));
          break;
        case "12":
          d = p2(t.current), d && a.splice(r2, 1, new gr({ id: 12, tag: e.tag, substitution: d }));
          break;
        case "63":
          d = p2(t), Array.isArray(d) && d.length && a.splice(r2, 1, new gr({ id: 63, tag: e.tag, substitution: d }));
          break;
        case "41":
          d = p2(t), d && a.splice(r2, 1, new gr({ id: 41, tag: e.tag, substitution: d }));
          break;
        case "21":
          d = p2(t.current), d && a.splice(r2, 1, new gr({ id: 21, tag: e.tag, substitution: d }));
          break;
      }
      t = new Tt(a, r2), !(Array.isArray(d) && !d.length) && (d = null);
    }
  return a.length ? a : null;
};
mt.prototype.supports = function(e) {
  if (!e.script)
    return false;
  this.getScriptFeatures(e.script);
  var t = this.features.hasOwnProperty(e.script);
  if (!e.tag)
    return t;
  var r2 = this.features[e.script].some(function(n) {
    return n.tag === e.tag;
  });
  return t && r2;
};
mt.prototype.getLookupSubtables = function(e) {
  return e.subtables || null;
};
mt.prototype.getLookupByIndex = function(e) {
  var t = this.font.tables.gsub.lookups;
  return t[e] || null;
};
mt.prototype.getFeatureLookups = function(e) {
  return e.lookupListIndexes.map(this.getLookupByIndex.bind(this));
};
mt.prototype.getFeature = function(t) {
  if (!this.font)
    return { FAIL: "No font was found" };
  this.features.hasOwnProperty(t.script) || this.getScriptFeatures(t.script);
  var r2 = this.features[t.script];
  return r2 ? r2.tags[t.tag] ? this.features[t.script].tags[t.tag] : null : { FAIL: "No feature for script " + t.script };
};
function Zd(e) {
  var t = e.current, r2 = e.get(-1);
  return r2 === null && lr(t) || !lr(r2) && lr(t);
}
function Jd(e) {
  var t = e.get(1);
  return t === null || !lr(t);
}
var Kd = { startCheck: Zd, endCheck: Jd };
function Qd(e) {
  var t = e.current, r2 = e.get(-1);
  return (lr(t) || fr(t)) && !lr(r2);
}
function e0(e) {
  var t = e.get(1);
  switch (true) {
    case t === null:
      return true;
    case (!lr(t) && !fr(t)):
      var r2 = zd(t);
      if (!r2)
        return true;
      if (r2) {
        var n = false;
        if (n = e.lookahead.some(function(i) {
          return lr(i) || fr(i);
        }), !n)
          return true;
      }
      break;
    default:
      return false;
  }
}
var t0 = { startCheck: Qd, endCheck: e0 };
function r0(e, t, r2) {
  t[r2].setState(e.tag, e.substitution);
}
function n0(e, t, r2) {
  t[r2].setState(e.tag, e.substitution);
}
function i0(e, t, r2) {
  e.substitution.forEach(function(n, i) {
    var a = t[r2 + i];
    a.setState(e.tag, n);
  });
}
function a0(e, t, r2) {
  var n = t[r2];
  n.setState(e.tag, e.substitution.ligGlyph);
  for (var i = e.substitution.components.length, a = 0; a < i; a++)
    n = t[r2 + a + 1], n.setState("deleted", true);
}
var Ls = { 11: r0, 12: n0, 63: i0, 41: a0 };
function ua(e, t, r2) {
  e instanceof gr && Ls[e.id] && Ls[e.id](e, t, r2);
}
function o0(e) {
  for (var t = [].concat(e.backtrack), r2 = t.length - 1; r2 >= 0; r2--) {
    var n = t[r2], i = au(n), a = fr(n);
    if (!i && !a)
      return true;
    if (i)
      return false;
  }
  return false;
}
function s0(e) {
  if (au(e.current))
    return false;
  for (var t = 0; t < e.lookahead.length; t++) {
    var r2 = e.lookahead[t], n = fr(r2);
    if (!n)
      return true;
  }
  return false;
}
function u0(e) {
  var t = this, r2 = "arab", n = this.featuresTags[r2], i = this.tokenizer.getRangeTokens(e);
  if (i.length !== 1) {
    var a = new Tt(i.map(function(u) {
      return u.getState("glyphIndex");
    }), 0), o = new Tt(i.map(function(u) {
      return u.char;
    }), 0);
    i.forEach(function(u, s) {
      if (!fr(u.char)) {
        a.setCurrentIndex(s), o.setCurrentIndex(s);
        var l = 0;
        o0(o) && (l |= 1), s0(o) && (l |= 2);
        var f;
        switch (l) {
          case 1:
            f = "fina";
            break;
          case 2:
            f = "init";
            break;
          case 3:
            f = "medi";
            break;
        }
        if (n.indexOf(f) !== -1) {
          var c = t.query.lookupFeature({ tag: f, script: r2, contextParams: a });
          if (c instanceof Error)
            return console.info(c.message);
          c.forEach(function(p2, d) {
            p2 instanceof gr && (ua(p2, i, d), a.context[d] = p2.substitution);
          });
        }
      }
    });
  }
}
function Is(e, t) {
  var r2 = e.map(function(n) {
    return n.activeState.value;
  });
  return new Tt(r2, t || 0);
}
function l0(e) {
  var t = this, r2 = "arab", n = this.tokenizer.getRangeTokens(e), i = Is(n);
  i.context.forEach(function(a, o) {
    i.setCurrentIndex(o);
    var u = t.query.lookupFeature({ tag: "rlig", script: r2, contextParams: i });
    u.length && (u.forEach(function(s) {
      return ua(s, n, o);
    }), i = Is(n));
  });
}
function f0(e) {
  var t = e.current, r2 = e.get(-1);
  return r2 === null && Sn(t) || !Sn(r2) && Sn(t);
}
function c0(e) {
  var t = e.get(1);
  return t === null || !Sn(t);
}
var p0 = { startCheck: f0, endCheck: c0 };
function Ps(e, t) {
  var r2 = e.map(function(n) {
    return n.activeState.value;
  });
  return new Tt(r2, t || 0);
}
function h0(e) {
  var t = this, r2 = "latn", n = this.tokenizer.getRangeTokens(e), i = Ps(n);
  i.context.forEach(function(a, o) {
    i.setCurrentIndex(o);
    var u = t.query.lookupFeature({ tag: "liga", script: r2, contextParams: i });
    u.length && (u.forEach(function(s) {
      return ua(s, n, o);
    }), i = Ps(n));
  });
}
function Ot(e) {
  this.baseDir = e || "ltr", this.tokenizer = new Me(), this.featuresTags = {};
}
Ot.prototype.setText = function(e) {
  this.text = e;
};
Ot.prototype.contextChecks = { latinWordCheck: p0, arabicWordCheck: Kd, arabicSentenceCheck: t0 };
function ea(e) {
  var t = this.contextChecks[e + "Check"];
  return this.tokenizer.registerContextChecker(e, t.startCheck, t.endCheck);
}
function d0() {
  return ea.call(this, "latinWord"), ea.call(this, "arabicWord"), ea.call(this, "arabicSentence"), this.tokenizer.tokenize(this.text);
}
function v0() {
  var e = this, t = this.tokenizer.getContextRanges("arabicSentence");
  t.forEach(function(r2) {
    var n = e.tokenizer.getRangeTokens(r2);
    e.tokenizer.replaceRange(r2.startIndex, r2.endOffset, n.reverse());
  });
}
Ot.prototype.registerFeatures = function(e, t) {
  var r2 = this, n = t.filter(function(i) {
    return r2.query.supports({ script: e, tag: i });
  });
  this.featuresTags.hasOwnProperty(e) ? this.featuresTags[e] = this.featuresTags[e].concat(n) : this.featuresTags[e] = n;
};
Ot.prototype.applyFeatures = function(e, t) {
  if (!e)
    throw new Error("No valid font was provided to apply features");
  this.query || (this.query = new mt(e));
  for (var r2 = 0; r2 < t.length; r2++) {
    var n = t[r2];
    this.query.supports({ script: n.script }) && this.registerFeatures(n.script, n.tags);
  }
};
Ot.prototype.registerModifier = function(e, t, r2) {
  this.tokenizer.registerModifier(e, t, r2);
};
function la() {
  if (this.tokenizer.registeredModifiers.indexOf("glyphIndex") === -1)
    throw new Error("glyphIndex modifier is required to apply arabic presentation features.");
}
function g0() {
  var e = this, t = "arab";
  if (this.featuresTags.hasOwnProperty(t)) {
    la.call(this);
    var r2 = this.tokenizer.getContextRanges("arabicWord");
    r2.forEach(function(n) {
      u0.call(e, n);
    });
  }
}
function m0() {
  var e = this, t = "arab";
  if (this.featuresTags.hasOwnProperty(t)) {
    var r2 = this.featuresTags[t];
    if (r2.indexOf("rlig") !== -1) {
      la.call(this);
      var n = this.tokenizer.getContextRanges("arabicWord");
      n.forEach(function(i) {
        l0.call(e, i);
      });
    }
  }
}
function D0() {
  var e = this, t = "latn";
  if (this.featuresTags.hasOwnProperty(t)) {
    var r2 = this.featuresTags[t];
    if (r2.indexOf("liga") !== -1) {
      la.call(this);
      var n = this.tokenizer.getContextRanges("latinWord");
      n.forEach(function(i) {
        h0.call(e, i);
      });
    }
  }
}
Ot.prototype.checkContextReady = function(e) {
  return !!this.tokenizer.getContext(e);
};
Ot.prototype.applyFeaturesToContexts = function() {
  this.checkContextReady("arabicWord") && (g0.call(this), m0.call(this)), this.checkContextReady("latinWord") && D0.call(this), this.checkContextReady("arabicSentence") && v0.call(this);
};
Ot.prototype.processText = function(e) {
  (!this.text || this.text !== e) && (this.setText(e), d0.call(this), this.applyFeaturesToContexts());
};
Ot.prototype.getBidiText = function(e) {
  return this.processText(e), this.tokenizer.getText();
};
Ot.prototype.getTextGlyphs = function(e) {
  this.processText(e);
  for (var t = [], r2 = 0; r2 < this.tokenizer.tokens.length; r2++) {
    var n = this.tokenizer.tokens[r2];
    if (!n.state.deleted) {
      var i = n.activeState.value;
      t.push(Array.isArray(i) ? i[0] : i);
    }
  }
  return t;
};
function st(e) {
  e = e || {}, e.tables = e.tables || {}, e.empty || (Nr(e.familyName, "When creating a new Font object, familyName is required."), Nr(e.styleName, "When creating a new Font object, styleName is required."), Nr(e.unitsPerEm, "When creating a new Font object, unitsPerEm is required."), Nr(e.ascender, "When creating a new Font object, ascender is required."), Nr(e.descender <= 0, "When creating a new Font object, negative descender value is required."), this.unitsPerEm = e.unitsPerEm || 1e3, this.ascender = e.ascender, this.descender = e.descender, this.createdTimestamp = e.createdTimestamp, this.tables = Object.assign(e.tables, { os2: Object.assign({ usWeightClass: e.weightClass || this.usWeightClasses.MEDIUM, usWidthClass: e.widthClass || this.usWidthClasses.MEDIUM, fsSelection: e.fsSelection || this.fsSelectionValues.REGULAR }, e.tables.os2) })), this.supported = true, this.glyphs = new $t.GlyphSet(this, e.glyphs || []), this.encoding = new Vs(this), this.position = new zr(this), this.substitution = new gt(this), this.tables = this.tables || {}, this._push = null, this._hmtxTableData = {}, Object.defineProperty(this, "hinting", { get: function() {
    if (this._hinting)
      return this._hinting;
    if (this.outlinesFormat === "truetype")
      return this._hinting = new tu(this);
  } });
}
st.prototype.hasChar = function(e) {
  return this.encoding.charToGlyphIndex(e) !== null;
};
st.prototype.charToGlyphIndex = function(e) {
  return this.encoding.charToGlyphIndex(e);
};
st.prototype.charToGlyph = function(e) {
  var t = this.charToGlyphIndex(e), r2 = this.glyphs.get(t);
  return r2 || (r2 = this.glyphs.get(0)), r2;
};
st.prototype.updateFeatures = function(e) {
  return this.defaultRenderOptions.features.map(function(t) {
    return t.script === "latn" ? { script: "latn", tags: t.tags.filter(function(r2) {
      return e[r2];
    }) } : t;
  });
};
st.prototype.stringToGlyphs = function(e, t) {
  var r2 = this, n = new Ot(), i = function(c) {
    return r2.charToGlyphIndex(c.char);
  };
  n.registerModifier("glyphIndex", null, i);
  var a = t ? this.updateFeatures(t.features) : this.defaultRenderOptions.features;
  n.applyFeatures(this, a);
  for (var o = n.getTextGlyphs(e), u = o.length, s = new Array(u), l = this.glyphs.get(0), f = 0; f < u; f += 1)
    s[f] = this.glyphs.get(o[f]) || l;
  return s;
};
st.prototype.getKerningValue = function(e, t) {
  e = e.index || e, t = t.index || t;
  var r2 = this.position.defaultKerningTables;
  return r2 ? this.position.getKerningValue(r2, e, t) : this.kerningPairs[e + "," + t] || 0;
};
st.prototype.defaultRenderOptions = { kerning: true, features: [{ script: "arab", tags: ["init", "medi", "fina", "rlig"] }, { script: "latn", tags: ["liga", "rlig"] }] };
st.prototype.forEachGlyph = function(e, t, r2, n, i, a) {
  t = t !== void 0 ? t : 0, r2 = r2 !== void 0 ? r2 : 0, n = n !== void 0 ? n : 72, i = Object.assign({}, this.defaultRenderOptions, i);
  var o = 1 / this.unitsPerEm * n, u = this.stringToGlyphs(e, i), s;
  if (i.kerning) {
    var l = i.script || this.position.getDefaultScriptName();
    s = this.position.getKerningTables(l, i.language);
  }
  for (var f = 0; f < u.length; f += 1) {
    var c = u[f];
    if (a.call(this, c, t, r2, n, i), c.advanceWidth && (t += c.advanceWidth * o), i.kerning && f < u.length - 1) {
      var p2 = s ? this.position.getKerningValue(s, c.index, u[f + 1].index) : this.getKerningValue(c, u[f + 1]);
      t += p2 * o;
    }
    i.letterSpacing ? t += i.letterSpacing * n : i.tracking && (t += i.tracking / 1e3 * n);
  }
  return t;
};
st.prototype.getPath = function(e, t, r2, n, i) {
  var a = new ot();
  return this.forEachGlyph(e, t, r2, n, i, function(o, u, s, l) {
    var f = o.getPath(u, s, l, i, this);
    a.extend(f);
  }), a;
};
st.prototype.getPaths = function(e, t, r2, n, i) {
  var a = [];
  return this.forEachGlyph(e, t, r2, n, i, function(o, u, s, l) {
    var f = o.getPath(u, s, l, i, this);
    a.push(f);
  }), a;
};
st.prototype.getAdvanceWidth = function(e, t, r2) {
  return this.forEachGlyph(e, 0, 0, t, r2, function() {
  });
};
st.prototype.fsSelectionValues = { ITALIC: 1, UNDERSCORE: 2, NEGATIVE: 4, OUTLINED: 8, STRIKEOUT: 16, BOLD: 32, REGULAR: 64, USER_TYPO_METRICS: 128, WWS: 256, OBLIQUE: 512 };
st.prototype.usWidthClasses = { ULTRA_CONDENSED: 1, EXTRA_CONDENSED: 2, CONDENSED: 3, SEMI_CONDENSED: 4, MEDIUM: 5, SEMI_EXPANDED: 6, EXPANDED: 7, EXTRA_EXPANDED: 8, ULTRA_EXPANDED: 9 };
st.prototype.usWeightClasses = { THIN: 100, EXTRA_LIGHT: 200, LIGHT: 300, NORMAL: 400, MEDIUM: 500, SEMI_BOLD: 600, BOLD: 700, EXTRA_BOLD: 800, BLACK: 900 };
function y0(e, t) {
  t.parseUShort(), e.length = t.parseULong(), e.language = t.parseULong();
  var r2;
  e.groupCount = r2 = t.parseULong(), e.glyphIndexMap = {};
  for (var n = 0; n < r2; n += 1)
    for (var i = t.parseULong(), a = t.parseULong(), o = t.parseULong(), u = i; u <= a; u += 1)
      e.glyphIndexMap[u] = o, o++;
}
function b0(e, t, r2, n, i) {
  e.length = t.parseUShort(), e.language = t.parseUShort();
  var a;
  e.segCount = a = t.parseUShort() >> 1, t.skip("uShort", 3), e.glyphIndexMap = {};
  for (var o = new se.Parser(r2, n + i + 14), u = new se.Parser(r2, n + i + 16 + a * 2), s = new se.Parser(r2, n + i + 16 + a * 4), l = new se.Parser(r2, n + i + 16 + a * 6), f = n + i + 16 + a * 8, c = 0; c < a - 1; c += 1)
    for (var p2 = void 0, d = o.parseUShort(), D = u.parseUShort(), v = s.parseShort(), g = l.parseUShort(), y = D; y <= d; y += 1)
      g !== 0 ? (f = l.offset + l.relativeOffset - 2, f += g, f += (y - D) * 2, p2 = se.getUShort(r2, f), p2 !== 0 && (p2 = p2 + v & 65535)) : p2 = y + v & 65535, e.glyphIndexMap[y] = p2;
}
function x0(e, t) {
  var r2 = {};
  r2.version = se.getUShort(e, t), Te.argument(r2.version === 0, "cmap table version should be 0."), r2.numTables = se.getUShort(e, t + 2);
  for (var n = -1, i = r2.numTables - 1; i >= 0; i -= 1) {
    var a = se.getUShort(e, t + 4 + i * 8), o = se.getUShort(e, t + 4 + i * 8 + 2);
    if (a === 3 && (o === 0 || o === 1 || o === 10) || a === 0 && (o === 0 || o === 1 || o === 2 || o === 3 || o === 4)) {
      n = se.getULong(e, t + 4 + i * 8 + 4);
      break;
    }
  }
  if (n === -1)
    throw new Error("No valid cmap sub-tables found.");
  var u = new se.Parser(e, t + n);
  if (r2.format = u.parseUShort(), r2.format === 12)
    y0(r2, u);
  else if (r2.format === 4)
    b0(r2, u, e, t, n);
  else
    throw new Error("Only format 4 and 12 cmap tables are supported (found format " + r2.format + ").");
  return r2;
}
var w0 = { parse: x0 };
function na(e) {
  var t;
  return e.length < 1240 ? t = 107 : e.length < 33900 ? t = 1131 : t = 32768, t;
}
function sr(e, t, r2) {
  var n = [], i = [], a = se.getCard16(e, t), o, u;
  if (a !== 0) {
    var s = se.getByte(e, t + 2);
    o = t + (a + 1) * s + 2;
    for (var l = t + 3, f = 0; f < a + 1; f += 1)
      n.push(se.getOffset(e, l, s)), l += s;
    u = o + n[a];
  } else
    u = t + 2;
  for (var c = 0; c < n.length - 1; c += 1) {
    var p2 = se.getBytes(e, o + n[c], o + n[c + 1]);
    r2 && (p2 = r2(p2)), i.push(p2);
  }
  return { objects: i, startOffset: t, endOffset: u };
}
function E0(e, t) {
  var r2 = [], n = se.getCard16(e, t), i, a;
  if (n !== 0) {
    var o = se.getByte(e, t + 2);
    i = t + (n + 1) * o + 2;
    for (var u = t + 3, s = 0; s < n + 1; s += 1)
      r2.push(se.getOffset(e, u, o)), u += o;
    a = i + r2[n];
  } else
    a = t + 2;
  return { offsets: r2, startOffset: t, endOffset: a };
}
function F0(e, t, r2, n, i) {
  var a = se.getCard16(r2, n), o = 0;
  if (a !== 0) {
    var u = se.getByte(r2, n + 2);
    o = n + (a + 1) * u + 2;
  }
  var s = se.getBytes(r2, o + t[e], o + t[e + 1]);
  return i && (s = i(s)), s;
}
function C0(e) {
  for (var t = "", r2 = 15, n = ["0", "1", "2", "3", "4", "5", "6", "7", "8", "9", ".", "E", "E-", null, "-"]; ; ) {
    var i = e.parseByte(), a = i >> 4, o = i & 15;
    if (a === r2 || (t += n[a], o === r2))
      break;
    t += n[o];
  }
  return parseFloat(t);
}
function S0(e, t) {
  var r2, n, i, a;
  if (t === 28)
    return r2 = e.parseByte(), n = e.parseByte(), r2 << 8 | n;
  if (t === 29)
    return r2 = e.parseByte(), n = e.parseByte(), i = e.parseByte(), a = e.parseByte(), r2 << 24 | n << 16 | i << 8 | a;
  if (t === 30)
    return C0(e);
  if (t >= 32 && t <= 246)
    return t - 139;
  if (t >= 247 && t <= 250)
    return r2 = e.parseByte(), (t - 247) * 256 + r2 + 108;
  if (t >= 251 && t <= 254)
    return r2 = e.parseByte(), -(t - 251) * 256 - r2 - 108;
  throw new Error("Invalid b0 " + t);
}
function k0(e) {
  for (var t = {}, r2 = 0; r2 < e.length; r2 += 1) {
    var n = e[r2][0], i = e[r2][1], a = void 0;
    if (i.length === 1 ? a = i[0] : a = i, t.hasOwnProperty(n) && !isNaN(t[n]))
      throw new Error("Object " + t + " already has key " + n);
    t[n] = a;
  }
  return t;
}
function ou(e, t, r2) {
  t = t !== void 0 ? t : 0;
  var n = new se.Parser(e, t), i = [], a = [];
  for (r2 = r2 !== void 0 ? r2 : e.length; n.relativeOffset < r2; ) {
    var o = n.parseByte();
    o <= 21 ? (o === 12 && (o = 1200 + n.parseByte()), i.push([o, a]), a = []) : a.push(S0(n, o));
  }
  return k0(i);
}
function Gr(e, t) {
  return t <= 390 ? t = Hp[t] : t = e[t - 391], t;
}
function su(e, t, r2) {
  for (var n = {}, i, a = 0; a < t.length; a += 1) {
    var o = t[a];
    if (Array.isArray(o.type)) {
      var u = [];
      u.length = o.type.length;
      for (var s = 0; s < o.type.length; s++)
        i = e[o.op] !== void 0 ? e[o.op][s] : void 0, i === void 0 && (i = o.value !== void 0 && o.value[s] !== void 0 ? o.value[s] : null), o.type[s] === "SID" && (i = Gr(r2, i)), u[s] = i;
      n[o.name] = u;
    } else
      i = e[o.op], i === void 0 && (i = o.value !== void 0 ? o.value : null), o.type === "SID" && (i = Gr(r2, i)), n[o.name] = i;
  }
  return n;
}
function T0(e, t) {
  var r2 = {};
  return r2.formatMajor = se.getCard8(e, t), r2.formatMinor = se.getCard8(e, t + 1), r2.size = se.getCard8(e, t + 2), r2.offsetSize = se.getCard8(e, t + 3), r2.startOffset = t, r2.endOffset = t + 4, r2;
}
var _0 = [{ name: "version", op: 0, type: "SID" }, { name: "notice", op: 1, type: "SID" }, { name: "copyright", op: 1200, type: "SID" }, { name: "fullName", op: 2, type: "SID" }, { name: "familyName", op: 3, type: "SID" }, { name: "weight", op: 4, type: "SID" }, { name: "isFixedPitch", op: 1201, type: "number", value: 0 }, { name: "italicAngle", op: 1202, type: "number", value: 0 }, { name: "underlinePosition", op: 1203, type: "number", value: -100 }, { name: "underlineThickness", op: 1204, type: "number", value: 50 }, { name: "paintType", op: 1205, type: "number", value: 0 }, { name: "charstringType", op: 1206, type: "number", value: 2 }, { name: "fontMatrix", op: 1207, type: ["real", "real", "real", "real", "real", "real"], value: [1e-3, 0, 0, 1e-3, 0, 0] }, { name: "uniqueId", op: 13, type: "number" }, { name: "fontBBox", op: 5, type: ["number", "number", "number", "number"], value: [0, 0, 0, 0] }, { name: "strokeWidth", op: 1208, type: "number", value: 0 }, { name: "xuid", op: 14, type: [], value: null }, { name: "charset", op: 15, type: "offset", value: 0 }, { name: "encoding", op: 16, type: "offset", value: 0 }, { name: "charStrings", op: 17, type: "offset", value: 0 }, { name: "private", op: 18, type: ["number", "offset"], value: [0, 0] }, { name: "ros", op: 1230, type: ["SID", "SID", "number"] }, { name: "cidFontVersion", op: 1231, type: "number", value: 0 }, { name: "cidFontRevision", op: 1232, type: "number", value: 0 }, { name: "cidFontType", op: 1233, type: "number", value: 0 }, { name: "cidCount", op: 1234, type: "number", value: 8720 }, { name: "uidBase", op: 1235, type: "number" }, { name: "fdArray", op: 1236, type: "offset" }, { name: "fdSelect", op: 1237, type: "offset" }, { name: "fontName", op: 1238, type: "SID" }];
var A0 = [{ name: "subrs", op: 19, type: "offset", value: 0 }, { name: "defaultWidthX", op: 20, type: "number", value: 0 }, { name: "nominalWidthX", op: 21, type: "number", value: 0 }];
function O0(e, t) {
  var r2 = ou(e, 0, e.byteLength);
  return su(r2, _0, t);
}
function uu(e, t, r2, n) {
  var i = ou(e, t, r2);
  return su(i, A0, n);
}
function Rs(e, t, r2, n) {
  for (var i = [], a = 0; a < r2.length; a += 1) {
    var o = new DataView(new Uint8Array(r2[a]).buffer), u = O0(o, n);
    u._subrs = [], u._subrsBias = 0, u._defaultWidthX = 0, u._nominalWidthX = 0;
    var s = u.private[0], l = u.private[1];
    if (s !== 0 && l !== 0) {
      var f = uu(e, l + t, s, n);
      if (u._defaultWidthX = f.defaultWidthX, u._nominalWidthX = f.nominalWidthX, f.subrs !== 0) {
        var c = l + f.subrs, p2 = sr(e, c + t);
        u._subrs = p2.objects, u._subrsBias = na(u._subrs);
      }
      u._privateDict = f;
    }
    i.push(u);
  }
  return i;
}
function L0(e, t, r2, n) {
  var i, a, o = new se.Parser(e, t);
  r2 -= 1;
  var u = [".notdef"], s = o.parseCard8();
  if (s === 0)
    for (var l = 0; l < r2; l += 1)
      i = o.parseSID(), u.push(Gr(n, i));
  else if (s === 1)
    for (; u.length <= r2; ) {
      i = o.parseSID(), a = o.parseCard8();
      for (var f = 0; f <= a; f += 1)
        u.push(Gr(n, i)), i += 1;
    }
  else if (s === 2)
    for (; u.length <= r2; ) {
      i = o.parseSID(), a = o.parseCard16();
      for (var c = 0; c <= a; c += 1)
        u.push(Gr(n, i)), i += 1;
    }
  else
    throw new Error("Unknown charset format " + s);
  return u;
}
function I0(e, t, r2) {
  var n, i = {}, a = new se.Parser(e, t), o = a.parseCard8();
  if (o === 0)
    for (var u = a.parseCard8(), s = 0; s < u; s += 1)
      n = a.parseCard8(), i[n] = s;
  else if (o === 1) {
    var l = a.parseCard8();
    n = 1;
    for (var f = 0; f < l; f += 1)
      for (var c = a.parseCard8(), p2 = a.parseCard8(), d = c; d <= c + p2; d += 1)
        i[d] = n, n += 1;
  } else
    throw new Error("Unknown encoding format " + o);
  return new kn(i, r2);
}
function Us(e, t, r2) {
  var n, i, a, o, u = new ot(), s = [], l = 0, f = false, c = false, p2 = 0, d = 0, D, v, g, y;
  if (e.isCIDFont) {
    var b = e.tables.cff.topDict._fdSelect[t.index], C = e.tables.cff.topDict._fdArray[b];
    D = C._subrs, v = C._subrsBias, g = C._defaultWidthX, y = C._nominalWidthX;
  } else
    D = e.tables.cff.topDict._subrs, v = e.tables.cff.topDict._subrsBias, g = e.tables.cff.topDict._defaultWidthX, y = e.tables.cff.topDict._nominalWidthX;
  var k = g;
  function S(T, U) {
    c && u.closePath(), u.moveTo(T, U), c = true;
  }
  function E() {
    var T;
    T = s.length % 2 !== 0, T && !f && (k = s.shift() + y), l += s.length >> 1, s.length = 0, f = true;
  }
  function L(T) {
    for (var U, M, H, q, ee, A, R, O, Y, Z, te, ie, B = 0; B < T.length; ) {
      var z = T[B];
      switch (B += 1, z) {
        case 1:
          E();
          break;
        case 3:
          E();
          break;
        case 4:
          s.length > 1 && !f && (k = s.shift() + y, f = true), d += s.pop(), S(p2, d);
          break;
        case 5:
          for (; s.length > 0; )
            p2 += s.shift(), d += s.shift(), u.lineTo(p2, d);
          break;
        case 6:
          for (; s.length > 0 && (p2 += s.shift(), u.lineTo(p2, d), s.length !== 0); )
            d += s.shift(), u.lineTo(p2, d);
          break;
        case 7:
          for (; s.length > 0 && (d += s.shift(), u.lineTo(p2, d), s.length !== 0); )
            p2 += s.shift(), u.lineTo(p2, d);
          break;
        case 8:
          for (; s.length > 0; )
            n = p2 + s.shift(), i = d + s.shift(), a = n + s.shift(), o = i + s.shift(), p2 = a + s.shift(), d = o + s.shift(), u.curveTo(n, i, a, o, p2, d);
          break;
        case 10:
          ee = s.pop() + v, A = D[ee], A && L(A);
          break;
        case 11:
          return;
        case 12:
          switch (z = T[B], B += 1, z) {
            case 35:
              n = p2 + s.shift(), i = d + s.shift(), a = n + s.shift(), o = i + s.shift(), R = a + s.shift(), O = o + s.shift(), Y = R + s.shift(), Z = O + s.shift(), te = Y + s.shift(), ie = Z + s.shift(), p2 = te + s.shift(), d = ie + s.shift(), s.shift(), u.curveTo(n, i, a, o, R, O), u.curveTo(Y, Z, te, ie, p2, d);
              break;
            case 34:
              n = p2 + s.shift(), i = d, a = n + s.shift(), o = i + s.shift(), R = a + s.shift(), O = o, Y = R + s.shift(), Z = o, te = Y + s.shift(), ie = d, p2 = te + s.shift(), u.curveTo(n, i, a, o, R, O), u.curveTo(Y, Z, te, ie, p2, d);
              break;
            case 36:
              n = p2 + s.shift(), i = d + s.shift(), a = n + s.shift(), o = i + s.shift(), R = a + s.shift(), O = o, Y = R + s.shift(), Z = o, te = Y + s.shift(), ie = Z + s.shift(), p2 = te + s.shift(), u.curveTo(n, i, a, o, R, O), u.curveTo(Y, Z, te, ie, p2, d);
              break;
            case 37:
              n = p2 + s.shift(), i = d + s.shift(), a = n + s.shift(), o = i + s.shift(), R = a + s.shift(), O = o + s.shift(), Y = R + s.shift(), Z = O + s.shift(), te = Y + s.shift(), ie = Z + s.shift(), Math.abs(te - p2) > Math.abs(ie - d) ? p2 = te + s.shift() : d = ie + s.shift(), u.curveTo(n, i, a, o, R, O), u.curveTo(Y, Z, te, ie, p2, d);
              break;
            default:
              console.log("Glyph " + t.index + ": unknown operator 1200" + z), s.length = 0;
          }
          break;
        case 14:
          s.length > 0 && !f && (k = s.shift() + y, f = true), c && (u.closePath(), c = false);
          break;
        case 18:
          E();
          break;
        case 19:
        case 20:
          E(), B += l + 7 >> 3;
          break;
        case 21:
          s.length > 2 && !f && (k = s.shift() + y, f = true), d += s.pop(), p2 += s.pop(), S(p2, d);
          break;
        case 22:
          s.length > 1 && !f && (k = s.shift() + y, f = true), p2 += s.pop(), S(p2, d);
          break;
        case 23:
          E();
          break;
        case 24:
          for (; s.length > 2; )
            n = p2 + s.shift(), i = d + s.shift(), a = n + s.shift(), o = i + s.shift(), p2 = a + s.shift(), d = o + s.shift(), u.curveTo(n, i, a, o, p2, d);
          p2 += s.shift(), d += s.shift(), u.lineTo(p2, d);
          break;
        case 25:
          for (; s.length > 6; )
            p2 += s.shift(), d += s.shift(), u.lineTo(p2, d);
          n = p2 + s.shift(), i = d + s.shift(), a = n + s.shift(), o = i + s.shift(), p2 = a + s.shift(), d = o + s.shift(), u.curveTo(n, i, a, o, p2, d);
          break;
        case 26:
          for (s.length % 2 && (p2 += s.shift()); s.length > 0; )
            n = p2, i = d + s.shift(), a = n + s.shift(), o = i + s.shift(), p2 = a, d = o + s.shift(), u.curveTo(n, i, a, o, p2, d);
          break;
        case 27:
          for (s.length % 2 && (d += s.shift()); s.length > 0; )
            n = p2 + s.shift(), i = d, a = n + s.shift(), o = i + s.shift(), p2 = a + s.shift(), d = o, u.curveTo(n, i, a, o, p2, d);
          break;
        case 28:
          U = T[B], M = T[B + 1], s.push((U << 24 | M << 16) >> 16), B += 2;
          break;
        case 29:
          ee = s.pop() + e.gsubrsBias, A = e.gsubrs[ee], A && L(A);
          break;
        case 30:
          for (; s.length > 0 && (n = p2, i = d + s.shift(), a = n + s.shift(), o = i + s.shift(), p2 = a + s.shift(), d = o + (s.length === 1 ? s.shift() : 0), u.curveTo(n, i, a, o, p2, d), s.length !== 0); )
            n = p2 + s.shift(), i = d, a = n + s.shift(), o = i + s.shift(), d = o + s.shift(), p2 = a + (s.length === 1 ? s.shift() : 0), u.curveTo(n, i, a, o, p2, d);
          break;
        case 31:
          for (; s.length > 0 && (n = p2 + s.shift(), i = d, a = n + s.shift(), o = i + s.shift(), d = o + s.shift(), p2 = a + (s.length === 1 ? s.shift() : 0), u.curveTo(n, i, a, o, p2, d), s.length !== 0); )
            n = p2, i = d + s.shift(), a = n + s.shift(), o = i + s.shift(), p2 = a + s.shift(), d = o + (s.length === 1 ? s.shift() : 0), u.curveTo(n, i, a, o, p2, d);
          break;
        default:
          z < 32 ? console.log("Glyph " + t.index + ": unknown operator " + z) : z < 247 ? s.push(z - 139) : z < 251 ? (U = T[B], B += 1, s.push((z - 247) * 256 + U + 108)) : z < 255 ? (U = T[B], B += 1, s.push(-(z - 251) * 256 - U - 108)) : (U = T[B], M = T[B + 1], H = T[B + 2], q = T[B + 3], B += 4, s.push((U << 24 | M << 16 | H << 8 | q) / 65536));
      }
    }
  }
  return L(r2), t.advanceWidth = k, u;
}
function P0(e, t, r2, n) {
  var i = [], a, o = new se.Parser(e, t), u = o.parseCard8();
  if (u === 0)
    for (var s = 0; s < r2; s++) {
      if (a = o.parseCard8(), a >= n)
        throw new Error("CFF table CID Font FDSelect has bad FD index value " + a + " (FD count " + n + ")");
      i.push(a);
    }
  else if (u === 3) {
    var l = o.parseCard16(), f = o.parseCard16();
    if (f !== 0)
      throw new Error("CFF Table CID Font FDSelect format 3 range has bad initial GID " + f);
    for (var c, p2 = 0; p2 < l; p2++) {
      if (a = o.parseCard8(), c = o.parseCard16(), a >= n)
        throw new Error("CFF table CID Font FDSelect has bad FD index value " + a + " (FD count " + n + ")");
      if (c > r2)
        throw new Error("CFF Table CID Font FDSelect format 3 range has bad GID " + c);
      for (; f < c; f++)
        i.push(a);
      f = c;
    }
    if (c !== r2)
      throw new Error("CFF Table CID Font FDSelect format 3 range has bad final GID " + c);
  } else
    throw new Error("CFF Table CID Font FDSelect table has unsupported format " + u);
  return i;
}
function R0(e, t, r2, n) {
  r2.tables.cff = {};
  var i = T0(e, t), a = sr(e, i.endOffset, se.bytesToString), o = sr(e, a.endOffset), u = sr(e, o.endOffset, se.bytesToString), s = sr(e, u.endOffset);
  r2.gsubrs = s.objects, r2.gsubrsBias = na(r2.gsubrs);
  var l = Rs(e, t, o.objects, u.objects);
  if (l.length !== 1)
    throw new Error("CFF table has too many fonts in 'FontSet' - count of fonts NameIndex.length = " + l.length);
  var f = l[0];
  if (r2.tables.cff.topDict = f, f._privateDict && (r2.defaultWidthX = f._privateDict.defaultWidthX, r2.nominalWidthX = f._privateDict.nominalWidthX), f.ros[0] !== void 0 && f.ros[1] !== void 0 && (r2.isCIDFont = true), r2.isCIDFont) {
    var c = f.fdArray, p2 = f.fdSelect;
    if (c === 0 || p2 === 0)
      throw new Error("Font is marked as a CID font, but FDArray and/or FDSelect information is missing");
    c += t;
    var d = sr(e, c), D = Rs(e, t, d.objects, u.objects);
    f._fdArray = D, p2 += t, f._fdSelect = P0(e, p2, r2.numGlyphs, D.length);
  }
  var v = t + f.private[1], g = uu(e, v, f.private[0], u.objects);
  if (r2.defaultWidthX = g.defaultWidthX, r2.nominalWidthX = g.nominalWidthX, g.subrs !== 0) {
    var y = v + g.subrs, b = sr(e, y);
    r2.subrs = b.objects, r2.subrsBias = na(r2.subrs);
  } else
    r2.subrs = [], r2.subrsBias = 0;
  var C;
  n.lowMemory ? (C = E0(e, t + f.charStrings), r2.nGlyphs = C.offsets.length) : (C = sr(e, t + f.charStrings), r2.nGlyphs = C.objects.length);
  var k = L0(e, t + f.charset, r2.nGlyphs, u.objects);
  if (f.encoding === 0 ? r2.cffEncoding = new kn(Xp, k) : f.encoding === 1 ? r2.cffEncoding = new kn(qp, k) : r2.cffEncoding = I0(e, t + f.encoding, k), r2.encoding = r2.encoding || r2.cffEncoding, r2.glyphs = new $t.GlyphSet(r2), n.lowMemory)
    r2._push = function(L) {
      var T = F0(L, C.offsets, e, t + f.charStrings);
      r2.glyphs.push(L, $t.cffGlyphLoader(r2, L, Us, T));
    };
  else
    for (var S = 0; S < r2.nGlyphs; S += 1) {
      var E = C.objects[S];
      r2.glyphs.push(S, $t.cffGlyphLoader(r2, S, Us, E));
    }
}
var U0 = { parse: R0 };
function B0(e, t, r2) {
  var n = {}, i = new se.Parser(e, t);
  return n.tag = i.parseTag(), n.minValue = i.parseFixed(), n.defaultValue = i.parseFixed(), n.maxValue = i.parseFixed(), i.skip("uShort", 1), n.name = r2[i.parseUShort()] || {}, n;
}
function N0(e, t, r2, n) {
  var i = {}, a = new se.Parser(e, t);
  i.name = n[a.parseUShort()] || {}, a.skip("uShort", 1), i.coordinates = {};
  for (var o = 0; o < r2.length; ++o)
    i.coordinates[r2[o].tag] = a.parseFixed();
  return i;
}
function M0(e, t, r2) {
  var n = new se.Parser(e, t), i = n.parseULong();
  Te.argument(i === 65536, "Unsupported fvar table version.");
  var a = n.parseOffset16();
  n.skip("uShort", 1);
  for (var o = n.parseUShort(), u = n.parseUShort(), s = n.parseUShort(), l = n.parseUShort(), f = [], c = 0; c < o; c++)
    f.push(B0(e, t + a + c * u, r2));
  for (var p2 = [], d = t + a + o * u, D = 0; D < s; D++)
    p2.push(N0(e, d + D * l, f, r2));
  return { axes: f, instances: p2 };
}
var G0 = { parse: M0 };
var W0 = function() {
  return { coverage: this.parsePointer($.coverage), attachPoints: this.parseList($.pointer($.uShortList)) };
};
var $0 = function() {
  var e = this.parseUShort();
  if (Te.argument(e === 1 || e === 2 || e === 3, "Unsupported CaretValue table version."), e === 1)
    return { coordinate: this.parseShort() };
  if (e === 2)
    return { pointindex: this.parseShort() };
  if (e === 3)
    return { coordinate: this.parseShort() };
};
var j0 = function() {
  return this.parseList($.pointer($0));
};
var z0 = function() {
  return { coverage: this.parsePointer($.coverage), ligGlyphs: this.parseList($.pointer(j0)) };
};
var V0 = function() {
  return this.parseUShort(), this.parseList($.pointer($.coverage));
};
function H0(e, t) {
  t = t || 0;
  var r2 = new $(e, t), n = r2.parseVersion(1);
  Te.argument(n === 1 || n === 1.2 || n === 1.3, "Unsupported GDEF table version.");
  var i = { version: n, classDef: r2.parsePointer($.classDef), attachList: r2.parsePointer(W0), ligCaretList: r2.parsePointer(z0), markAttachClassDef: r2.parsePointer($.classDef) };
  return n >= 1.2 && (i.markGlyphSets = r2.parsePointer(V0)), i;
}
var X0 = { parse: H0 };
var _t = new Array(10);
_t[1] = function() {
  var t = this.offset + this.relativeOffset, r2 = this.parseUShort();
  if (r2 === 1)
    return { posFormat: 1, coverage: this.parsePointer($.coverage), value: this.parseValueRecord() };
  if (r2 === 2)
    return { posFormat: 2, coverage: this.parsePointer($.coverage), values: this.parseValueRecordList() };
  Te.assert(false, "0x" + t.toString(16) + ": GPOS lookup type 1 format must be 1 or 2.");
};
_t[2] = function() {
  var t = this.offset + this.relativeOffset, r2 = this.parseUShort();
  Te.assert(r2 === 1 || r2 === 2, "0x" + t.toString(16) + ": GPOS lookup type 2 format must be 1 or 2.");
  var n = this.parsePointer($.coverage), i = this.parseUShort(), a = this.parseUShort();
  if (r2 === 1)
    return { posFormat: r2, coverage: n, valueFormat1: i, valueFormat2: a, pairSets: this.parseList($.pointer($.list(function() {
      return { secondGlyph: this.parseUShort(), value1: this.parseValueRecord(i), value2: this.parseValueRecord(a) };
    }))) };
  if (r2 === 2) {
    var o = this.parsePointer($.classDef), u = this.parsePointer($.classDef), s = this.parseUShort(), l = this.parseUShort();
    return { posFormat: r2, coverage: n, valueFormat1: i, valueFormat2: a, classDef1: o, classDef2: u, class1Count: s, class2Count: l, classRecords: this.parseList(s, $.list(l, function() {
      return { value1: this.parseValueRecord(i), value2: this.parseValueRecord(a) };
    })) };
  }
};
_t[3] = function() {
  return { error: "GPOS Lookup 3 not supported" };
};
_t[4] = function() {
  return { error: "GPOS Lookup 4 not supported" };
};
_t[5] = function() {
  return { error: "GPOS Lookup 5 not supported" };
};
_t[6] = function() {
  return { error: "GPOS Lookup 6 not supported" };
};
_t[7] = function() {
  return { error: "GPOS Lookup 7 not supported" };
};
_t[8] = function() {
  return { error: "GPOS Lookup 8 not supported" };
};
_t[9] = function() {
  return { error: "GPOS Lookup 9 not supported" };
};
function q0(e, t) {
  t = t || 0;
  var r2 = new $(e, t), n = r2.parseVersion(1);
  return Te.argument(n === 1 || n === 1.1, "Unsupported GPOS table version " + n), n === 1 ? { version: n, scripts: r2.parseScriptList(), features: r2.parseFeatureList(), lookups: r2.parseLookupList(_t) } : { version: n, scripts: r2.parseScriptList(), features: r2.parseFeatureList(), lookups: r2.parseLookupList(_t), variations: r2.parseFeatureVariationsList() };
}
var Y0 = { parse: q0 };
var At = new Array(9);
At[1] = function() {
  var t = this.offset + this.relativeOffset, r2 = this.parseUShort();
  if (r2 === 1)
    return { substFormat: 1, coverage: this.parsePointer($.coverage), deltaGlyphId: this.parseUShort() };
  if (r2 === 2)
    return { substFormat: 2, coverage: this.parsePointer($.coverage), substitute: this.parseOffset16List() };
  Te.assert(false, "0x" + t.toString(16) + ": lookup type 1 format must be 1 or 2.");
};
At[2] = function() {
  var t = this.parseUShort();
  return Te.argument(t === 1, "GSUB Multiple Substitution Subtable identifier-format must be 1"), { substFormat: t, coverage: this.parsePointer($.coverage), sequences: this.parseListOfLists() };
};
At[3] = function() {
  var t = this.parseUShort();
  return Te.argument(t === 1, "GSUB Alternate Substitution Subtable identifier-format must be 1"), { substFormat: t, coverage: this.parsePointer($.coverage), alternateSets: this.parseListOfLists() };
};
At[4] = function() {
  var t = this.parseUShort();
  return Te.argument(t === 1, "GSUB ligature table identifier-format must be 1"), { substFormat: t, coverage: this.parsePointer($.coverage), ligatureSets: this.parseListOfLists(function() {
    return { ligGlyph: this.parseUShort(), components: this.parseUShortList(this.parseUShort() - 1) };
  }) };
};
var _r = { sequenceIndex: $.uShort, lookupListIndex: $.uShort };
At[5] = function() {
  var t = this.offset + this.relativeOffset, r2 = this.parseUShort();
  if (r2 === 1)
    return { substFormat: r2, coverage: this.parsePointer($.coverage), ruleSets: this.parseListOfLists(function() {
      var a = this.parseUShort(), o = this.parseUShort();
      return { input: this.parseUShortList(a - 1), lookupRecords: this.parseRecordList(o, _r) };
    }) };
  if (r2 === 2)
    return { substFormat: r2, coverage: this.parsePointer($.coverage), classDef: this.parsePointer($.classDef), classSets: this.parseListOfLists(function() {
      var a = this.parseUShort(), o = this.parseUShort();
      return { classes: this.parseUShortList(a - 1), lookupRecords: this.parseRecordList(o, _r) };
    }) };
  if (r2 === 3) {
    var n = this.parseUShort(), i = this.parseUShort();
    return { substFormat: r2, coverages: this.parseList(n, $.pointer($.coverage)), lookupRecords: this.parseRecordList(i, _r) };
  }
  Te.assert(false, "0x" + t.toString(16) + ": lookup type 5 format must be 1, 2 or 3.");
};
At[6] = function() {
  var t = this.offset + this.relativeOffset, r2 = this.parseUShort();
  if (r2 === 1)
    return { substFormat: 1, coverage: this.parsePointer($.coverage), chainRuleSets: this.parseListOfLists(function() {
      return { backtrack: this.parseUShortList(), input: this.parseUShortList(this.parseShort() - 1), lookahead: this.parseUShortList(), lookupRecords: this.parseRecordList(_r) };
    }) };
  if (r2 === 2)
    return { substFormat: 2, coverage: this.parsePointer($.coverage), backtrackClassDef: this.parsePointer($.classDef), inputClassDef: this.parsePointer($.classDef), lookaheadClassDef: this.parsePointer($.classDef), chainClassSet: this.parseListOfLists(function() {
      return { backtrack: this.parseUShortList(), input: this.parseUShortList(this.parseShort() - 1), lookahead: this.parseUShortList(), lookupRecords: this.parseRecordList(_r) };
    }) };
  if (r2 === 3)
    return { substFormat: 3, backtrackCoverage: this.parseList($.pointer($.coverage)), inputCoverage: this.parseList($.pointer($.coverage)), lookaheadCoverage: this.parseList($.pointer($.coverage)), lookupRecords: this.parseRecordList(_r) };
  Te.assert(false, "0x" + t.toString(16) + ": lookup type 6 format must be 1, 2 or 3.");
};
At[7] = function() {
  var t = this.parseUShort();
  Te.argument(t === 1, "GSUB Extension Substitution subtable identifier-format must be 1");
  var r2 = this.parseUShort(), n = new $(this.data, this.offset + this.parseULong());
  return { substFormat: 1, lookupType: r2, extension: At[r2].call(n) };
};
At[8] = function() {
  var t = this.parseUShort();
  return Te.argument(t === 1, "GSUB Reverse Chaining Contextual Single Substitution Subtable identifier-format must be 1"), { substFormat: t, coverage: this.parsePointer($.coverage), backtrackCoverage: this.parseList($.pointer($.coverage)), lookaheadCoverage: this.parseList($.pointer($.coverage)), substitutes: this.parseUShortList() };
};
function Z0(e, t) {
  t = t || 0;
  var r2 = new $(e, t), n = r2.parseVersion(1);
  return Te.argument(n === 1 || n === 1.1, "Unsupported GSUB table version."), n === 1 ? { version: n, scripts: r2.parseScriptList(), features: r2.parseFeatureList(), lookups: r2.parseLookupList(At) } : { version: n, scripts: r2.parseScriptList(), features: r2.parseFeatureList(), lookups: r2.parseLookupList(At), variations: r2.parseFeatureVariationsList() };
}
var J0 = { parse: Z0 };
function K0(e, t) {
  var r2 = {}, n = new se.Parser(e, t);
  return r2.version = n.parseVersion(), r2.fontRevision = Math.round(n.parseFixed() * 1e3) / 1e3, r2.checkSumAdjustment = n.parseULong(), r2.magicNumber = n.parseULong(), Te.argument(r2.magicNumber === 1594834165, "Font header has wrong magic number."), r2.flags = n.parseUShort(), r2.unitsPerEm = n.parseUShort(), r2.created = n.parseLongDateTime(), r2.modified = n.parseLongDateTime(), r2.xMin = n.parseShort(), r2.yMin = n.parseShort(), r2.xMax = n.parseShort(), r2.yMax = n.parseShort(), r2.macStyle = n.parseUShort(), r2.lowestRecPPEM = n.parseUShort(), r2.fontDirectionHint = n.parseShort(), r2.indexToLocFormat = n.parseShort(), r2.glyphDataFormat = n.parseShort(), r2;
}
var Q0 = { parse: K0 };
function ev(e, t) {
  var r2 = {}, n = new se.Parser(e, t);
  return r2.version = n.parseVersion(), r2.ascender = n.parseShort(), r2.descender = n.parseShort(), r2.lineGap = n.parseShort(), r2.advanceWidthMax = n.parseUShort(), r2.minLeftSideBearing = n.parseShort(), r2.minRightSideBearing = n.parseShort(), r2.xMaxExtent = n.parseShort(), r2.caretSlopeRise = n.parseShort(), r2.caretSlopeRun = n.parseShort(), r2.caretOffset = n.parseShort(), n.relativeOffset += 8, r2.metricDataFormat = n.parseShort(), r2.numberOfHMetrics = n.parseUShort(), r2;
}
var tv = { parse: ev };
function rv(e, t, r2, n, i) {
  for (var a, o, u = new se.Parser(e, t), s = 0; s < n; s += 1) {
    s < r2 && (a = u.parseUShort(), o = u.parseShort());
    var l = i.get(s);
    l.advanceWidth = a, l.leftSideBearing = o;
  }
}
function nv(e, t, r2, n, i) {
  e._hmtxTableData = {};
  for (var a, o, u = new se.Parser(t, r2), s = 0; s < i; s += 1)
    s < n && (a = u.parseUShort(), o = u.parseShort()), e._hmtxTableData[s] = { advanceWidth: a, leftSideBearing: o };
}
function iv(e, t, r2, n, i, a, o) {
  o.lowMemory ? nv(e, t, r2, n, i) : rv(t, r2, n, i, a);
}
var av = { parse: iv };
function ov(e) {
  var t = {};
  e.skip("uShort");
  var r2 = e.parseUShort();
  Te.argument(r2 === 0, "Unsupported kern sub-table version."), e.skip("uShort", 2);
  var n = e.parseUShort();
  e.skip("uShort", 3);
  for (var i = 0; i < n; i += 1) {
    var a = e.parseUShort(), o = e.parseUShort(), u = e.parseShort();
    t[a + "," + o] = u;
  }
  return t;
}
function sv(e) {
  var t = {};
  e.skip("uShort");
  var r2 = e.parseULong();
  r2 > 1 && console.warn("Only the first kern subtable is supported."), e.skip("uLong");
  var n = e.parseUShort(), i = n & 255;
  if (e.skip("uShort"), i === 0) {
    var a = e.parseUShort();
    e.skip("uShort", 3);
    for (var o = 0; o < a; o += 1) {
      var u = e.parseUShort(), s = e.parseUShort(), l = e.parseShort();
      t[u + "," + s] = l;
    }
  }
  return t;
}
function uv(e, t) {
  var r2 = new se.Parser(e, t), n = r2.parseUShort();
  if (n === 0)
    return ov(r2);
  if (n === 1)
    return sv(r2);
  throw new Error("Unsupported kern table version (" + n + ").");
}
var lv = { parse: uv };
function fv(e, t) {
  var r2 = new se.Parser(e, t), n = r2.parseULong();
  Te.argument(n === 1, "Unsupported ltag table version."), r2.skip("uLong", 1);
  for (var i = r2.parseULong(), a = [], o = 0; o < i; o++) {
    for (var u = "", s = t + r2.parseUShort(), l = r2.parseUShort(), f = s; f < s + l; ++f)
      u += String.fromCharCode(e.getInt8(f));
    a.push(u);
  }
  return a;
}
var cv = { parse: fv };
function pv(e, t, r2, n) {
  for (var i = new se.Parser(e, t), a = n ? i.parseUShort : i.parseULong, o = [], u = 0; u < r2 + 1; u += 1) {
    var s = a.call(i);
    n && (s *= 2), o.push(s);
  }
  return o;
}
var hv = { parse: pv };
function dv(e, t) {
  var r2 = {}, n = new se.Parser(e, t);
  return r2.version = n.parseVersion(), r2.numGlyphs = n.parseUShort(), r2.version === 1 && (r2.maxPoints = n.parseUShort(), r2.maxContours = n.parseUShort(), r2.maxCompositePoints = n.parseUShort(), r2.maxCompositeContours = n.parseUShort(), r2.maxZones = n.parseUShort(), r2.maxTwilightPoints = n.parseUShort(), r2.maxStorage = n.parseUShort(), r2.maxFunctionDefs = n.parseUShort(), r2.maxInstructionDefs = n.parseUShort(), r2.maxStackElements = n.parseUShort(), r2.maxSizeOfInstructions = n.parseUShort(), r2.maxComponentElements = n.parseUShort(), r2.maxComponentDepth = n.parseUShort()), r2;
}
var vv = { parse: dv };
function gv(e, t) {
  var r2 = {}, n = new se.Parser(e, t);
  r2.version = n.parseUShort(), r2.xAvgCharWidth = n.parseShort(), r2.usWeightClass = n.parseUShort(), r2.usWidthClass = n.parseUShort(), r2.fsType = n.parseUShort(), r2.ySubscriptXSize = n.parseShort(), r2.ySubscriptYSize = n.parseShort(), r2.ySubscriptXOffset = n.parseShort(), r2.ySubscriptYOffset = n.parseShort(), r2.ySuperscriptXSize = n.parseShort(), r2.ySuperscriptYSize = n.parseShort(), r2.ySuperscriptXOffset = n.parseShort(), r2.ySuperscriptYOffset = n.parseShort(), r2.yStrikeoutSize = n.parseShort(), r2.yStrikeoutPosition = n.parseShort(), r2.sFamilyClass = n.parseShort(), r2.panose = [];
  for (var i = 0; i < 10; i++)
    r2.panose[i] = n.parseByte();
  return r2.ulUnicodeRange1 = n.parseULong(), r2.ulUnicodeRange2 = n.parseULong(), r2.ulUnicodeRange3 = n.parseULong(), r2.ulUnicodeRange4 = n.parseULong(), r2.achVendID = String.fromCharCode(n.parseByte(), n.parseByte(), n.parseByte(), n.parseByte()), r2.fsSelection = n.parseUShort(), r2.usFirstCharIndex = n.parseUShort(), r2.usLastCharIndex = n.parseUShort(), r2.sTypoAscender = n.parseShort(), r2.sTypoDescender = n.parseShort(), r2.sTypoLineGap = n.parseShort(), r2.usWinAscent = n.parseUShort(), r2.usWinDescent = n.parseUShort(), r2.version >= 1 && (r2.ulCodePageRange1 = n.parseULong(), r2.ulCodePageRange2 = n.parseULong()), r2.version >= 2 && (r2.sxHeight = n.parseShort(), r2.sCapHeight = n.parseShort(), r2.usDefaultChar = n.parseUShort(), r2.usBreakChar = n.parseUShort(), r2.usMaxContent = n.parseUShort()), r2;
}
var mv = { parse: gv };
function Dv(e, t) {
  var r2 = {}, n = new se.Parser(e, t);
  switch (r2.version = n.parseVersion(), r2.italicAngle = n.parseFixed(), r2.underlinePosition = n.parseShort(), r2.underlineThickness = n.parseShort(), r2.isFixedPitch = n.parseULong(), r2.minMemType42 = n.parseULong(), r2.maxMemType42 = n.parseULong(), r2.minMemType1 = n.parseULong(), r2.maxMemType1 = n.parseULong(), r2.names = [], r2.version) {
    case 1:
      break;
    case 2:
      r2.numberOfGlyphs = n.parseUShort(), r2.glyphNameIndex = new Array(r2.numberOfGlyphs);
      for (var i = 0; i < r2.numberOfGlyphs; i++)
        r2.glyphNameIndex[i] = n.parseUShort();
      break;
    case 2.5:
      r2.numberOfGlyphs = n.parseUShort(), r2.offset = new Array(r2.numberOfGlyphs);
      for (var a = 0; a < r2.numberOfGlyphs; a++)
        r2.offset[a] = n.parseChar();
      break;
  }
  return r2;
}
var yv = { parse: Dv };
var On = {};
On.UTF8 = function(e, t, r2) {
  for (var n = [], i = r2, a = 0; a < i; a++, t += 1)
    n[a] = e.getUint8(t);
  return String.fromCharCode.apply(null, n);
};
On.UTF16 = function(e, t, r2) {
  for (var n = [], i = r2 / 2, a = 0; a < i; a++, t += 2)
    n[a] = e.getUint16(t);
  return String.fromCharCode.apply(null, n);
};
var bv = { "x-mac-croatian": "\xC4\xC5\xC7\xC9\xD1\xD6\xDC\xE1\xE0\xE2\xE4\xE3\xE5\xE7\xE9\xE8\xEA\xEB\xED\xEC\xEE\xEF\xF1\xF3\xF2\xF4\xF6\xF5\xFA\xF9\xFB\xFC\u2020\xB0\xA2\xA3\xA7\u2022\xB6\xDF\xAE\u0160\u2122\xB4\xA8\u2260\u017D\xD8\u221E\xB1\u2264\u2265\u2206\xB5\u2202\u2211\u220F\u0161\u222B\xAA\xBA\u03A9\u017E\xF8\xBF\xA1\xAC\u221A\u0192\u2248\u0106\xAB\u010C\u2026\xA0\xC0\xC3\xD5\u0152\u0153\u0110\u2014\u201C\u201D\u2018\u2019\xF7\u25CA\uF8FF\xA9\u2044\u20AC\u2039\u203A\xC6\xBB\u2013\xB7\u201A\u201E\u2030\xC2\u0107\xC1\u010D\xC8\xCD\xCE\xCF\xCC\xD3\xD4\u0111\xD2\xDA\xDB\xD9\u0131\u02C6\u02DC\xAF\u03C0\xCB\u02DA\xB8\xCA\xE6\u02C7", "x-mac-cyrillic": "\u0410\u0411\u0412\u0413\u0414\u0415\u0416\u0417\u0418\u0419\u041A\u041B\u041C\u041D\u041E\u041F\u0420\u0421\u0422\u0423\u0424\u0425\u0426\u0427\u0428\u0429\u042A\u042B\u042C\u042D\u042E\u042F\u2020\xB0\u0490\xA3\xA7\u2022\xB6\u0406\xAE\xA9\u2122\u0402\u0452\u2260\u0403\u0453\u221E\xB1\u2264\u2265\u0456\xB5\u0491\u0408\u0404\u0454\u0407\u0457\u0409\u0459\u040A\u045A\u0458\u0405\xAC\u221A\u0192\u2248\u2206\xAB\xBB\u2026\xA0\u040B\u045B\u040C\u045C\u0455\u2013\u2014\u201C\u201D\u2018\u2019\xF7\u201E\u040E\u045E\u040F\u045F\u2116\u0401\u0451\u044F\u0430\u0431\u0432\u0433\u0434\u0435\u0436\u0437\u0438\u0439\u043A\u043B\u043C\u043D\u043E\u043F\u0440\u0441\u0442\u0443\u0444\u0445\u0446\u0447\u0448\u0449\u044A\u044B\u044C\u044D\u044E", "x-mac-gaelic": "\xC4\xC5\xC7\xC9\xD1\xD6\xDC\xE1\xE0\xE2\xE4\xE3\xE5\xE7\xE9\xE8\xEA\xEB\xED\xEC\xEE\xEF\xF1\xF3\xF2\xF4\xF6\xF5\xFA\xF9\xFB\xFC\u2020\xB0\xA2\xA3\xA7\u2022\xB6\xDF\xAE\xA9\u2122\xB4\xA8\u2260\xC6\xD8\u1E02\xB1\u2264\u2265\u1E03\u010A\u010B\u1E0A\u1E0B\u1E1E\u1E1F\u0120\u0121\u1E40\xE6\xF8\u1E41\u1E56\u1E57\u027C\u0192\u017F\u1E60\xAB\xBB\u2026\xA0\xC0\xC3\xD5\u0152\u0153\u2013\u2014\u201C\u201D\u2018\u2019\u1E61\u1E9B\xFF\u0178\u1E6A\u20AC\u2039\u203A\u0176\u0177\u1E6B\xB7\u1EF2\u1EF3\u204A\xC2\xCA\xC1\xCB\xC8\xCD\xCE\xCF\xCC\xD3\xD4\u2663\xD2\xDA\xDB\xD9\u0131\xDD\xFD\u0174\u0175\u1E84\u1E85\u1E80\u1E81\u1E82\u1E83", "x-mac-greek": "\xC4\xB9\xB2\xC9\xB3\xD6\xDC\u0385\xE0\xE2\xE4\u0384\xA8\xE7\xE9\xE8\xEA\xEB\xA3\u2122\xEE\xEF\u2022\xBD\u2030\xF4\xF6\xA6\u20AC\xF9\xFB\xFC\u2020\u0393\u0394\u0398\u039B\u039E\u03A0\xDF\xAE\xA9\u03A3\u03AA\xA7\u2260\xB0\xB7\u0391\xB1\u2264\u2265\xA5\u0392\u0395\u0396\u0397\u0399\u039A\u039C\u03A6\u03AB\u03A8\u03A9\u03AC\u039D\xAC\u039F\u03A1\u2248\u03A4\xAB\xBB\u2026\xA0\u03A5\u03A7\u0386\u0388\u0153\u2013\u2015\u201C\u201D\u2018\u2019\xF7\u0389\u038A\u038C\u038E\u03AD\u03AE\u03AF\u03CC\u038F\u03CD\u03B1\u03B2\u03C8\u03B4\u03B5\u03C6\u03B3\u03B7\u03B9\u03BE\u03BA\u03BB\u03BC\u03BD\u03BF\u03C0\u03CE\u03C1\u03C3\u03C4\u03B8\u03C9\u03C2\u03C7\u03C5\u03B6\u03CA\u03CB\u0390\u03B0\xAD", "x-mac-icelandic": "\xC4\xC5\xC7\xC9\xD1\xD6\xDC\xE1\xE0\xE2\xE4\xE3\xE5\xE7\xE9\xE8\xEA\xEB\xED\xEC\xEE\xEF\xF1\xF3\xF2\xF4\xF6\xF5\xFA\xF9\xFB\xFC\xDD\xB0\xA2\xA3\xA7\u2022\xB6\xDF\xAE\xA9\u2122\xB4\xA8\u2260\xC6\xD8\u221E\xB1\u2264\u2265\xA5\xB5\u2202\u2211\u220F\u03C0\u222B\xAA\xBA\u03A9\xE6\xF8\xBF\xA1\xAC\u221A\u0192\u2248\u2206\xAB\xBB\u2026\xA0\xC0\xC3\xD5\u0152\u0153\u2013\u2014\u201C\u201D\u2018\u2019\xF7\u25CA\xFF\u0178\u2044\u20AC\xD0\xF0\xDE\xFE\xFD\xB7\u201A\u201E\u2030\xC2\xCA\xC1\xCB\xC8\xCD\xCE\xCF\xCC\xD3\xD4\uF8FF\xD2\xDA\xDB\xD9\u0131\u02C6\u02DC\xAF\u02D8\u02D9\u02DA\xB8\u02DD\u02DB\u02C7", "x-mac-inuit": "\u1403\u1404\u1405\u1406\u140A\u140B\u1431\u1432\u1433\u1434\u1438\u1439\u1449\u144E\u144F\u1450\u1451\u1455\u1456\u1466\u146D\u146E\u146F\u1470\u1472\u1473\u1483\u148B\u148C\u148D\u148E\u1490\u1491\xB0\u14A1\u14A5\u14A6\u2022\xB6\u14A7\xAE\xA9\u2122\u14A8\u14AA\u14AB\u14BB\u14C2\u14C3\u14C4\u14C5\u14C7\u14C8\u14D0\u14EF\u14F0\u14F1\u14F2\u14F4\u14F5\u1505\u14D5\u14D6\u14D7\u14D8\u14DA\u14DB\u14EA\u1528\u1529\u152A\u152B\u152D\u2026\xA0\u152E\u153E\u1555\u1556\u1557\u2013\u2014\u201C\u201D\u2018\u2019\u1558\u1559\u155A\u155D\u1546\u1547\u1548\u1549\u154B\u154C\u1550\u157F\u1580\u1581\u1582\u1583\u1584\u1585\u158F\u1590\u1591\u1592\u1593\u1594\u1595\u1671\u1672\u1673\u1674\u1675\u1676\u1596\u15A0\u15A1\u15A2\u15A3\u15A4\u15A5\u15A6\u157C\u0141\u0142", "x-mac-ce": "\xC4\u0100\u0101\xC9\u0104\xD6\xDC\xE1\u0105\u010C\xE4\u010D\u0106\u0107\xE9\u0179\u017A\u010E\xED\u010F\u0112\u0113\u0116\xF3\u0117\xF4\xF6\xF5\xFA\u011A\u011B\xFC\u2020\xB0\u0118\xA3\xA7\u2022\xB6\xDF\xAE\xA9\u2122\u0119\xA8\u2260\u0123\u012E\u012F\u012A\u2264\u2265\u012B\u0136\u2202\u2211\u0142\u013B\u013C\u013D\u013E\u0139\u013A\u0145\u0146\u0143\xAC\u221A\u0144\u0147\u2206\xAB\xBB\u2026\xA0\u0148\u0150\xD5\u0151\u014C\u2013\u2014\u201C\u201D\u2018\u2019\xF7\u25CA\u014D\u0154\u0155\u0158\u2039\u203A\u0159\u0156\u0157\u0160\u201A\u201E\u0161\u015A\u015B\xC1\u0164\u0165\xCD\u017D\u017E\u016A\xD3\xD4\u016B\u016E\xDA\u016F\u0170\u0171\u0172\u0173\xDD\xFD\u0137\u017B\u0141\u017C\u0122\u02C7", macintosh: "\xC4\xC5\xC7\xC9\xD1\xD6\xDC\xE1\xE0\xE2\xE4\xE3\xE5\xE7\xE9\xE8\xEA\xEB\xED\xEC\xEE\xEF\xF1\xF3\xF2\xF4\xF6\xF5\xFA\xF9\xFB\xFC\u2020\xB0\xA2\xA3\xA7\u2022\xB6\xDF\xAE\xA9\u2122\xB4\xA8\u2260\xC6\xD8\u221E\xB1\u2264\u2265\xA5\xB5\u2202\u2211\u220F\u03C0\u222B\xAA\xBA\u03A9\xE6\xF8\xBF\xA1\xAC\u221A\u0192\u2248\u2206\xAB\xBB\u2026\xA0\xC0\xC3\xD5\u0152\u0153\u2013\u2014\u201C\u201D\u2018\u2019\xF7\u25CA\xFF\u0178\u2044\u20AC\u2039\u203A\uFB01\uFB02\u2021\xB7\u201A\u201E\u2030\xC2\xCA\xC1\xCB\xC8\xCD\xCE\xCF\xCC\xD3\xD4\uF8FF\xD2\xDA\xDB\xD9\u0131\u02C6\u02DC\xAF\u02D8\u02D9\u02DA\xB8\u02DD\u02DB\u02C7", "x-mac-romanian": "\xC4\xC5\xC7\xC9\xD1\xD6\xDC\xE1\xE0\xE2\xE4\xE3\xE5\xE7\xE9\xE8\xEA\xEB\xED\xEC\xEE\xEF\xF1\xF3\xF2\xF4\xF6\xF5\xFA\xF9\xFB\xFC\u2020\xB0\xA2\xA3\xA7\u2022\xB6\xDF\xAE\xA9\u2122\xB4\xA8\u2260\u0102\u0218\u221E\xB1\u2264\u2265\xA5\xB5\u2202\u2211\u220F\u03C0\u222B\xAA\xBA\u03A9\u0103\u0219\xBF\xA1\xAC\u221A\u0192\u2248\u2206\xAB\xBB\u2026\xA0\xC0\xC3\xD5\u0152\u0153\u2013\u2014\u201C\u201D\u2018\u2019\xF7\u25CA\xFF\u0178\u2044\u20AC\u2039\u203A\u021A\u021B\u2021\xB7\u201A\u201E\u2030\xC2\xCA\xC1\xCB\xC8\xCD\xCE\xCF\xCC\xD3\xD4\uF8FF\xD2\xDA\xDB\xD9\u0131\u02C6\u02DC\xAF\u02D8\u02D9\u02DA\xB8\u02DD\u02DB\u02C7", "x-mac-turkish": "\xC4\xC5\xC7\xC9\xD1\xD6\xDC\xE1\xE0\xE2\xE4\xE3\xE5\xE7\xE9\xE8\xEA\xEB\xED\xEC\xEE\xEF\xF1\xF3\xF2\xF4\xF6\xF5\xFA\xF9\xFB\xFC\u2020\xB0\xA2\xA3\xA7\u2022\xB6\xDF\xAE\xA9\u2122\xB4\xA8\u2260\xC6\xD8\u221E\xB1\u2264\u2265\xA5\xB5\u2202\u2211\u220F\u03C0\u222B\xAA\xBA\u03A9\xE6\xF8\xBF\xA1\xAC\u221A\u0192\u2248\u2206\xAB\xBB\u2026\xA0\xC0\xC3\xD5\u0152\u0153\u2013\u2014\u201C\u201D\u2018\u2019\xF7\u25CA\xFF\u0178\u011E\u011F\u0130\u0131\u015E\u015F\u2021\xB7\u201A\u201E\u2030\xC2\xCA\xC1\xCB\xC8\xCD\xCE\xCF\xCC\xD3\xD4\uF8FF\xD2\xDA\xDB\xD9\uF8A0\u02C6\u02DC\xAF\u02D8\u02D9\u02DA\xB8\u02DD\u02DB\u02C7" };
On.MACSTRING = function(e, t, r2, n) {
  var i = bv[n];
  if (i !== void 0) {
    for (var a = "", o = 0; o < r2; o++) {
      var u = e.getUint8(t + o);
      u <= 127 ? a += String.fromCharCode(u) : a += i[u & 127];
    }
    return a;
  }
};
function xv(e, t) {
  var r2 = new se.Parser(e, t), n = r2.parseULong();
  Te.argument(n === 1, "Unsupported META table version."), r2.parseULong(), r2.parseULong();
  for (var i = r2.parseULong(), a = {}, o = 0; o < i; o++) {
    var u = r2.parseTag(), s = r2.parseULong(), l = r2.parseULong(), f = On.UTF8(e, t + s, l);
    a[u] = f;
  }
  return a;
}
var wv = { parse: xv };
function Bs(e, t) {
  for (var r2 = [], n = 12, i = 0; i < t; i += 1) {
    var a = se.getTag(e, n), o = se.getULong(e, n + 4), u = se.getULong(e, n + 8), s = se.getULong(e, n + 12);
    r2.push({ tag: a, checksum: o, offset: u, length: s, compression: false }), n += 16;
  }
  return r2;
}
function Ev(e, t) {
  for (var r2 = [], n = 44, i = 0; i < t; i += 1) {
    var a = se.getTag(e, n), o = se.getULong(e, n + 4), u = se.getULong(e, n + 8), s = se.getULong(e, n + 12), l = void 0;
    u < s ? l = "WOFF" : l = false, r2.push({ tag: a, offset: o, compression: l, compressedLength: u, length: s }), n += 20;
  }
  return r2;
}
function je(e, t) {
  if (t.compression === "WOFF") {
    var r2 = new Uint8Array(e.buffer, t.offset + 2, t.compressedLength - 2), n = new Uint8Array(t.length);
    if (jp(r2, n), n.byteLength !== t.length)
      throw new Error("Decompression error: " + t.tag + " decompressed length doesn't match recorded length");
    var i = new DataView(n.buffer, 0);
    return { data: i, offset: 0 };
  } else
    return { data: e, offset: t.offset };
}
function Fv(e, t) {
  t = t ?? {};
  var r2, n = new st({ empty: true }), i = new DataView(e, 0), a, o = [], u = se.getTag(i, 0);
  if (u === "\0\0\0" || u === "true" || u === "typ1")
    n.outlinesFormat = "truetype", a = se.getUShort(i, 4), o = Bs(i, a);
  else if (u === "OTTO")
    n.outlinesFormat = "cff", a = se.getUShort(i, 4), o = Bs(i, a);
  else if (u === "wOFF") {
    var s = se.getTag(i, 4);
    if (s === "\0\0\0")
      n.outlinesFormat = "truetype";
    else if (s === "OTTO")
      n.outlinesFormat = "cff";
    else
      throw new Error("Unsupported OpenType flavor " + u);
    a = se.getUShort(i, 12), o = Ev(i, a);
  } else
    throw new Error("Unsupported OpenType signature " + u);
  for (var l, f, c, p2, d, D, v, g, y, b, C, k = 0; k < a; k += 1) {
    var S = o[k], E = void 0;
    switch (S.tag) {
      case "cmap":
        E = je(i, S), n.tables.cmap = w0.parse(E.data, E.offset), n.encoding = new Hs(n.tables.cmap);
        break;
      case "cvt ":
        E = je(i, S), C = new se.Parser(E.data, E.offset), n.tables.cvt = C.parseShortList(S.length / 2);
        break;
      case "fvar":
        f = S;
        break;
      case "fpgm":
        E = je(i, S), C = new se.Parser(E.data, E.offset), n.tables.fpgm = C.parseByteList(S.length);
        break;
      case "head":
        E = je(i, S), n.tables.head = Q0.parse(E.data, E.offset), n.unitsPerEm = n.tables.head.unitsPerEm, r2 = n.tables.head.indexToLocFormat;
        break;
      case "hhea":
        E = je(i, S), n.tables.hhea = tv.parse(E.data, E.offset), n.ascender = n.tables.hhea.ascender, n.descender = n.tables.hhea.descender, n.numberOfHMetrics = n.tables.hhea.numberOfHMetrics;
        break;
      case "hmtx":
        v = S;
        break;
      case "ltag":
        E = je(i, S), ltagTable = cv.parse(E.data, E.offset);
        break;
      case "maxp":
        E = je(i, S), n.tables.maxp = vv.parse(E.data, E.offset), n.numGlyphs = n.tables.maxp.numGlyphs;
        break;
      case "OS/2":
        E = je(i, S), n.tables.os2 = mv.parse(E.data, E.offset);
        break;
      case "post":
        E = je(i, S), n.tables.post = yv.parse(E.data, E.offset);
        break;
      case "prep":
        E = je(i, S), C = new se.Parser(E.data, E.offset), n.tables.prep = C.parseByteList(S.length);
        break;
      case "glyf":
        c = S;
        break;
      case "loca":
        y = S;
        break;
      case "CFF ":
        l = S;
        break;
      case "kern":
        g = S;
        break;
      case "GDEF":
        p2 = S;
        break;
      case "GPOS":
        d = S;
        break;
      case "GSUB":
        D = S;
        break;
      case "meta":
        b = S;
        break;
    }
  }
  if (c && y) {
    var L = r2 === 0, T = je(i, y), U = hv.parse(T.data, T.offset, n.numGlyphs, L), M = je(i, c);
    n.glyphs = Ks.parse(M.data, M.offset, U, n, t);
  } else if (l) {
    var H = je(i, l);
    U0.parse(H.data, H.offset, n, t);
  } else
    throw new Error("Font doesn't contain TrueType or CFF outlines.");
  var q = je(i, v);
  if (av.parse(n, q.data, q.offset, n.numberOfHMetrics, n.numGlyphs, n.glyphs, t), Jp(n, t), g) {
    var ee = je(i, g);
    n.kerningPairs = lv.parse(ee.data, ee.offset);
  } else
    n.kerningPairs = {};
  if (p2) {
    var A = je(i, p2);
    n.tables.gdef = X0.parse(A.data, A.offset);
  }
  if (d) {
    var R = je(i, d);
    n.tables.gpos = Y0.parse(R.data, R.offset), n.position.init();
  }
  if (D) {
    var O = je(i, D);
    n.tables.gsub = J0.parse(O.data, O.offset);
  }
  if (f) {
    var Y = je(i, f);
    n.tables.fvar = G0.parse(Y.data, Y.offset, n.names);
  }
  if (b) {
    var Z = je(i, b);
    n.tables.meta = wv.parse(Z.data, Z.offset), n.metas = n.tables.meta;
  }
  return n;
}
function Cv() {
}
function Sv() {
}
var kv = Object.freeze({ __proto__: null, Font: st, Glyph: Jt, Path: ot, _parse: se, parse: Fv, load: Cv, loadSync: Sv });
var Ln = kv;
var Tv = Object.create;
var Yn = Object.defineProperty;
var _v = Object.getOwnPropertyDescriptor;
var Av = Object.getOwnPropertyNames;
var Ov = Object.getPrototypeOf;
var Lv = Object.prototype.hasOwnProperty;
var _a = (e, t) => () => (e && (t = e(e = 0)), t);
var le = (e, t) => () => (t || e((t = { exports: {} }).exports, t), t.exports);
var Aa = (e, t) => {
  for (var r2 in t)
    Yn(e, r2, { get: t[r2], enumerable: true });
};
var Bu = (e, t, r2, n) => {
  if (t && typeof t == "object" || typeof t == "function")
    for (let i of Av(t))
      !Lv.call(e, i) && i !== r2 && Yn(e, i, { get: () => t[i], enumerable: !(n = _v(t, i)) || n.enumerable });
  return e;
};
var Iv = (e, t, r2) => (r2 = e != null ? Tv(Ov(e)) : {}, Bu(t || !e || !e.__esModule ? Yn(r2, "default", { value: e, enumerable: true }) : r2, e));
var Xn = (e) => Bu(Yn({}, "__esModule", { value: true }), e);
var Nu = {};
Aa(Nu, { getYogaModule: () => Pv });
async function Pv() {
  return {};
}
var Rv = _a(() => {
});
var Mu = le((e) => {
  "use strict";
  Object.defineProperty(e, "__esModule", { value: true }), Object.defineProperty(e, "default", { enumerable: true, get: () => t });
  function t(r2) {
    if (r2 = `${r2}`, r2 === "0")
      return "0";
    if (/^[+-]?(\d+|\d*\.\d+)(e[+-]?\d+)?(%|\w+)?$/.test(r2))
      return r2.replace(/^[+-]?/, (n) => n === "-" ? "" : "-");
    if (r2.includes("var(") || r2.includes("calc("))
      return `calc(${r2} * -1)`;
  }
});
var Uv = le((e) => {
  "use strict";
  Object.defineProperty(e, "__esModule", { value: true }), Object.defineProperty(e, "default", { enumerable: true, get: () => t });
  var t = ["preflight", "container", "accessibility", "pointerEvents", "visibility", "position", "inset", "isolation", "zIndex", "order", "gridColumn", "gridColumnStart", "gridColumnEnd", "gridRow", "gridRowStart", "gridRowEnd", "float", "clear", "margin", "boxSizing", "display", "aspectRatio", "height", "maxHeight", "minHeight", "width", "minWidth", "maxWidth", "flex", "flexShrink", "flexGrow", "flexBasis", "tableLayout", "borderCollapse", "borderSpacing", "transformOrigin", "translate", "rotate", "skew", "scale", "transform", "animation", "cursor", "touchAction", "userSelect", "resize", "scrollSnapType", "scrollSnapAlign", "scrollSnapStop", "scrollMargin", "scrollPadding", "listStylePosition", "listStyleType", "appearance", "columns", "breakBefore", "breakInside", "breakAfter", "gridAutoColumns", "gridAutoFlow", "gridAutoRows", "gridTemplateColumns", "gridTemplateRows", "flexDirection", "flexWrap", "placeContent", "placeItems", "alignContent", "alignItems", "justifyContent", "justifyItems", "gap", "space", "divideWidth", "divideStyle", "divideColor", "divideOpacity", "placeSelf", "alignSelf", "justifySelf", "overflow", "overscrollBehavior", "scrollBehavior", "textOverflow", "whitespace", "wordBreak", "borderRadius", "borderWidth", "borderStyle", "borderColor", "borderOpacity", "backgroundColor", "backgroundOpacity", "backgroundImage", "gradientColorStops", "boxDecorationBreak", "backgroundSize", "backgroundAttachment", "backgroundClip", "backgroundPosition", "backgroundRepeat", "backgroundOrigin", "fill", "stroke", "strokeWidth", "objectFit", "objectPosition", "padding", "textAlign", "textIndent", "verticalAlign", "fontFamily", "fontSize", "fontWeight", "textTransform", "fontStyle", "fontVariantNumeric", "lineHeight", "letterSpacing", "textColor", "textOpacity", "textDecoration", "textDecorationColor", "textDecorationStyle", "textDecorationThickness", "textUnderlineOffset", "fontSmoothing", "placeholderColor", "placeholderOpacity", "caretColor", "accentColor", "opacity", "backgroundBlendMode", "mixBlendMode", "boxShadow", "boxShadowColor", "outlineStyle", "outlineWidth", "outlineOffset", "outlineColor", "ringWidth", "ringColor", "ringOpacity", "ringOffsetWidth", "ringOffsetColor", "blur", "brightness", "contrast", "dropShadow", "grayscale", "hueRotate", "invert", "saturate", "sepia", "filter", "backdropBlur", "backdropBrightness", "backdropContrast", "backdropGrayscale", "backdropHueRotate", "backdropInvert", "backdropOpacity", "backdropSaturate", "backdropSepia", "backdropFilter", "transitionProperty", "transitionDelay", "transitionDuration", "transitionTimingFunction", "willChange", "content"];
});
var Bv = le((e) => {
  "use strict";
  Object.defineProperty(e, "__esModule", { value: true }), Object.defineProperty(e, "default", { enumerable: true, get: () => t });
  function t(r2, n) {
    return r2 === void 0 ? n : Array.isArray(r2) ? r2 : [...new Set(n.filter((i) => r2 !== false && r2[i] !== false).concat(Object.keys(r2).filter((i) => r2[i] !== false)))];
  }
});
var Gu = le((e, t) => {
  t.exports = { content: [], presets: [], darkMode: "media", theme: { screens: { sm: "640px", md: "768px", lg: "1024px", xl: "1280px", "2xl": "1536px" }, colors: ({ colors: r2 }) => ({ inherit: r2.inherit, current: r2.current, transparent: r2.transparent, black: r2.black, white: r2.white, slate: r2.slate, gray: r2.gray, zinc: r2.zinc, neutral: r2.neutral, stone: r2.stone, red: r2.red, orange: r2.orange, amber: r2.amber, yellow: r2.yellow, lime: r2.lime, green: r2.green, emerald: r2.emerald, teal: r2.teal, cyan: r2.cyan, sky: r2.sky, blue: r2.blue, indigo: r2.indigo, violet: r2.violet, purple: r2.purple, fuchsia: r2.fuchsia, pink: r2.pink, rose: r2.rose }), columns: { auto: "auto", 1: "1", 2: "2", 3: "3", 4: "4", 5: "5", 6: "6", 7: "7", 8: "8", 9: "9", 10: "10", 11: "11", 12: "12", "3xs": "16rem", "2xs": "18rem", xs: "20rem", sm: "24rem", md: "28rem", lg: "32rem", xl: "36rem", "2xl": "42rem", "3xl": "48rem", "4xl": "56rem", "5xl": "64rem", "6xl": "72rem", "7xl": "80rem" }, spacing: { px: "1px", 0: "0px", 0.5: "0.125rem", 1: "0.25rem", 1.5: "0.375rem", 2: "0.5rem", 2.5: "0.625rem", 3: "0.75rem", 3.5: "0.875rem", 4: "1rem", 5: "1.25rem", 6: "1.5rem", 7: "1.75rem", 8: "2rem", 9: "2.25rem", 10: "2.5rem", 11: "2.75rem", 12: "3rem", 14: "3.5rem", 16: "4rem", 20: "5rem", 24: "6rem", 28: "7rem", 32: "8rem", 36: "9rem", 40: "10rem", 44: "11rem", 48: "12rem", 52: "13rem", 56: "14rem", 60: "15rem", 64: "16rem", 72: "18rem", 80: "20rem", 96: "24rem" }, animation: { none: "none", spin: "spin 1s linear infinite", ping: "ping 1s cubic-bezier(0, 0, 0.2, 1) infinite", pulse: "pulse 2s cubic-bezier(0.4, 0, 0.6, 1) infinite", bounce: "bounce 1s infinite" }, aspectRatio: { auto: "auto", square: "1 / 1", video: "16 / 9" }, backdropBlur: ({ theme: r2 }) => r2("blur"), backdropBrightness: ({ theme: r2 }) => r2("brightness"), backdropContrast: ({ theme: r2 }) => r2("contrast"), backdropGrayscale: ({ theme: r2 }) => r2("grayscale"), backdropHueRotate: ({ theme: r2 }) => r2("hueRotate"), backdropInvert: ({ theme: r2 }) => r2("invert"), backdropOpacity: ({ theme: r2 }) => r2("opacity"), backdropSaturate: ({ theme: r2 }) => r2("saturate"), backdropSepia: ({ theme: r2 }) => r2("sepia"), backgroundColor: ({ theme: r2 }) => r2("colors"), backgroundImage: { none: "none", "gradient-to-t": "linear-gradient(to top, var(--tw-gradient-stops))", "gradient-to-tr": "linear-gradient(to top right, var(--tw-gradient-stops))", "gradient-to-r": "linear-gradient(to right, var(--tw-gradient-stops))", "gradient-to-br": "linear-gradient(to bottom right, var(--tw-gradient-stops))", "gradient-to-b": "linear-gradient(to bottom, var(--tw-gradient-stops))", "gradient-to-bl": "linear-gradient(to bottom left, var(--tw-gradient-stops))", "gradient-to-l": "linear-gradient(to left, var(--tw-gradient-stops))", "gradient-to-tl": "linear-gradient(to top left, var(--tw-gradient-stops))" }, backgroundOpacity: ({ theme: r2 }) => r2("opacity"), backgroundPosition: { bottom: "bottom", center: "center", left: "left", "left-bottom": "left bottom", "left-top": "left top", right: "right", "right-bottom": "right bottom", "right-top": "right top", top: "top" }, backgroundSize: { auto: "auto", cover: "cover", contain: "contain" }, blur: { 0: "0", none: "0", sm: "4px", DEFAULT: "8px", md: "12px", lg: "16px", xl: "24px", "2xl": "40px", "3xl": "64px" }, brightness: { 0: "0", 50: ".5", 75: ".75", 90: ".9", 95: ".95", 100: "1", 105: "1.05", 110: "1.1", 125: "1.25", 150: "1.5", 200: "2" }, borderColor: ({ theme: r2 }) => ({ ...r2("colors"), DEFAULT: r2("colors.gray.200", "currentColor") }), borderOpacity: ({ theme: r2 }) => r2("opacity"), borderRadius: { none: "0px", sm: "0.125rem", DEFAULT: "0.25rem", md: "0.375rem", lg: "0.5rem", xl: "0.75rem", "2xl": "1rem", "3xl": "1.5rem", full: "9999px" }, borderSpacing: ({ theme: r2 }) => ({ ...r2("spacing") }), borderWidth: { DEFAULT: "1px", 0: "0px", 2: "2px", 4: "4px", 8: "8px" }, boxShadow: { sm: "0 1px 2px 0 rgb(0 0 0 / 0.05)", DEFAULT: "0 1px 3px 0 rgb(0 0 0 / 0.1), 0 1px 2px -1px rgb(0 0 0 / 0.1)", md: "0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1)", lg: "0 10px 15px -3px rgb(0 0 0 / 0.1), 0 4px 6px -4px rgb(0 0 0 / 0.1)", xl: "0 20px 25px -5px rgb(0 0 0 / 0.1), 0 8px 10px -6px rgb(0 0 0 / 0.1)", "2xl": "0 25px 50px -12px rgb(0 0 0 / 0.25)", inner: "inset 0 2px 4px 0 rgb(0 0 0 / 0.05)", none: "none" }, boxShadowColor: ({ theme: r2 }) => r2("colors"), caretColor: ({ theme: r2 }) => r2("colors"), accentColor: ({ theme: r2 }) => ({ ...r2("colors"), auto: "auto" }), contrast: { 0: "0", 50: ".5", 75: ".75", 100: "1", 125: "1.25", 150: "1.5", 200: "2" }, container: {}, content: { none: "none" }, cursor: { auto: "auto", default: "default", pointer: "pointer", wait: "wait", text: "text", move: "move", help: "help", "not-allowed": "not-allowed", none: "none", "context-menu": "context-menu", progress: "progress", cell: "cell", crosshair: "crosshair", "vertical-text": "vertical-text", alias: "alias", copy: "copy", "no-drop": "no-drop", grab: "grab", grabbing: "grabbing", "all-scroll": "all-scroll", "col-resize": "col-resize", "row-resize": "row-resize", "n-resize": "n-resize", "e-resize": "e-resize", "s-resize": "s-resize", "w-resize": "w-resize", "ne-resize": "ne-resize", "nw-resize": "nw-resize", "se-resize": "se-resize", "sw-resize": "sw-resize", "ew-resize": "ew-resize", "ns-resize": "ns-resize", "nesw-resize": "nesw-resize", "nwse-resize": "nwse-resize", "zoom-in": "zoom-in", "zoom-out": "zoom-out" }, divideColor: ({ theme: r2 }) => r2("borderColor"), divideOpacity: ({ theme: r2 }) => r2("borderOpacity"), divideWidth: ({ theme: r2 }) => r2("borderWidth"), dropShadow: { sm: "0 1px 1px rgb(0 0 0 / 0.05)", DEFAULT: ["0 1px 2px rgb(0 0 0 / 0.1)", "0 1px 1px rgb(0 0 0 / 0.06)"], md: ["0 4px 3px rgb(0 0 0 / 0.07)", "0 2px 2px rgb(0 0 0 / 0.06)"], lg: ["0 10px 8px rgb(0 0 0 / 0.04)", "0 4px 3px rgb(0 0 0 / 0.1)"], xl: ["0 20px 13px rgb(0 0 0 / 0.03)", "0 8px 5px rgb(0 0 0 / 0.08)"], "2xl": "0 25px 25px rgb(0 0 0 / 0.15)", none: "0 0 #0000" }, fill: ({ theme: r2 }) => r2("colors"), grayscale: { 0: "0", DEFAULT: "100%" }, hueRotate: { 0: "0deg", 15: "15deg", 30: "30deg", 60: "60deg", 90: "90deg", 180: "180deg" }, invert: { 0: "0", DEFAULT: "100%" }, flex: { 1: "1 1 0%", auto: "1 1 auto", initial: "0 1 auto", none: "none" }, flexBasis: ({ theme: r2 }) => ({ auto: "auto", ...r2("spacing"), "1/2": "50%", "1/3": "33.333333%", "2/3": "66.666667%", "1/4": "25%", "2/4": "50%", "3/4": "75%", "1/5": "20%", "2/5": "40%", "3/5": "60%", "4/5": "80%", "1/6": "16.666667%", "2/6": "33.333333%", "3/6": "50%", "4/6": "66.666667%", "5/6": "83.333333%", "1/12": "8.333333%", "2/12": "16.666667%", "3/12": "25%", "4/12": "33.333333%", "5/12": "41.666667%", "6/12": "50%", "7/12": "58.333333%", "8/12": "66.666667%", "9/12": "75%", "10/12": "83.333333%", "11/12": "91.666667%", full: "100%" }), flexGrow: { 0: "0", DEFAULT: "1" }, flexShrink: { 0: "0", DEFAULT: "1" }, fontFamily: { sans: ["ui-sans-serif", "system-ui", "-apple-system", "BlinkMacSystemFont", '"Segoe UI"', "Roboto", '"Helvetica Neue"', "Arial", '"Noto Sans"', "sans-serif", '"Apple Color Emoji"', '"Segoe UI Emoji"', '"Segoe UI Symbol"', '"Noto Color Emoji"'], serif: ["ui-serif", "Georgia", "Cambria", '"Times New Roman"', "Times", "serif"], mono: ["ui-monospace", "SFMono-Regular", "Menlo", "Monaco", "Consolas", '"Liberation Mono"', '"Courier New"', "monospace"] }, fontSize: { xs: ["0.75rem", { lineHeight: "1rem" }], sm: ["0.875rem", { lineHeight: "1.25rem" }], base: ["1rem", { lineHeight: "1.5rem" }], lg: ["1.125rem", { lineHeight: "1.75rem" }], xl: ["1.25rem", { lineHeight: "1.75rem" }], "2xl": ["1.5rem", { lineHeight: "2rem" }], "3xl": ["1.875rem", { lineHeight: "2.25rem" }], "4xl": ["2.25rem", { lineHeight: "2.5rem" }], "5xl": ["3rem", { lineHeight: "1" }], "6xl": ["3.75rem", { lineHeight: "1" }], "7xl": ["4.5rem", { lineHeight: "1" }], "8xl": ["6rem", { lineHeight: "1" }], "9xl": ["8rem", { lineHeight: "1" }] }, fontWeight: { thin: "100", extralight: "200", light: "300", normal: "400", medium: "500", semibold: "600", bold: "700", extrabold: "800", black: "900" }, gap: ({ theme: r2 }) => r2("spacing"), gradientColorStops: ({ theme: r2 }) => r2("colors"), gridAutoColumns: { auto: "auto", min: "min-content", max: "max-content", fr: "minmax(0, 1fr)" }, gridAutoRows: { auto: "auto", min: "min-content", max: "max-content", fr: "minmax(0, 1fr)" }, gridColumn: { auto: "auto", "span-1": "span 1 / span 1", "span-2": "span 2 / span 2", "span-3": "span 3 / span 3", "span-4": "span 4 / span 4", "span-5": "span 5 / span 5", "span-6": "span 6 / span 6", "span-7": "span 7 / span 7", "span-8": "span 8 / span 8", "span-9": "span 9 / span 9", "span-10": "span 10 / span 10", "span-11": "span 11 / span 11", "span-12": "span 12 / span 12", "span-full": "1 / -1" }, gridColumnEnd: { auto: "auto", 1: "1", 2: "2", 3: "3", 4: "4", 5: "5", 6: "6", 7: "7", 8: "8", 9: "9", 10: "10", 11: "11", 12: "12", 13: "13" }, gridColumnStart: { auto: "auto", 1: "1", 2: "2", 3: "3", 4: "4", 5: "5", 6: "6", 7: "7", 8: "8", 9: "9", 10: "10", 11: "11", 12: "12", 13: "13" }, gridRow: { auto: "auto", "span-1": "span 1 / span 1", "span-2": "span 2 / span 2", "span-3": "span 3 / span 3", "span-4": "span 4 / span 4", "span-5": "span 5 / span 5", "span-6": "span 6 / span 6", "span-full": "1 / -1" }, gridRowStart: { auto: "auto", 1: "1", 2: "2", 3: "3", 4: "4", 5: "5", 6: "6", 7: "7" }, gridRowEnd: { auto: "auto", 1: "1", 2: "2", 3: "3", 4: "4", 5: "5", 6: "6", 7: "7" }, gridTemplateColumns: { none: "none", 1: "repeat(1, minmax(0, 1fr))", 2: "repeat(2, minmax(0, 1fr))", 3: "repeat(3, minmax(0, 1fr))", 4: "repeat(4, minmax(0, 1fr))", 5: "repeat(5, minmax(0, 1fr))", 6: "repeat(6, minmax(0, 1fr))", 7: "repeat(7, minmax(0, 1fr))", 8: "repeat(8, minmax(0, 1fr))", 9: "repeat(9, minmax(0, 1fr))", 10: "repeat(10, minmax(0, 1fr))", 11: "repeat(11, minmax(0, 1fr))", 12: "repeat(12, minmax(0, 1fr))" }, gridTemplateRows: { none: "none", 1: "repeat(1, minmax(0, 1fr))", 2: "repeat(2, minmax(0, 1fr))", 3: "repeat(3, minmax(0, 1fr))", 4: "repeat(4, minmax(0, 1fr))", 5: "repeat(5, minmax(0, 1fr))", 6: "repeat(6, minmax(0, 1fr))" }, height: ({ theme: r2 }) => ({ auto: "auto", ...r2("spacing"), "1/2": "50%", "1/3": "33.333333%", "2/3": "66.666667%", "1/4": "25%", "2/4": "50%", "3/4": "75%", "1/5": "20%", "2/5": "40%", "3/5": "60%", "4/5": "80%", "1/6": "16.666667%", "2/6": "33.333333%", "3/6": "50%", "4/6": "66.666667%", "5/6": "83.333333%", full: "100%", screen: "100vh", min: "min-content", max: "max-content", fit: "fit-content" }), inset: ({ theme: r2 }) => ({ auto: "auto", ...r2("spacing"), "1/2": "50%", "1/3": "33.333333%", "2/3": "66.666667%", "1/4": "25%", "2/4": "50%", "3/4": "75%", full: "100%" }), keyframes: { spin: { to: { transform: "rotate(360deg)" } }, ping: { "75%, 100%": { transform: "scale(2)", opacity: "0" } }, pulse: { "50%": { opacity: ".5" } }, bounce: { "0%, 100%": { transform: "translateY(-25%)", animationTimingFunction: "cubic-bezier(0.8,0,1,1)" }, "50%": { transform: "none", animationTimingFunction: "cubic-bezier(0,0,0.2,1)" } } }, letterSpacing: { tighter: "-0.05em", tight: "-0.025em", normal: "0em", wide: "0.025em", wider: "0.05em", widest: "0.1em" }, lineHeight: { none: "1", tight: "1.25", snug: "1.375", normal: "1.5", relaxed: "1.625", loose: "2", 3: ".75rem", 4: "1rem", 5: "1.25rem", 6: "1.5rem", 7: "1.75rem", 8: "2rem", 9: "2.25rem", 10: "2.5rem" }, listStyleType: { none: "none", disc: "disc", decimal: "decimal" }, margin: ({ theme: r2 }) => ({ auto: "auto", ...r2("spacing") }), maxHeight: ({ theme: r2 }) => ({ ...r2("spacing"), full: "100%", screen: "100vh", min: "min-content", max: "max-content", fit: "fit-content" }), maxWidth: ({ theme: r2, breakpoints: n }) => ({ none: "none", 0: "0rem", xs: "20rem", sm: "24rem", md: "28rem", lg: "32rem", xl: "36rem", "2xl": "42rem", "3xl": "48rem", "4xl": "56rem", "5xl": "64rem", "6xl": "72rem", "7xl": "80rem", full: "100%", min: "min-content", max: "max-content", fit: "fit-content", prose: "65ch", ...n(r2("screens")) }), minHeight: { 0: "0px", full: "100%", screen: "100vh", min: "min-content", max: "max-content", fit: "fit-content" }, minWidth: { 0: "0px", full: "100%", min: "min-content", max: "max-content", fit: "fit-content" }, objectPosition: { bottom: "bottom", center: "center", left: "left", "left-bottom": "left bottom", "left-top": "left top", right: "right", "right-bottom": "right bottom", "right-top": "right top", top: "top" }, opacity: { 0: "0", 5: "0.05", 10: "0.1", 20: "0.2", 25: "0.25", 30: "0.3", 40: "0.4", 50: "0.5", 60: "0.6", 70: "0.7", 75: "0.75", 80: "0.8", 90: "0.9", 95: "0.95", 100: "1" }, order: { first: "-9999", last: "9999", none: "0", 1: "1", 2: "2", 3: "3", 4: "4", 5: "5", 6: "6", 7: "7", 8: "8", 9: "9", 10: "10", 11: "11", 12: "12" }, padding: ({ theme: r2 }) => r2("spacing"), placeholderColor: ({ theme: r2 }) => r2("colors"), placeholderOpacity: ({ theme: r2 }) => r2("opacity"), outlineColor: ({ theme: r2 }) => r2("colors"), outlineOffset: { 0: "0px", 1: "1px", 2: "2px", 4: "4px", 8: "8px" }, outlineWidth: { 0: "0px", 1: "1px", 2: "2px", 4: "4px", 8: "8px" }, ringColor: ({ theme: r2 }) => ({ DEFAULT: r2("colors.blue.500", "#3b82f6"), ...r2("colors") }), ringOffsetColor: ({ theme: r2 }) => r2("colors"), ringOffsetWidth: { 0: "0px", 1: "1px", 2: "2px", 4: "4px", 8: "8px" }, ringOpacity: ({ theme: r2 }) => ({ DEFAULT: "0.5", ...r2("opacity") }), ringWidth: { DEFAULT: "3px", 0: "0px", 1: "1px", 2: "2px", 4: "4px", 8: "8px" }, rotate: { 0: "0deg", 1: "1deg", 2: "2deg", 3: "3deg", 6: "6deg", 12: "12deg", 45: "45deg", 90: "90deg", 180: "180deg" }, saturate: { 0: "0", 50: ".5", 100: "1", 150: "1.5", 200: "2" }, scale: { 0: "0", 50: ".5", 75: ".75", 90: ".9", 95: ".95", 100: "1", 105: "1.05", 110: "1.1", 125: "1.25", 150: "1.5" }, scrollMargin: ({ theme: r2 }) => ({ ...r2("spacing") }), scrollPadding: ({ theme: r2 }) => r2("spacing"), sepia: { 0: "0", DEFAULT: "100%" }, skew: { 0: "0deg", 1: "1deg", 2: "2deg", 3: "3deg", 6: "6deg", 12: "12deg" }, space: ({ theme: r2 }) => ({ ...r2("spacing") }), stroke: ({ theme: r2 }) => r2("colors"), strokeWidth: { 0: "0", 1: "1", 2: "2" }, textColor: ({ theme: r2 }) => r2("colors"), textDecorationColor: ({ theme: r2 }) => r2("colors"), textDecorationThickness: { auto: "auto", "from-font": "from-font", 0: "0px", 1: "1px", 2: "2px", 4: "4px", 8: "8px" }, textUnderlineOffset: { auto: "auto", 0: "0px", 1: "1px", 2: "2px", 4: "4px", 8: "8px" }, textIndent: ({ theme: r2 }) => ({ ...r2("spacing") }), textOpacity: ({ theme: r2 }) => r2("opacity"), transformOrigin: { center: "center", top: "top", "top-right": "top right", right: "right", "bottom-right": "bottom right", bottom: "bottom", "bottom-left": "bottom left", left: "left", "top-left": "top left" }, transitionDelay: { 75: "75ms", 100: "100ms", 150: "150ms", 200: "200ms", 300: "300ms", 500: "500ms", 700: "700ms", 1e3: "1000ms" }, transitionDuration: { DEFAULT: "150ms", 75: "75ms", 100: "100ms", 150: "150ms", 200: "200ms", 300: "300ms", 500: "500ms", 700: "700ms", 1e3: "1000ms" }, transitionProperty: { none: "none", all: "all", DEFAULT: "color, background-color, border-color, text-decoration-color, fill, stroke, opacity, box-shadow, transform, filter, backdrop-filter", colors: "color, background-color, border-color, text-decoration-color, fill, stroke", opacity: "opacity", shadow: "box-shadow", transform: "transform" }, transitionTimingFunction: { DEFAULT: "cubic-bezier(0.4, 0, 0.2, 1)", linear: "linear", in: "cubic-bezier(0.4, 0, 1, 1)", out: "cubic-bezier(0, 0, 0.2, 1)", "in-out": "cubic-bezier(0.4, 0, 0.2, 1)" }, translate: ({ theme: r2 }) => ({ ...r2("spacing"), "1/2": "50%", "1/3": "33.333333%", "2/3": "66.666667%", "1/4": "25%", "2/4": "50%", "3/4": "75%", full: "100%" }), width: ({ theme: r2 }) => ({ auto: "auto", ...r2("spacing"), "1/2": "50%", "1/3": "33.333333%", "2/3": "66.666667%", "1/4": "25%", "2/4": "50%", "3/4": "75%", "1/5": "20%", "2/5": "40%", "3/5": "60%", "4/5": "80%", "1/6": "16.666667%", "2/6": "33.333333%", "3/6": "50%", "4/6": "66.666667%", "5/6": "83.333333%", "1/12": "8.333333%", "2/12": "16.666667%", "3/12": "25%", "4/12": "33.333333%", "5/12": "41.666667%", "6/12": "50%", "7/12": "58.333333%", "8/12": "66.666667%", "9/12": "75%", "10/12": "83.333333%", "11/12": "91.666667%", full: "100%", screen: "100vw", min: "min-content", max: "max-content", fit: "fit-content" }), willChange: { auto: "auto", scroll: "scroll-position", contents: "contents", transform: "transform" }, zIndex: { auto: "auto", 0: "0", 10: "10", 20: "20", 30: "30", 40: "40", 50: "50" } }, variantOrder: ["first", "last", "odd", "even", "visited", "checked", "empty", "read-only", "group-hover", "group-focus", "focus-within", "hover", "focus", "focus-visible", "active", "disabled"], plugins: [] };
});
var Zn = {};
Aa(Zn, { default: () => Wu });
var Wu;
var Oa = _a(() => {
  Wu = { info(e, t) {
    console.info(...Array.isArray(e) ? [e] : [t, e]);
  }, warn(e, t) {
    console.warn(...Array.isArray(e) ? [e] : [t, e]);
  }, risk(e, t) {
    console.error(...Array.isArray(e) ? [e] : [t, e]);
  } };
});
var Nv = le((e) => {
  "use strict";
  Object.defineProperty(e, "__esModule", { value: true }), Object.defineProperty(e, "default", { enumerable: true, get: () => i });
  var t = r2((Oa(), Xn(Zn)));
  function r2(a) {
    return a && a.__esModule ? a : { default: a };
  }
  function n({ version: a, from: o, to: u }) {
    t.default.warn(`${o}-color-renamed`, [`As of Tailwind CSS ${a}, \`${o}\` has been renamed to \`${u}\`.`, "Update your configuration file to silence this warning."]);
  }
  var i = { inherit: "inherit", current: "currentColor", transparent: "transparent", black: "#000", white: "#fff", slate: { 50: "#f8fafc", 100: "#f1f5f9", 200: "#e2e8f0", 300: "#cbd5e1", 400: "#94a3b8", 500: "#64748b", 600: "#475569", 700: "#334155", 800: "#1e293b", 900: "#0f172a" }, gray: { 50: "#f9fafb", 100: "#f3f4f6", 200: "#e5e7eb", 300: "#d1d5db", 400: "#9ca3af", 500: "#6b7280", 600: "#4b5563", 700: "#374151", 800: "#1f2937", 900: "#111827" }, zinc: { 50: "#fafafa", 100: "#f4f4f5", 200: "#e4e4e7", 300: "#d4d4d8", 400: "#a1a1aa", 500: "#71717a", 600: "#52525b", 700: "#3f3f46", 800: "#27272a", 900: "#18181b" }, neutral: { 50: "#fafafa", 100: "#f5f5f5", 200: "#e5e5e5", 300: "#d4d4d4", 400: "#a3a3a3", 500: "#737373", 600: "#525252", 700: "#404040", 800: "#262626", 900: "#171717" }, stone: { 50: "#fafaf9", 100: "#f5f5f4", 200: "#e7e5e4", 300: "#d6d3d1", 400: "#a8a29e", 500: "#78716c", 600: "#57534e", 700: "#44403c", 800: "#292524", 900: "#1c1917" }, red: { 50: "#fef2f2", 100: "#fee2e2", 200: "#fecaca", 300: "#fca5a5", 400: "#f87171", 500: "#ef4444", 600: "#dc2626", 700: "#b91c1c", 800: "#991b1b", 900: "#7f1d1d" }, orange: { 50: "#fff7ed", 100: "#ffedd5", 200: "#fed7aa", 300: "#fdba74", 400: "#fb923c", 500: "#f97316", 600: "#ea580c", 700: "#c2410c", 800: "#9a3412", 900: "#7c2d12" }, amber: { 50: "#fffbeb", 100: "#fef3c7", 200: "#fde68a", 300: "#fcd34d", 400: "#fbbf24", 500: "#f59e0b", 600: "#d97706", 700: "#b45309", 800: "#92400e", 900: "#78350f" }, yellow: { 50: "#fefce8", 100: "#fef9c3", 200: "#fef08a", 300: "#fde047", 400: "#facc15", 500: "#eab308", 600: "#ca8a04", 700: "#a16207", 800: "#854d0e", 900: "#713f12" }, lime: { 50: "#f7fee7", 100: "#ecfccb", 200: "#d9f99d", 300: "#bef264", 400: "#a3e635", 500: "#84cc16", 600: "#65a30d", 700: "#4d7c0f", 800: "#3f6212", 900: "#365314" }, green: { 50: "#f0fdf4", 100: "#dcfce7", 200: "#bbf7d0", 300: "#86efac", 400: "#4ade80", 500: "#22c55e", 600: "#16a34a", 700: "#15803d", 800: "#166534", 900: "#14532d" }, emerald: { 50: "#ecfdf5", 100: "#d1fae5", 200: "#a7f3d0", 300: "#6ee7b7", 400: "#34d399", 500: "#10b981", 600: "#059669", 700: "#047857", 800: "#065f46", 900: "#064e3b" }, teal: { 50: "#f0fdfa", 100: "#ccfbf1", 200: "#99f6e4", 300: "#5eead4", 400: "#2dd4bf", 500: "#14b8a6", 600: "#0d9488", 700: "#0f766e", 800: "#115e59", 900: "#134e4a" }, cyan: { 50: "#ecfeff", 100: "#cffafe", 200: "#a5f3fc", 300: "#67e8f9", 400: "#22d3ee", 500: "#06b6d4", 600: "#0891b2", 700: "#0e7490", 800: "#155e75", 900: "#164e63" }, sky: { 50: "#f0f9ff", 100: "#e0f2fe", 200: "#bae6fd", 300: "#7dd3fc", 400: "#38bdf8", 500: "#0ea5e9", 600: "#0284c7", 700: "#0369a1", 800: "#075985", 900: "#0c4a6e" }, blue: { 50: "#eff6ff", 100: "#dbeafe", 200: "#bfdbfe", 300: "#93c5fd", 400: "#60a5fa", 500: "#3b82f6", 600: "#2563eb", 700: "#1d4ed8", 800: "#1e40af", 900: "#1e3a8a" }, indigo: { 50: "#eef2ff", 100: "#e0e7ff", 200: "#c7d2fe", 300: "#a5b4fc", 400: "#818cf8", 500: "#6366f1", 600: "#4f46e5", 700: "#4338ca", 800: "#3730a3", 900: "#312e81" }, violet: { 50: "#f5f3ff", 100: "#ede9fe", 200: "#ddd6fe", 300: "#c4b5fd", 400: "#a78bfa", 500: "#8b5cf6", 600: "#7c3aed", 700: "#6d28d9", 800: "#5b21b6", 900: "#4c1d95" }, purple: { 50: "#faf5ff", 100: "#f3e8ff", 200: "#e9d5ff", 300: "#d8b4fe", 400: "#c084fc", 500: "#a855f7", 600: "#9333ea", 700: "#7e22ce", 800: "#6b21a8", 900: "#581c87" }, fuchsia: { 50: "#fdf4ff", 100: "#fae8ff", 200: "#f5d0fe", 300: "#f0abfc", 400: "#e879f9", 500: "#d946ef", 600: "#c026d3", 700: "#a21caf", 800: "#86198f", 900: "#701a75" }, pink: { 50: "#fdf2f8", 100: "#fce7f3", 200: "#fbcfe8", 300: "#f9a8d4", 400: "#f472b6", 500: "#ec4899", 600: "#db2777", 700: "#be185d", 800: "#9d174d", 900: "#831843" }, rose: { 50: "#fff1f2", 100: "#ffe4e6", 200: "#fecdd3", 300: "#fda4af", 400: "#fb7185", 500: "#f43f5e", 600: "#e11d48", 700: "#be123c", 800: "#9f1239", 900: "#881337" }, get lightBlue() {
    return n({ version: "v2.2", from: "lightBlue", to: "sky" }), this.sky;
  }, get warmGray() {
    return n({ version: "v3.0", from: "warmGray", to: "stone" }), this.stone;
  }, get trueGray() {
    return n({ version: "v3.0", from: "trueGray", to: "neutral" }), this.neutral;
  }, get coolGray() {
    return n({ version: "v3.0", from: "coolGray", to: "gray" }), this.gray;
  }, get blueGray() {
    return n({ version: "v3.0", from: "blueGray", to: "slate" }), this.slate;
  } };
});
var Mv = le((e) => {
  "use strict";
  Object.defineProperty(e, "__esModule", { value: true }), Object.defineProperty(e, "defaults", { enumerable: true, get: () => t });
  function t(r2, ...n) {
    for (let o of n) {
      for (let u in o) {
        var i;
        !(r2 == null || (i = r2.hasOwnProperty) === null || i === void 0) && i.call(r2, u) || (r2[u] = o[u]);
      }
      for (let u of Object.getOwnPropertySymbols(o)) {
        var a;
        !(r2 == null || (a = r2.hasOwnProperty) === null || a === void 0) && a.call(r2, u) || (r2[u] = o[u]);
      }
    }
    return r2;
  }
});
var Gv = le((e) => {
  "use strict";
  Object.defineProperty(e, "__esModule", { value: true }), Object.defineProperty(e, "toPath", { enumerable: true, get: () => t });
  function t(r2) {
    if (Array.isArray(r2))
      return r2;
    let n = r2.split("[").length - 1, i = r2.split("]").length - 1;
    if (n !== i)
      throw new Error(`Path is invalid. Has unbalanced brackets: ${r2}`);
    return r2.split(/\.(?![^\[]*\])|[\[\]]/g).filter(Boolean);
  }
});
var Wv = le((e) => {
  "use strict";
  Object.defineProperty(e, "__esModule", { value: true }), Object.defineProperty(e, "normalizeConfig", { enumerable: true, get: () => i });
  var t = n((Oa(), Xn(Zn)));
  function r2(a) {
    if (typeof WeakMap != "function")
      return null;
    var o = /* @__PURE__ */ new WeakMap(), u = /* @__PURE__ */ new WeakMap();
    return (r2 = function(s) {
      return s ? u : o;
    })(a);
  }
  function n(a, o) {
    if (!o && a && a.__esModule)
      return a;
    if (a === null || typeof a != "object" && typeof a != "function")
      return { default: a };
    var u = r2(o);
    if (u && u.has(a))
      return u.get(a);
    var s = {}, l = Object.defineProperty && Object.getOwnPropertyDescriptor;
    for (var f in a)
      if (f !== "default" && Object.prototype.hasOwnProperty.call(a, f)) {
        var c = l ? Object.getOwnPropertyDescriptor(a, f) : null;
        c && (c.get || c.set) ? Object.defineProperty(s, f, c) : s[f] = a[f];
      }
    return s.default = a, u && u.set(a, s), s;
  }
  function i(a) {
    if ((() => {
      if (a.purge || !a.content || !Array.isArray(a.content) && !(typeof a.content == "object" && a.content !== null))
        return false;
      if (Array.isArray(a.content))
        return a.content.every((u) => typeof u == "string" ? true : !(typeof u?.raw != "string" || u != null && u.extension && typeof u?.extension != "string"));
      if (typeof a.content == "object" && a.content !== null) {
        if (Object.keys(a.content).some((u) => !["files", "extract", "transform"].includes(u)))
          return false;
        if (Array.isArray(a.content.files)) {
          if (!a.content.files.every((u) => typeof u == "string" ? true : !(typeof u?.raw != "string" || u != null && u.extension && typeof u?.extension != "string")))
            return false;
          if (typeof a.content.extract == "object") {
            for (let u of Object.values(a.content.extract))
              if (typeof u != "function")
                return false;
          } else if (!(a.content.extract === void 0 || typeof a.content.extract == "function"))
            return false;
          if (typeof a.content.transform == "object") {
            for (let u of Object.values(a.content.transform))
              if (typeof u != "function")
                return false;
          } else if (!(a.content.transform === void 0 || typeof a.content.transform == "function"))
            return false;
        }
        return true;
      }
      return false;
    })() || t.default.warn("purge-deprecation", ["The `purge`/`content` options have changed in Tailwind CSS v3.0.", "Update your configuration file to eliminate this warning.", "https://tailwindcss.com/docs/upgrade-guide#configure-content-sources"]), a.safelist = (() => {
      var u;
      let { content: s, purge: l, safelist: f } = a;
      return Array.isArray(f) ? f : Array.isArray(s?.safelist) ? s.safelist : Array.isArray(l?.safelist) ? l.safelist : Array.isArray(l == null || (u = l.options) === null || u === void 0 ? void 0 : u.safelist) ? l.options.safelist : [];
    })(), typeof a.prefix == "function")
      t.default.warn("prefix-function", ["As of Tailwind CSS v3.0, `prefix` cannot be a function.", "Update `prefix` in your configuration to be a string to eliminate this warning.", "https://tailwindcss.com/docs/upgrade-guide#prefix-cannot-be-a-function"]), a.prefix = "";
    else {
      var o;
      a.prefix = (o = a.prefix) !== null && o !== void 0 ? o : "";
    }
    a.content = { files: (() => {
      let { content: u, purge: s } = a;
      return Array.isArray(s) ? s : Array.isArray(s?.content) ? s.content : Array.isArray(u) ? u : Array.isArray(u?.content) ? u.content : Array.isArray(u?.files) ? u.files : [];
    })(), extract: (() => {
      let u = (() => {
        var f, c, p2, d, D, v, g, y, b, C;
        return !((f = a.purge) === null || f === void 0) && f.extract ? a.purge.extract : !((c = a.content) === null || c === void 0) && c.extract ? a.content.extract : !((p2 = a.purge) === null || p2 === void 0 || (d = p2.extract) === null || d === void 0) && d.DEFAULT ? a.purge.extract.DEFAULT : !((D = a.content) === null || D === void 0 || (v = D.extract) === null || v === void 0) && v.DEFAULT ? a.content.extract.DEFAULT : !((g = a.purge) === null || g === void 0 || (y = g.options) === null || y === void 0) && y.extractors ? a.purge.options.extractors : !((b = a.content) === null || b === void 0 || (C = b.options) === null || C === void 0) && C.extractors ? a.content.options.extractors : {};
      })(), s = {}, l = (() => {
        var f, c, p2, d;
        if (!((f = a.purge) === null || f === void 0 || (c = f.options) === null || c === void 0) && c.defaultExtractor)
          return a.purge.options.defaultExtractor;
        if (!((p2 = a.content) === null || p2 === void 0 || (d = p2.options) === null || d === void 0) && d.defaultExtractor)
          return a.content.options.defaultExtractor;
      })();
      if (l !== void 0 && (s.DEFAULT = l), typeof u == "function")
        s.DEFAULT = u;
      else if (Array.isArray(u))
        for (let { extensions: f, extractor: c } of u ?? [])
          for (let p2 of f)
            s[p2] = c;
      else
        typeof u == "object" && u !== null && Object.assign(s, u);
      return s;
    })(), transform: (() => {
      let u = (() => {
        var l, f, c, p2, d, D;
        return !((l = a.purge) === null || l === void 0) && l.transform ? a.purge.transform : !((f = a.content) === null || f === void 0) && f.transform ? a.content.transform : !((c = a.purge) === null || c === void 0 || (p2 = c.transform) === null || p2 === void 0) && p2.DEFAULT ? a.purge.transform.DEFAULT : !((d = a.content) === null || d === void 0 || (D = d.transform) === null || D === void 0) && D.DEFAULT ? a.content.transform.DEFAULT : {};
      })(), s = {};
      return typeof u == "function" && (s.DEFAULT = u), typeof u == "object" && u !== null && Object.assign(s, u), s;
    })() };
    for (let u of a.content.files)
      if (typeof u == "string" && /{([^,]*?)}/g.test(u)) {
        t.default.warn("invalid-glob-braces", [`The glob pattern ${(0, t.dim)(u)} in your Tailwind CSS configuration is invalid.`, `Update it to ${(0, t.dim)(u.replace(/{([^,]*?)}/g, "$1"))} to silence this warning.`]);
        break;
      }
    return a;
  }
});
var $v = le((e) => {
  "use strict";
  Object.defineProperty(e, "__esModule", { value: true }), Object.defineProperty(e, "default", { enumerable: true, get: () => t });
  function t(r2) {
    if (Object.prototype.toString.call(r2) !== "[object Object]")
      return false;
    let n = Object.getPrototypeOf(r2);
    return n === null || n === Object.prototype;
  }
});
var jv = le((e) => {
  "use strict";
  Object.defineProperty(e, "__esModule", { value: true }), Object.defineProperty(e, "cloneDeep", { enumerable: true, get: () => t });
  function t(r2) {
    return Array.isArray(r2) ? r2.map((n) => t(n)) : typeof r2 == "object" && r2 !== null ? Object.fromEntries(Object.entries(r2).map(([n, i]) => [n, t(i)])) : r2;
  }
});
var $u = le((e, t) => {
  "use strict";
  e.__esModule = true, e.default = i;
  function r2(a) {
    for (var o = a.toLowerCase(), u = "", s = false, l = 0; l < 6 && o[l] !== void 0; l++) {
      var f = o.charCodeAt(l), c = f >= 97 && f <= 102 || f >= 48 && f <= 57;
      if (s = f === 32, !c)
        break;
      u += o[l];
    }
    if (u.length !== 0) {
      var p2 = parseInt(u, 16), d = p2 >= 55296 && p2 <= 57343;
      return d || p2 === 0 || p2 > 1114111 ? ["\uFFFD", u.length + (s ? 1 : 0)] : [String.fromCodePoint(p2), u.length + (s ? 1 : 0)];
    }
  }
  var n = /\\/;
  function i(a) {
    var o = n.test(a);
    if (!o)
      return a;
    for (var u = "", s = 0; s < a.length; s++) {
      if (a[s] === "\\") {
        var l = r2(a.slice(s + 1, s + 7));
        if (l !== void 0) {
          u += l[0], s += l[1];
          continue;
        }
        if (a[s + 1] === "\\") {
          u += "\\", s++;
          continue;
        }
        a.length === s + 1 && (u += a[s]);
        continue;
      }
      u += a[s];
    }
    return u;
  }
  t.exports = e.default;
});
var zv = le((e, t) => {
  "use strict";
  e.__esModule = true, e.default = r2;
  function r2(n) {
    for (var i = arguments.length, a = new Array(i > 1 ? i - 1 : 0), o = 1; o < i; o++)
      a[o - 1] = arguments[o];
    for (; a.length > 0; ) {
      var u = a.shift();
      if (!n[u])
        return;
      n = n[u];
    }
    return n;
  }
  t.exports = e.default;
});
var Vv = le((e, t) => {
  "use strict";
  e.__esModule = true, e.default = r2;
  function r2(n) {
    for (var i = arguments.length, a = new Array(i > 1 ? i - 1 : 0), o = 1; o < i; o++)
      a[o - 1] = arguments[o];
    for (; a.length > 0; ) {
      var u = a.shift();
      n[u] || (n[u] = {}), n = n[u];
    }
  }
  t.exports = e.default;
});
var Hv = le((e, t) => {
  "use strict";
  e.__esModule = true, e.default = r2;
  function r2(n) {
    for (var i = "", a = n.indexOf("/*"), o = 0; a >= 0; ) {
      i = i + n.slice(o, a);
      var u = n.indexOf("*/", a + 2);
      if (u < 0)
        return i;
      o = u + 2, a = n.indexOf("/*", o);
    }
    return i = i + n.slice(o), i;
  }
  t.exports = e.default;
});
var Jn = le((e) => {
  "use strict";
  e.__esModule = true, e.stripComments = e.ensureObject = e.getProp = e.unesc = void 0;
  var t = a($u());
  e.unesc = t.default;
  var r2 = a(zv());
  e.getProp = r2.default;
  var n = a(Vv());
  e.ensureObject = n.default;
  var i = a(Hv());
  e.stripComments = i.default;
  function a(o) {
    return o && o.__esModule ? o : { default: o };
  }
});
var pr = le((e, t) => {
  "use strict";
  e.__esModule = true, e.default = void 0;
  var r2 = Jn();
  function n(u, s) {
    for (var l = 0; l < s.length; l++) {
      var f = s[l];
      f.enumerable = f.enumerable || false, f.configurable = true, "value" in f && (f.writable = true), Object.defineProperty(u, f.key, f);
    }
  }
  function i(u, s, l) {
    return s && n(u.prototype, s), l && n(u, l), u;
  }
  var a = function u(s, l) {
    if (typeof s != "object" || s === null)
      return s;
    var f = new s.constructor();
    for (var c in s)
      if (s.hasOwnProperty(c)) {
        var p2 = s[c], d = typeof p2;
        c === "parent" && d === "object" ? l && (f[c] = l) : p2 instanceof Array ? f[c] = p2.map(function(D) {
          return u(D, f);
        }) : f[c] = u(p2, f);
      }
    return f;
  }, o = function() {
    function u(l) {
      l === void 0 && (l = {}), Object.assign(this, l), this.spaces = this.spaces || {}, this.spaces.before = this.spaces.before || "", this.spaces.after = this.spaces.after || "";
    }
    var s = u.prototype;
    return s.remove = function() {
      return this.parent && this.parent.removeChild(this), this.parent = void 0, this;
    }, s.replaceWith = function() {
      if (this.parent) {
        for (var l in arguments)
          this.parent.insertBefore(this, arguments[l]);
        this.remove();
      }
      return this;
    }, s.next = function() {
      return this.parent.at(this.parent.index(this) + 1);
    }, s.prev = function() {
      return this.parent.at(this.parent.index(this) - 1);
    }, s.clone = function(l) {
      l === void 0 && (l = {});
      var f = a(this);
      for (var c in l)
        f[c] = l[c];
      return f;
    }, s.appendToPropertyAndEscape = function(l, f, c) {
      this.raws || (this.raws = {});
      var p2 = this[l], d = this.raws[l];
      this[l] = p2 + f, d || c !== f ? this.raws[l] = (d || p2) + c : delete this.raws[l];
    }, s.setPropertyAndEscape = function(l, f, c) {
      this.raws || (this.raws = {}), this[l] = f, this.raws[l] = c;
    }, s.setPropertyWithoutEscape = function(l, f) {
      this[l] = f, this.raws && delete this.raws[l];
    }, s.isAtPosition = function(l, f) {
      if (this.source && this.source.start && this.source.end)
        return !(this.source.start.line > l || this.source.end.line < l || this.source.start.line === l && this.source.start.column > f || this.source.end.line === l && this.source.end.column < f);
    }, s.stringifyProperty = function(l) {
      return this.raws && this.raws[l] || this[l];
    }, s.valueToString = function() {
      return String(this.stringifyProperty("value"));
    }, s.toString = function() {
      return [this.rawSpaceBefore, this.valueToString(), this.rawSpaceAfter].join("");
    }, i(u, [{ key: "rawSpaceBefore", get: function() {
      var l = this.raws && this.raws.spaces && this.raws.spaces.before;
      return l === void 0 && (l = this.spaces && this.spaces.before), l || "";
    }, set: function(l) {
      (0, r2.ensureObject)(this, "raws", "spaces"), this.raws.spaces.before = l;
    } }, { key: "rawSpaceAfter", get: function() {
      var l = this.raws && this.raws.spaces && this.raws.spaces.after;
      return l === void 0 && (l = this.spaces.after), l || "";
    }, set: function(l) {
      (0, r2.ensureObject)(this, "raws", "spaces"), this.raws.spaces.after = l;
    } }]), u;
  }();
  e.default = o, t.exports = e.default;
});
var ut = le((e) => {
  "use strict";
  e.__esModule = true, e.UNIVERSAL = e.ATTRIBUTE = e.CLASS = e.COMBINATOR = e.COMMENT = e.ID = e.NESTING = e.PSEUDO = e.ROOT = e.SELECTOR = e.STRING = e.TAG = void 0;
  var t = "tag";
  e.TAG = t;
  var r2 = "string";
  e.STRING = r2;
  var n = "selector";
  e.SELECTOR = n;
  var i = "root";
  e.ROOT = i;
  var a = "pseudo";
  e.PSEUDO = a;
  var o = "nesting";
  e.NESTING = o;
  var u = "id";
  e.ID = u;
  var s = "comment";
  e.COMMENT = s;
  var l = "combinator";
  e.COMBINATOR = l;
  var f = "class";
  e.CLASS = f;
  var c = "attribute";
  e.ATTRIBUTE = c;
  var p2 = "universal";
  e.UNIVERSAL = p2;
});
var La = le((e, t) => {
  "use strict";
  e.__esModule = true, e.default = void 0;
  var r2 = o(pr()), n = a(ut());
  function i() {
    if (typeof WeakMap != "function")
      return null;
    var v = /* @__PURE__ */ new WeakMap();
    return i = function() {
      return v;
    }, v;
  }
  function a(v) {
    if (v && v.__esModule)
      return v;
    if (v === null || typeof v != "object" && typeof v != "function")
      return { default: v };
    var g = i();
    if (g && g.has(v))
      return g.get(v);
    var y = {}, b = Object.defineProperty && Object.getOwnPropertyDescriptor;
    for (var C in v)
      if (Object.prototype.hasOwnProperty.call(v, C)) {
        var k = b ? Object.getOwnPropertyDescriptor(v, C) : null;
        k && (k.get || k.set) ? Object.defineProperty(y, C, k) : y[C] = v[C];
      }
    return y.default = v, g && g.set(v, y), y;
  }
  function o(v) {
    return v && v.__esModule ? v : { default: v };
  }
  function u(v, g) {
    var y;
    if (typeof Symbol > "u" || v[Symbol.iterator] == null) {
      if (Array.isArray(v) || (y = s(v)) || g && v && typeof v.length == "number") {
        y && (v = y);
        var b = 0;
        return function() {
          return b >= v.length ? { done: true } : { done: false, value: v[b++] };
        };
      }
      throw new TypeError(`Invalid attempt to iterate non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
    }
    return y = v[Symbol.iterator](), y.next.bind(y);
  }
  function s(v, g) {
    if (v) {
      if (typeof v == "string")
        return l(v, g);
      var y = Object.prototype.toString.call(v).slice(8, -1);
      if (y === "Object" && v.constructor && (y = v.constructor.name), y === "Map" || y === "Set")
        return Array.from(v);
      if (y === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(y))
        return l(v, g);
    }
  }
  function l(v, g) {
    (g == null || g > v.length) && (g = v.length);
    for (var y = 0, b = new Array(g); y < g; y++)
      b[y] = v[y];
    return b;
  }
  function f(v, g) {
    for (var y = 0; y < g.length; y++) {
      var b = g[y];
      b.enumerable = b.enumerable || false, b.configurable = true, "value" in b && (b.writable = true), Object.defineProperty(v, b.key, b);
    }
  }
  function c(v, g, y) {
    return g && f(v.prototype, g), y && f(v, y), v;
  }
  function p2(v, g) {
    v.prototype = Object.create(g.prototype), v.prototype.constructor = v, d(v, g);
  }
  function d(v, g) {
    return d = Object.setPrototypeOf || function(y, b) {
      return y.__proto__ = b, y;
    }, d(v, g);
  }
  var D = function(v) {
    p2(g, v);
    function g(b) {
      var C;
      return C = v.call(this, b) || this, C.nodes || (C.nodes = []), C;
    }
    var y = g.prototype;
    return y.append = function(b) {
      return b.parent = this, this.nodes.push(b), this;
    }, y.prepend = function(b) {
      return b.parent = this, this.nodes.unshift(b), this;
    }, y.at = function(b) {
      return this.nodes[b];
    }, y.index = function(b) {
      return typeof b == "number" ? b : this.nodes.indexOf(b);
    }, y.removeChild = function(b) {
      b = this.index(b), this.at(b).parent = void 0, this.nodes.splice(b, 1);
      var C;
      for (var k in this.indexes)
        C = this.indexes[k], C >= b && (this.indexes[k] = C - 1);
      return this;
    }, y.removeAll = function() {
      for (var b = u(this.nodes), C; !(C = b()).done; ) {
        var k = C.value;
        k.parent = void 0;
      }
      return this.nodes = [], this;
    }, y.empty = function() {
      return this.removeAll();
    }, y.insertAfter = function(b, C) {
      C.parent = this;
      var k = this.index(b);
      this.nodes.splice(k + 1, 0, C), C.parent = this;
      var S;
      for (var E in this.indexes)
        S = this.indexes[E], k <= S && (this.indexes[E] = S + 1);
      return this;
    }, y.insertBefore = function(b, C) {
      C.parent = this;
      var k = this.index(b);
      this.nodes.splice(k, 0, C), C.parent = this;
      var S;
      for (var E in this.indexes)
        S = this.indexes[E], S <= k && (this.indexes[E] = S + 1);
      return this;
    }, y._findChildAtPosition = function(b, C) {
      var k = void 0;
      return this.each(function(S) {
        if (S.atPosition) {
          var E = S.atPosition(b, C);
          if (E)
            return k = E, false;
        } else if (S.isAtPosition(b, C))
          return k = S, false;
      }), k;
    }, y.atPosition = function(b, C) {
      if (this.isAtPosition(b, C))
        return this._findChildAtPosition(b, C) || this;
    }, y._inferEndPosition = function() {
      this.last && this.last.source && this.last.source.end && (this.source = this.source || {}, this.source.end = this.source.end || {}, Object.assign(this.source.end, this.last.source.end));
    }, y.each = function(b) {
      this.lastEach || (this.lastEach = 0), this.indexes || (this.indexes = {}), this.lastEach++;
      var C = this.lastEach;
      if (this.indexes[C] = 0, !!this.length) {
        for (var k, S; this.indexes[C] < this.length && (k = this.indexes[C], S = b(this.at(k), k), S !== false); )
          this.indexes[C] += 1;
        if (delete this.indexes[C], S === false)
          return false;
      }
    }, y.walk = function(b) {
      return this.each(function(C, k) {
        var S = b(C, k);
        if (S !== false && C.length && (S = C.walk(b)), S === false)
          return false;
      });
    }, y.walkAttributes = function(b) {
      var C = this;
      return this.walk(function(k) {
        if (k.type === n.ATTRIBUTE)
          return b.call(C, k);
      });
    }, y.walkClasses = function(b) {
      var C = this;
      return this.walk(function(k) {
        if (k.type === n.CLASS)
          return b.call(C, k);
      });
    }, y.walkCombinators = function(b) {
      var C = this;
      return this.walk(function(k) {
        if (k.type === n.COMBINATOR)
          return b.call(C, k);
      });
    }, y.walkComments = function(b) {
      var C = this;
      return this.walk(function(k) {
        if (k.type === n.COMMENT)
          return b.call(C, k);
      });
    }, y.walkIds = function(b) {
      var C = this;
      return this.walk(function(k) {
        if (k.type === n.ID)
          return b.call(C, k);
      });
    }, y.walkNesting = function(b) {
      var C = this;
      return this.walk(function(k) {
        if (k.type === n.NESTING)
          return b.call(C, k);
      });
    }, y.walkPseudos = function(b) {
      var C = this;
      return this.walk(function(k) {
        if (k.type === n.PSEUDO)
          return b.call(C, k);
      });
    }, y.walkTags = function(b) {
      var C = this;
      return this.walk(function(k) {
        if (k.type === n.TAG)
          return b.call(C, k);
      });
    }, y.walkUniversals = function(b) {
      var C = this;
      return this.walk(function(k) {
        if (k.type === n.UNIVERSAL)
          return b.call(C, k);
      });
    }, y.split = function(b) {
      var C = this, k = [];
      return this.reduce(function(S, E, L) {
        var T = b.call(C, E);
        return k.push(E), T ? (S.push(k), k = []) : L === C.length - 1 && S.push(k), S;
      }, []);
    }, y.map = function(b) {
      return this.nodes.map(b);
    }, y.reduce = function(b, C) {
      return this.nodes.reduce(b, C);
    }, y.every = function(b) {
      return this.nodes.every(b);
    }, y.some = function(b) {
      return this.nodes.some(b);
    }, y.filter = function(b) {
      return this.nodes.filter(b);
    }, y.sort = function(b) {
      return this.nodes.sort(b);
    }, y.toString = function() {
      return this.map(String).join("");
    }, c(g, [{ key: "first", get: function() {
      return this.at(0);
    } }, { key: "last", get: function() {
      return this.at(this.length - 1);
    } }, { key: "length", get: function() {
      return this.nodes.length;
    } }]), g;
  }(r2.default);
  e.default = D, t.exports = e.default;
});
var ju = le((e, t) => {
  "use strict";
  e.__esModule = true, e.default = void 0;
  var r2 = i(La()), n = ut();
  function i(f) {
    return f && f.__esModule ? f : { default: f };
  }
  function a(f, c) {
    for (var p2 = 0; p2 < c.length; p2++) {
      var d = c[p2];
      d.enumerable = d.enumerable || false, d.configurable = true, "value" in d && (d.writable = true), Object.defineProperty(f, d.key, d);
    }
  }
  function o(f, c, p2) {
    return c && a(f.prototype, c), p2 && a(f, p2), f;
  }
  function u(f, c) {
    f.prototype = Object.create(c.prototype), f.prototype.constructor = f, s(f, c);
  }
  function s(f, c) {
    return s = Object.setPrototypeOf || function(p2, d) {
      return p2.__proto__ = d, p2;
    }, s(f, c);
  }
  var l = function(f) {
    u(c, f);
    function c(d) {
      var D;
      return D = f.call(this, d) || this, D.type = n.ROOT, D;
    }
    var p2 = c.prototype;
    return p2.toString = function() {
      var d = this.reduce(function(D, v) {
        return D.push(String(v)), D;
      }, []).join(",");
      return this.trailingComma ? d + "," : d;
    }, p2.error = function(d, D) {
      return this._error ? this._error(d, D) : new Error(d);
    }, o(c, [{ key: "errorGenerator", set: function(d) {
      this._error = d;
    } }]), c;
  }(r2.default);
  e.default = l, t.exports = e.default;
});
var zu = le((e, t) => {
  "use strict";
  e.__esModule = true, e.default = void 0;
  var r2 = i(La()), n = ut();
  function i(s) {
    return s && s.__esModule ? s : { default: s };
  }
  function a(s, l) {
    s.prototype = Object.create(l.prototype), s.prototype.constructor = s, o(s, l);
  }
  function o(s, l) {
    return o = Object.setPrototypeOf || function(f, c) {
      return f.__proto__ = c, f;
    }, o(s, l);
  }
  var u = function(s) {
    a(l, s);
    function l(f) {
      var c;
      return c = s.call(this, f) || this, c.type = n.SELECTOR, c;
    }
    return l;
  }(r2.default);
  e.default = u, t.exports = e.default;
});
var Ia = le((e, t) => {
  "use strict";
  var r2 = {}, n = r2.hasOwnProperty, i = function(l, f) {
    if (!l)
      return f;
    var c = {};
    for (var p2 in f)
      c[p2] = n.call(l, p2) ? l[p2] : f[p2];
    return c;
  }, a = /[ -,\.\/:-@\[-\^`\{-~]/, o = /[ -,\.\/:-@\[\]\^`\{-~]/, u = /(^|\\+)?(\\[A-F0-9]{1,6})\x20(?![a-fA-F0-9\x20])/g, s = function l(f, c) {
    c = i(c, l.options), c.quotes != "single" && c.quotes != "double" && (c.quotes = "single");
    for (var p2 = c.quotes == "double" ? '"' : "'", d = c.isIdentifier, D = f.charAt(0), v = "", g = 0, y = f.length; g < y; ) {
      var b = f.charAt(g++), C = b.charCodeAt(), k = void 0;
      if (C < 32 || C > 126) {
        if (C >= 55296 && C <= 56319 && g < y) {
          var S = f.charCodeAt(g++);
          (S & 64512) == 56320 ? C = ((C & 1023) << 10) + (S & 1023) + 65536 : g--;
        }
        k = "\\" + C.toString(16).toUpperCase() + " ";
      } else
        c.escapeEverything ? a.test(b) ? k = "\\" + b : k = "\\" + C.toString(16).toUpperCase() + " " : /[\t\n\f\r\x0B]/.test(b) ? k = "\\" + C.toString(16).toUpperCase() + " " : b == "\\" || !d && (b == '"' && p2 == b || b == "'" && p2 == b) || d && o.test(b) ? k = "\\" + b : k = b;
      v += k;
    }
    return d && (/^-[-\d]/.test(v) ? v = "\\-" + v.slice(1) : /\d/.test(D) && (v = "\\3" + D + " " + v.slice(1))), v = v.replace(u, function(E, L, T) {
      return L && L.length % 2 ? E : (L || "") + T;
    }), !d && c.wrap ? p2 + v + p2 : v;
  };
  s.options = { escapeEverything: false, isIdentifier: false, quotes: "single", wrap: false }, s.version = "3.0.0", t.exports = s;
});
var Vu = le((e, t) => {
  "use strict";
  e.__esModule = true, e.default = void 0;
  var r2 = o(Ia()), n = Jn(), i = o(pr()), a = ut();
  function o(p2) {
    return p2 && p2.__esModule ? p2 : { default: p2 };
  }
  function u(p2, d) {
    for (var D = 0; D < d.length; D++) {
      var v = d[D];
      v.enumerable = v.enumerable || false, v.configurable = true, "value" in v && (v.writable = true), Object.defineProperty(p2, v.key, v);
    }
  }
  function s(p2, d, D) {
    return d && u(p2.prototype, d), D && u(p2, D), p2;
  }
  function l(p2, d) {
    p2.prototype = Object.create(d.prototype), p2.prototype.constructor = p2, f(p2, d);
  }
  function f(p2, d) {
    return f = Object.setPrototypeOf || function(D, v) {
      return D.__proto__ = v, D;
    }, f(p2, d);
  }
  var c = function(p2) {
    l(d, p2);
    function d(v) {
      var g;
      return g = p2.call(this, v) || this, g.type = a.CLASS, g._constructed = true, g;
    }
    var D = d.prototype;
    return D.valueToString = function() {
      return "." + p2.prototype.valueToString.call(this);
    }, s(d, [{ key: "value", get: function() {
      return this._value;
    }, set: function(v) {
      if (this._constructed) {
        var g = (0, r2.default)(v, { isIdentifier: true });
        g !== v ? ((0, n.ensureObject)(this, "raws"), this.raws.value = g) : this.raws && delete this.raws.value;
      }
      this._value = v;
    } }]), d;
  }(i.default);
  e.default = c, t.exports = e.default;
});
var Hu = le((e, t) => {
  "use strict";
  e.__esModule = true, e.default = void 0;
  var r2 = i(pr()), n = ut();
  function i(s) {
    return s && s.__esModule ? s : { default: s };
  }
  function a(s, l) {
    s.prototype = Object.create(l.prototype), s.prototype.constructor = s, o(s, l);
  }
  function o(s, l) {
    return o = Object.setPrototypeOf || function(f, c) {
      return f.__proto__ = c, f;
    }, o(s, l);
  }
  var u = function(s) {
    a(l, s);
    function l(f) {
      var c;
      return c = s.call(this, f) || this, c.type = n.COMMENT, c;
    }
    return l;
  }(r2.default);
  e.default = u, t.exports = e.default;
});
var Xu = le((e, t) => {
  "use strict";
  e.__esModule = true, e.default = void 0;
  var r2 = i(pr()), n = ut();
  function i(s) {
    return s && s.__esModule ? s : { default: s };
  }
  function a(s, l) {
    s.prototype = Object.create(l.prototype), s.prototype.constructor = s, o(s, l);
  }
  function o(s, l) {
    return o = Object.setPrototypeOf || function(f, c) {
      return f.__proto__ = c, f;
    }, o(s, l);
  }
  var u = function(s) {
    a(l, s);
    function l(c) {
      var p2;
      return p2 = s.call(this, c) || this, p2.type = n.ID, p2;
    }
    var f = l.prototype;
    return f.valueToString = function() {
      return "#" + s.prototype.valueToString.call(this);
    }, l;
  }(r2.default);
  e.default = u, t.exports = e.default;
});
var Pa = le((e, t) => {
  "use strict";
  e.__esModule = true, e.default = void 0;
  var r2 = a(Ia()), n = Jn(), i = a(pr());
  function a(c) {
    return c && c.__esModule ? c : { default: c };
  }
  function o(c, p2) {
    for (var d = 0; d < p2.length; d++) {
      var D = p2[d];
      D.enumerable = D.enumerable || false, D.configurable = true, "value" in D && (D.writable = true), Object.defineProperty(c, D.key, D);
    }
  }
  function u(c, p2, d) {
    return p2 && o(c.prototype, p2), d && o(c, d), c;
  }
  function s(c, p2) {
    c.prototype = Object.create(p2.prototype), c.prototype.constructor = c, l(c, p2);
  }
  function l(c, p2) {
    return l = Object.setPrototypeOf || function(d, D) {
      return d.__proto__ = D, d;
    }, l(c, p2);
  }
  var f = function(c) {
    s(p2, c);
    function p2() {
      return c.apply(this, arguments) || this;
    }
    var d = p2.prototype;
    return d.qualifiedName = function(D) {
      return this.namespace ? this.namespaceString + "|" + D : D;
    }, d.valueToString = function() {
      return this.qualifiedName(c.prototype.valueToString.call(this));
    }, u(p2, [{ key: "namespace", get: function() {
      return this._namespace;
    }, set: function(D) {
      if (D === true || D === "*" || D === "&") {
        this._namespace = D, this.raws && delete this.raws.namespace;
        return;
      }
      var v = (0, r2.default)(D, { isIdentifier: true });
      this._namespace = D, v !== D ? ((0, n.ensureObject)(this, "raws"), this.raws.namespace = v) : this.raws && delete this.raws.namespace;
    } }, { key: "ns", get: function() {
      return this._namespace;
    }, set: function(D) {
      this.namespace = D;
    } }, { key: "namespaceString", get: function() {
      if (this.namespace) {
        var D = this.stringifyProperty("namespace");
        return D === true ? "" : D;
      } else
        return "";
    } }]), p2;
  }(i.default);
  e.default = f, t.exports = e.default;
});
var qu = le((e, t) => {
  "use strict";
  e.__esModule = true, e.default = void 0;
  var r2 = i(Pa()), n = ut();
  function i(s) {
    return s && s.__esModule ? s : { default: s };
  }
  function a(s, l) {
    s.prototype = Object.create(l.prototype), s.prototype.constructor = s, o(s, l);
  }
  function o(s, l) {
    return o = Object.setPrototypeOf || function(f, c) {
      return f.__proto__ = c, f;
    }, o(s, l);
  }
  var u = function(s) {
    a(l, s);
    function l(f) {
      var c;
      return c = s.call(this, f) || this, c.type = n.TAG, c;
    }
    return l;
  }(r2.default);
  e.default = u, t.exports = e.default;
});
var Yu = le((e, t) => {
  "use strict";
  e.__esModule = true, e.default = void 0;
  var r2 = i(pr()), n = ut();
  function i(s) {
    return s && s.__esModule ? s : { default: s };
  }
  function a(s, l) {
    s.prototype = Object.create(l.prototype), s.prototype.constructor = s, o(s, l);
  }
  function o(s, l) {
    return o = Object.setPrototypeOf || function(f, c) {
      return f.__proto__ = c, f;
    }, o(s, l);
  }
  var u = function(s) {
    a(l, s);
    function l(f) {
      var c;
      return c = s.call(this, f) || this, c.type = n.STRING, c;
    }
    return l;
  }(r2.default);
  e.default = u, t.exports = e.default;
});
var Zu = le((e, t) => {
  "use strict";
  e.__esModule = true, e.default = void 0;
  var r2 = i(La()), n = ut();
  function i(s) {
    return s && s.__esModule ? s : { default: s };
  }
  function a(s, l) {
    s.prototype = Object.create(l.prototype), s.prototype.constructor = s, o(s, l);
  }
  function o(s, l) {
    return o = Object.setPrototypeOf || function(f, c) {
      return f.__proto__ = c, f;
    }, o(s, l);
  }
  var u = function(s) {
    a(l, s);
    function l(c) {
      var p2;
      return p2 = s.call(this, c) || this, p2.type = n.PSEUDO, p2;
    }
    var f = l.prototype;
    return f.toString = function() {
      var c = this.length ? "(" + this.map(String).join(",") + ")" : "";
      return [this.rawSpaceBefore, this.stringifyProperty("value"), c, this.rawSpaceAfter].join("");
    }, l;
  }(r2.default);
  e.default = u, t.exports = e.default;
});
var Xv = le((e, t) => {
  t.exports = function(r2, n) {
    return function(...i) {
      return console.warn(n), r2(...i);
    };
  };
});
var Ju = le((e) => {
  "use strict";
  e.__esModule = true, e.unescapeValue = g, e.default = void 0;
  var t = o(Ia()), r2 = o($u()), n = o(Pa()), i = ut(), a;
  function o(S) {
    return S && S.__esModule ? S : { default: S };
  }
  function u(S, E) {
    for (var L = 0; L < E.length; L++) {
      var T = E[L];
      T.enumerable = T.enumerable || false, T.configurable = true, "value" in T && (T.writable = true), Object.defineProperty(S, T.key, T);
    }
  }
  function s(S, E, L) {
    return E && u(S.prototype, E), L && u(S, L), S;
  }
  function l(S, E) {
    S.prototype = Object.create(E.prototype), S.prototype.constructor = S, f(S, E);
  }
  function f(S, E) {
    return f = Object.setPrototypeOf || function(L, T) {
      return L.__proto__ = T, L;
    }, f(S, E);
  }
  var c = Xv(), p2 = /^('|")([^]*)\1$/, d = c(function() {
  }, "Assigning an attribute a value containing characters that might need to be escaped is deprecated. Call attribute.setValue() instead."), D = c(function() {
  }, "Assigning attr.quoted is deprecated and has no effect. Assign to attr.quoteMark instead."), v = c(function() {
  }, "Constructing an Attribute selector with a value without specifying quoteMark is deprecated. Note: The value should be unescaped now.");
  function g(S) {
    var E = false, L = null, T = S, U = T.match(p2);
    return U && (L = U[1], T = U[2]), T = (0, r2.default)(T), T !== S && (E = true), { deprecatedUsage: E, unescaped: T, quoteMark: L };
  }
  function y(S) {
    if (S.quoteMark !== void 0 || S.value === void 0)
      return S;
    v();
    var E = g(S.value), L = E.quoteMark, T = E.unescaped;
    return S.raws || (S.raws = {}), S.raws.value === void 0 && (S.raws.value = S.value), S.value = T, S.quoteMark = L, S;
  }
  var b = function(S) {
    l(E, S);
    function E(T) {
      var U;
      return T === void 0 && (T = {}), U = S.call(this, y(T)) || this, U.type = i.ATTRIBUTE, U.raws = U.raws || {}, Object.defineProperty(U.raws, "unquoted", { get: c(function() {
        return U.value;
      }, "attr.raws.unquoted is deprecated. Call attr.value instead."), set: c(function() {
        return U.value;
      }, "Setting attr.raws.unquoted is deprecated and has no effect. attr.value is unescaped by default now.") }), U._constructed = true, U;
    }
    var L = E.prototype;
    return L.getQuotedValue = function(T) {
      T === void 0 && (T = {});
      var U = this._determineQuoteMark(T), M = C[U], H = (0, t.default)(this._value, M);
      return H;
    }, L._determineQuoteMark = function(T) {
      return T.smart ? this.smartQuoteMark(T) : this.preferredQuoteMark(T);
    }, L.setValue = function(T, U) {
      U === void 0 && (U = {}), this._value = T, this._quoteMark = this._determineQuoteMark(U), this._syncRawValue();
    }, L.smartQuoteMark = function(T) {
      var U = this.value, M = U.replace(/[^']/g, "").length, H = U.replace(/[^"]/g, "").length;
      if (M + H === 0) {
        var q = (0, t.default)(U, { isIdentifier: true });
        if (q === U)
          return E.NO_QUOTE;
        var ee = this.preferredQuoteMark(T);
        if (ee === E.NO_QUOTE) {
          var A = this.quoteMark || T.quoteMark || E.DOUBLE_QUOTE, R = C[A], O = (0, t.default)(U, R);
          if (O.length < q.length)
            return A;
        }
        return ee;
      } else
        return H === M ? this.preferredQuoteMark(T) : H < M ? E.DOUBLE_QUOTE : E.SINGLE_QUOTE;
    }, L.preferredQuoteMark = function(T) {
      var U = T.preferCurrentQuoteMark ? this.quoteMark : T.quoteMark;
      return U === void 0 && (U = T.preferCurrentQuoteMark ? T.quoteMark : this.quoteMark), U === void 0 && (U = E.DOUBLE_QUOTE), U;
    }, L._syncRawValue = function() {
      var T = (0, t.default)(this._value, C[this.quoteMark]);
      T === this._value ? this.raws && delete this.raws.value : this.raws.value = T;
    }, L._handleEscapes = function(T, U) {
      if (this._constructed) {
        var M = (0, t.default)(U, { isIdentifier: true });
        M !== U ? this.raws[T] = M : delete this.raws[T];
      }
    }, L._spacesFor = function(T) {
      var U = { before: "", after: "" }, M = this.spaces[T] || {}, H = this.raws.spaces && this.raws.spaces[T] || {};
      return Object.assign(U, M, H);
    }, L._stringFor = function(T, U, M) {
      U === void 0 && (U = T), M === void 0 && (M = k);
      var H = this._spacesFor(U);
      return M(this.stringifyProperty(T), H);
    }, L.offsetOf = function(T) {
      var U = 1, M = this._spacesFor("attribute");
      if (U += M.before.length, T === "namespace" || T === "ns")
        return this.namespace ? U : -1;
      if (T === "attributeNS" || (U += this.namespaceString.length, this.namespace && (U += 1), T === "attribute"))
        return U;
      U += this.stringifyProperty("attribute").length, U += M.after.length;
      var H = this._spacesFor("operator");
      U += H.before.length;
      var q = this.stringifyProperty("operator");
      if (T === "operator")
        return q ? U : -1;
      U += q.length, U += H.after.length;
      var ee = this._spacesFor("value");
      U += ee.before.length;
      var A = this.stringifyProperty("value");
      if (T === "value")
        return A ? U : -1;
      U += A.length, U += ee.after.length;
      var R = this._spacesFor("insensitive");
      return U += R.before.length, T === "insensitive" && this.insensitive ? U : -1;
    }, L.toString = function() {
      var T = this, U = [this.rawSpaceBefore, "["];
      return U.push(this._stringFor("qualifiedAttribute", "attribute")), this.operator && (this.value || this.value === "") && (U.push(this._stringFor("operator")), U.push(this._stringFor("value")), U.push(this._stringFor("insensitiveFlag", "insensitive", function(M, H) {
        return M.length > 0 && !T.quoted && H.before.length === 0 && !(T.spaces.value && T.spaces.value.after) && (H.before = " "), k(M, H);
      }))), U.push("]"), U.push(this.rawSpaceAfter), U.join("");
    }, s(E, [{ key: "quoted", get: function() {
      var T = this.quoteMark;
      return T === "'" || T === '"';
    }, set: function(T) {
      D();
    } }, { key: "quoteMark", get: function() {
      return this._quoteMark;
    }, set: function(T) {
      if (!this._constructed) {
        this._quoteMark = T;
        return;
      }
      this._quoteMark !== T && (this._quoteMark = T, this._syncRawValue());
    } }, { key: "qualifiedAttribute", get: function() {
      return this.qualifiedName(this.raws.attribute || this.attribute);
    } }, { key: "insensitiveFlag", get: function() {
      return this.insensitive ? "i" : "";
    } }, { key: "value", get: function() {
      return this._value;
    }, set: function(T) {
      if (this._constructed) {
        var U = g(T), M = U.deprecatedUsage, H = U.unescaped, q = U.quoteMark;
        if (M && d(), H === this._value && q === this._quoteMark)
          return;
        this._value = H, this._quoteMark = q, this._syncRawValue();
      } else
        this._value = T;
    } }, { key: "attribute", get: function() {
      return this._attribute;
    }, set: function(T) {
      this._handleEscapes("attribute", T), this._attribute = T;
    } }]), E;
  }(n.default);
  e.default = b, b.NO_QUOTE = null, b.SINGLE_QUOTE = "'", b.DOUBLE_QUOTE = '"';
  var C = (a = { "'": { quotes: "single", wrap: true }, '"': { quotes: "double", wrap: true } }, a[null] = { isIdentifier: true }, a);
  function k(S, E) {
    return "" + E.before + S + E.after;
  }
});
var Ku = le((e, t) => {
  "use strict";
  e.__esModule = true, e.default = void 0;
  var r2 = i(Pa()), n = ut();
  function i(s) {
    return s && s.__esModule ? s : { default: s };
  }
  function a(s, l) {
    s.prototype = Object.create(l.prototype), s.prototype.constructor = s, o(s, l);
  }
  function o(s, l) {
    return o = Object.setPrototypeOf || function(f, c) {
      return f.__proto__ = c, f;
    }, o(s, l);
  }
  var u = function(s) {
    a(l, s);
    function l(f) {
      var c;
      return c = s.call(this, f) || this, c.type = n.UNIVERSAL, c.value = "*", c;
    }
    return l;
  }(r2.default);
  e.default = u, t.exports = e.default;
});
var Qu = le((e, t) => {
  "use strict";
  e.__esModule = true, e.default = void 0;
  var r2 = i(pr()), n = ut();
  function i(s) {
    return s && s.__esModule ? s : { default: s };
  }
  function a(s, l) {
    s.prototype = Object.create(l.prototype), s.prototype.constructor = s, o(s, l);
  }
  function o(s, l) {
    return o = Object.setPrototypeOf || function(f, c) {
      return f.__proto__ = c, f;
    }, o(s, l);
  }
  var u = function(s) {
    a(l, s);
    function l(f) {
      var c;
      return c = s.call(this, f) || this, c.type = n.COMBINATOR, c;
    }
    return l;
  }(r2.default);
  e.default = u, t.exports = e.default;
});
var el = le((e, t) => {
  "use strict";
  e.__esModule = true, e.default = void 0;
  var r2 = i(pr()), n = ut();
  function i(s) {
    return s && s.__esModule ? s : { default: s };
  }
  function a(s, l) {
    s.prototype = Object.create(l.prototype), s.prototype.constructor = s, o(s, l);
  }
  function o(s, l) {
    return o = Object.setPrototypeOf || function(f, c) {
      return f.__proto__ = c, f;
    }, o(s, l);
  }
  var u = function(s) {
    a(l, s);
    function l(f) {
      var c;
      return c = s.call(this, f) || this, c.type = n.NESTING, c.value = "&", c;
    }
    return l;
  }(r2.default);
  e.default = u, t.exports = e.default;
});
var qv = le((e, t) => {
  "use strict";
  e.__esModule = true, e.default = r2;
  function r2(n) {
    return n.sort(function(i, a) {
      return i - a;
    });
  }
  t.exports = e.default;
});
var tl = le((e) => {
  "use strict";
  e.__esModule = true, e.combinator = e.word = e.comment = e.str = e.tab = e.newline = e.feed = e.cr = e.backslash = e.bang = e.slash = e.doubleQuote = e.singleQuote = e.space = e.greaterThan = e.pipe = e.equals = e.plus = e.caret = e.tilde = e.dollar = e.closeSquare = e.openSquare = e.closeParenthesis = e.openParenthesis = e.semicolon = e.colon = e.comma = e.at = e.asterisk = e.ampersand = void 0;
  var t = 38;
  e.ampersand = t;
  var r2 = 42;
  e.asterisk = r2;
  var n = 64;
  e.at = n;
  var i = 44;
  e.comma = i;
  var a = 58;
  e.colon = a;
  var o = 59;
  e.semicolon = o;
  var u = 40;
  e.openParenthesis = u;
  var s = 41;
  e.closeParenthesis = s;
  var l = 91;
  e.openSquare = l;
  var f = 93;
  e.closeSquare = f;
  var c = 36;
  e.dollar = c;
  var p2 = 126;
  e.tilde = p2;
  var d = 94;
  e.caret = d;
  var D = 43;
  e.plus = D;
  var v = 61;
  e.equals = v;
  var g = 124;
  e.pipe = g;
  var y = 62;
  e.greaterThan = y;
  var b = 32;
  e.space = b;
  var C = 39;
  e.singleQuote = C;
  var k = 34;
  e.doubleQuote = k;
  var S = 47;
  e.slash = S;
  var E = 33;
  e.bang = E;
  var L = 92;
  e.backslash = L;
  var T = 13;
  e.cr = T;
  var U = 12;
  e.feed = U;
  var M = 10;
  e.newline = M;
  var H = 9;
  e.tab = H;
  var q = C;
  e.str = q;
  var ee = -1;
  e.comment = ee;
  var A = -2;
  e.word = A;
  var R = -3;
  e.combinator = R;
});
var Yv = le((e) => {
  "use strict";
  e.__esModule = true, e.default = D, e.FIELDS = void 0;
  var t = a(tl()), r2, n;
  function i() {
    if (typeof WeakMap != "function")
      return null;
    var v = /* @__PURE__ */ new WeakMap();
    return i = function() {
      return v;
    }, v;
  }
  function a(v) {
    if (v && v.__esModule)
      return v;
    if (v === null || typeof v != "object" && typeof v != "function")
      return { default: v };
    var g = i();
    if (g && g.has(v))
      return g.get(v);
    var y = {}, b = Object.defineProperty && Object.getOwnPropertyDescriptor;
    for (var C in v)
      if (Object.prototype.hasOwnProperty.call(v, C)) {
        var k = b ? Object.getOwnPropertyDescriptor(v, C) : null;
        k && (k.get || k.set) ? Object.defineProperty(y, C, k) : y[C] = v[C];
      }
    return y.default = v, g && g.set(v, y), y;
  }
  var o = (r2 = {}, r2[t.tab] = true, r2[t.newline] = true, r2[t.cr] = true, r2[t.feed] = true, r2), u = (n = {}, n[t.space] = true, n[t.tab] = true, n[t.newline] = true, n[t.cr] = true, n[t.feed] = true, n[t.ampersand] = true, n[t.asterisk] = true, n[t.bang] = true, n[t.comma] = true, n[t.colon] = true, n[t.semicolon] = true, n[t.openParenthesis] = true, n[t.closeParenthesis] = true, n[t.openSquare] = true, n[t.closeSquare] = true, n[t.singleQuote] = true, n[t.doubleQuote] = true, n[t.plus] = true, n[t.pipe] = true, n[t.tilde] = true, n[t.greaterThan] = true, n[t.equals] = true, n[t.dollar] = true, n[t.caret] = true, n[t.slash] = true, n), s = {}, l = "0123456789abcdefABCDEF";
  for (f = 0; f < l.length; f++)
    s[l.charCodeAt(f)] = true;
  var f;
  function c(v, g) {
    var y = g, b;
    do {
      if (b = v.charCodeAt(y), u[b])
        return y - 1;
      b === t.backslash ? y = p2(v, y) + 1 : y++;
    } while (y < v.length);
    return y - 1;
  }
  function p2(v, g) {
    var y = g, b = v.charCodeAt(y + 1);
    if (!o[b])
      if (s[b]) {
        var C = 0;
        do
          y++, C++, b = v.charCodeAt(y + 1);
        while (s[b] && C < 6);
        C < 6 && b === t.space && y++;
      } else
        y++;
    return y;
  }
  var d = { TYPE: 0, START_LINE: 1, START_COL: 2, END_LINE: 3, END_COL: 4, START_POS: 5, END_POS: 6 };
  e.FIELDS = d;
  function D(v) {
    var g = [], y = v.css.valueOf(), b = y, C = b.length, k = -1, S = 1, E = 0, L = 0, T, U, M, H, q, ee, A, R, O, Y, Z, te, ie;
    function B(z, _) {
      if (v.safe)
        y += _, O = y.length - 1;
      else
        throw v.error("Unclosed " + z, S, E - k, E);
    }
    for (; E < C; ) {
      switch (T = y.charCodeAt(E), T === t.newline && (k = E, S += 1), T) {
        case t.space:
        case t.tab:
        case t.newline:
        case t.cr:
        case t.feed:
          O = E;
          do
            O += 1, T = y.charCodeAt(O), T === t.newline && (k = O, S += 1);
          while (T === t.space || T === t.newline || T === t.tab || T === t.cr || T === t.feed);
          ie = t.space, H = S, M = O - k - 1, L = O;
          break;
        case t.plus:
        case t.greaterThan:
        case t.tilde:
        case t.pipe:
          O = E;
          do
            O += 1, T = y.charCodeAt(O);
          while (T === t.plus || T === t.greaterThan || T === t.tilde || T === t.pipe);
          ie = t.combinator, H = S, M = E - k, L = O;
          break;
        case t.asterisk:
        case t.ampersand:
        case t.bang:
        case t.comma:
        case t.equals:
        case t.dollar:
        case t.caret:
        case t.openSquare:
        case t.closeSquare:
        case t.colon:
        case t.semicolon:
        case t.openParenthesis:
        case t.closeParenthesis:
          O = E, ie = T, H = S, M = E - k, L = O + 1;
          break;
        case t.singleQuote:
        case t.doubleQuote:
          te = T === t.singleQuote ? "'" : '"', O = E;
          do
            for (q = false, O = y.indexOf(te, O + 1), O === -1 && B("quote", te), ee = O; y.charCodeAt(ee - 1) === t.backslash; )
              ee -= 1, q = !q;
          while (q);
          ie = t.str, H = S, M = E - k, L = O + 1;
          break;
        default:
          T === t.slash && y.charCodeAt(E + 1) === t.asterisk ? (O = y.indexOf("*/", E + 2) + 1, O === 0 && B("comment", "*/"), U = y.slice(E, O + 1), R = U.split(`
`), A = R.length - 1, A > 0 ? (Y = S + A, Z = O - R[A].length) : (Y = S, Z = k), ie = t.comment, S = Y, H = Y, M = O - Z) : T === t.slash ? (O = E, ie = T, H = S, M = E - k, L = O + 1) : (O = c(y, E), ie = t.word, H = S, M = O - k), L = O + 1;
          break;
      }
      g.push([ie, S, E - k, H, M, E, L]), Z && (k = Z, Z = null), E = L;
    }
    return g;
  }
});
var Zv = le((e, t) => {
  "use strict";
  e.__esModule = true, e.default = void 0;
  var r2 = L(ju()), n = L(zu()), i = L(Vu()), a = L(Hu()), o = L(Xu()), u = L(qu()), s = L(Yu()), l = L(Zu()), f = E(Ju()), c = L(Ku()), p2 = L(Qu()), d = L(el()), D = L(qv()), v = E(Yv()), g = E(tl()), y = E(ut()), b = Jn(), C, k;
  function S() {
    if (typeof WeakMap != "function")
      return null;
    var B = /* @__PURE__ */ new WeakMap();
    return S = function() {
      return B;
    }, B;
  }
  function E(B) {
    if (B && B.__esModule)
      return B;
    if (B === null || typeof B != "object" && typeof B != "function")
      return { default: B };
    var z = S();
    if (z && z.has(B))
      return z.get(B);
    var _ = {}, N = Object.defineProperty && Object.getOwnPropertyDescriptor;
    for (var ae in B)
      if (Object.prototype.hasOwnProperty.call(B, ae)) {
        var W = N ? Object.getOwnPropertyDescriptor(B, ae) : null;
        W && (W.get || W.set) ? Object.defineProperty(_, ae, W) : _[ae] = B[ae];
      }
    return _.default = B, z && z.set(B, _), _;
  }
  function L(B) {
    return B && B.__esModule ? B : { default: B };
  }
  function T(B, z) {
    for (var _ = 0; _ < z.length; _++) {
      var N = z[_];
      N.enumerable = N.enumerable || false, N.configurable = true, "value" in N && (N.writable = true), Object.defineProperty(B, N.key, N);
    }
  }
  function U(B, z, _) {
    return z && T(B.prototype, z), _ && T(B, _), B;
  }
  var M = (C = {}, C[g.space] = true, C[g.cr] = true, C[g.feed] = true, C[g.newline] = true, C[g.tab] = true, C), H = Object.assign({}, M, (k = {}, k[g.comment] = true, k));
  function q(B) {
    return { line: B[v.FIELDS.START_LINE], column: B[v.FIELDS.START_COL] };
  }
  function ee(B) {
    return { line: B[v.FIELDS.END_LINE], column: B[v.FIELDS.END_COL] };
  }
  function A(B, z, _, N) {
    return { start: { line: B, column: z }, end: { line: _, column: N } };
  }
  function R(B) {
    return A(B[v.FIELDS.START_LINE], B[v.FIELDS.START_COL], B[v.FIELDS.END_LINE], B[v.FIELDS.END_COL]);
  }
  function O(B, z) {
    if (B)
      return A(B[v.FIELDS.START_LINE], B[v.FIELDS.START_COL], z[v.FIELDS.END_LINE], z[v.FIELDS.END_COL]);
  }
  function Y(B, z) {
    var _ = B[z];
    if (typeof _ == "string")
      return _.indexOf("\\") !== -1 && ((0, b.ensureObject)(B, "raws"), B[z] = (0, b.unesc)(_), B.raws[z] === void 0 && (B.raws[z] = _)), B;
  }
  function Z(B, z) {
    for (var _ = -1, N = []; (_ = B.indexOf(z, _ + 1)) !== -1; )
      N.push(_);
    return N;
  }
  function te() {
    var B = Array.prototype.concat.apply([], arguments);
    return B.filter(function(z, _) {
      return _ === B.indexOf(z);
    });
  }
  var ie = function() {
    function B(_, N) {
      N === void 0 && (N = {}), this.rule = _, this.options = Object.assign({ lossy: false, safe: false }, N), this.position = 0, this.css = typeof this.rule == "string" ? this.rule : this.rule.selector, this.tokens = (0, v.default)({ css: this.css, error: this._errorGenerator(), safe: this.options.safe });
      var ae = O(this.tokens[0], this.tokens[this.tokens.length - 1]);
      this.root = new r2.default({ source: ae }), this.root.errorGenerator = this._errorGenerator();
      var W = new n.default({ source: { start: { line: 1, column: 1 } } });
      this.root.append(W), this.current = W, this.loop();
    }
    var z = B.prototype;
    return z._errorGenerator = function() {
      var _ = this;
      return function(N, ae) {
        return typeof _.rule == "string" ? new Error(N) : _.rule.error(N, ae);
      };
    }, z.attribute = function() {
      var _ = [], N = this.currToken;
      for (this.position++; this.position < this.tokens.length && this.currToken[v.FIELDS.TYPE] !== g.closeSquare; )
        _.push(this.currToken), this.position++;
      if (this.currToken[v.FIELDS.TYPE] !== g.closeSquare)
        return this.expected("closing square bracket", this.currToken[v.FIELDS.START_POS]);
      var ae = _.length, W = { source: A(N[1], N[2], this.currToken[3], this.currToken[4]), sourceIndex: N[v.FIELDS.START_POS] };
      if (ae === 1 && !~[g.word].indexOf(_[0][v.FIELDS.TYPE]))
        return this.expected("attribute", _[0][v.FIELDS.START_POS]);
      for (var fe = 0, ce = "", ge = "", pe = null, xe = false; fe < ae; ) {
        var _e = _[fe], he = this.content(_e), ye = _[fe + 1];
        switch (_e[v.FIELDS.TYPE]) {
          case g.space:
            if (xe = true, this.options.lossy)
              break;
            if (pe) {
              (0, b.ensureObject)(W, "spaces", pe);
              var Ge = W.spaces[pe].after || "";
              W.spaces[pe].after = Ge + he;
              var tt = (0, b.getProp)(W, "raws", "spaces", pe, "after") || null;
              tt && (W.raws.spaces[pe].after = tt + he);
            } else
              ce = ce + he, ge = ge + he;
            break;
          case g.asterisk:
            if (ye[v.FIELDS.TYPE] === g.equals)
              W.operator = he, pe = "operator";
            else if ((!W.namespace || pe === "namespace" && !xe) && ye) {
              ce && ((0, b.ensureObject)(W, "spaces", "attribute"), W.spaces.attribute.before = ce, ce = ""), ge && ((0, b.ensureObject)(W, "raws", "spaces", "attribute"), W.raws.spaces.attribute.before = ce, ge = ""), W.namespace = (W.namespace || "") + he;
              var We = (0, b.getProp)(W, "raws", "namespace") || null;
              We && (W.raws.namespace += he), pe = "namespace";
            }
            xe = false;
            break;
          case g.dollar:
            if (pe === "value") {
              var Be = (0, b.getProp)(W, "raws", "value");
              W.value += "$", Be && (W.raws.value = Be + "$");
              break;
            }
          case g.caret:
            ye[v.FIELDS.TYPE] === g.equals && (W.operator = he, pe = "operator"), xe = false;
            break;
          case g.combinator:
            if (he === "~" && ye[v.FIELDS.TYPE] === g.equals && (W.operator = he, pe = "operator"), he !== "|") {
              xe = false;
              break;
            }
            ye[v.FIELDS.TYPE] === g.equals ? (W.operator = he, pe = "operator") : !W.namespace && !W.attribute && (W.namespace = true), xe = false;
            break;
          case g.word:
            if (ye && this.content(ye) === "|" && _[fe + 2] && _[fe + 2][v.FIELDS.TYPE] !== g.equals && !W.operator && !W.namespace)
              W.namespace = he, pe = "namespace";
            else if (!W.attribute || pe === "attribute" && !xe) {
              ce && ((0, b.ensureObject)(W, "spaces", "attribute"), W.spaces.attribute.before = ce, ce = ""), ge && ((0, b.ensureObject)(W, "raws", "spaces", "attribute"), W.raws.spaces.attribute.before = ge, ge = ""), W.attribute = (W.attribute || "") + he;
              var He = (0, b.getProp)(W, "raws", "attribute") || null;
              He && (W.raws.attribute += he), pe = "attribute";
            } else if (!W.value && W.value !== "" || pe === "value" && !xe) {
              var rt = (0, b.unesc)(he), nt = (0, b.getProp)(W, "raws", "value") || "", it = W.value || "";
              W.value = it + rt, W.quoteMark = null, (rt !== he || nt) && ((0, b.ensureObject)(W, "raws"), W.raws.value = (nt || it) + he), pe = "value";
            } else {
              var at = he === "i" || he === "I";
              (W.value || W.value === "") && (W.quoteMark || xe) ? (W.insensitive = at, (!at || he === "I") && ((0, b.ensureObject)(W, "raws"), W.raws.insensitiveFlag = he), pe = "insensitive", ce && ((0, b.ensureObject)(W, "spaces", "insensitive"), W.spaces.insensitive.before = ce, ce = ""), ge && ((0, b.ensureObject)(W, "raws", "spaces", "insensitive"), W.raws.spaces.insensitive.before = ge, ge = "")) : (W.value || W.value === "") && (pe = "value", W.value += he, W.raws.value && (W.raws.value += he));
            }
            xe = false;
            break;
          case g.str:
            if (!W.attribute || !W.operator)
              return this.error("Expected an attribute followed by an operator preceding the string.", { index: _e[v.FIELDS.START_POS] });
            var Xe = (0, f.unescapeValue)(he), Ct = Xe.unescaped, Dt = Xe.quoteMark;
            W.value = Ct, W.quoteMark = Dt, pe = "value", (0, b.ensureObject)(W, "raws"), W.raws.value = he, xe = false;
            break;
          case g.equals:
            if (!W.attribute)
              return this.expected("attribute", _e[v.FIELDS.START_POS], he);
            if (W.value)
              return this.error('Unexpected "=" found; an operator was already defined.', { index: _e[v.FIELDS.START_POS] });
            W.operator = W.operator ? W.operator + he : he, pe = "operator", xe = false;
            break;
          case g.comment:
            if (pe)
              if (xe || ye && ye[v.FIELDS.TYPE] === g.space || pe === "insensitive") {
                var ft = (0, b.getProp)(W, "spaces", pe, "after") || "", ct = (0, b.getProp)(W, "raws", "spaces", pe, "after") || ft;
                (0, b.ensureObject)(W, "raws", "spaces", pe), W.raws.spaces[pe].after = ct + he;
              } else {
                var zt = W[pe] || "", lt = (0, b.getProp)(W, "raws", pe) || zt;
                (0, b.ensureObject)(W, "raws"), W.raws[pe] = lt + he;
              }
            else
              ge = ge + he;
            break;
          default:
            return this.error('Unexpected "' + he + '" found.', { index: _e[v.FIELDS.START_POS] });
        }
        fe++;
      }
      Y(W, "attribute"), Y(W, "namespace"), this.newNode(new f.default(W)), this.position++;
    }, z.parseWhitespaceEquivalentTokens = function(_) {
      _ < 0 && (_ = this.tokens.length);
      var N = this.position, ae = [], W = "", fe = void 0;
      do
        if (M[this.currToken[v.FIELDS.TYPE]])
          this.options.lossy || (W += this.content());
        else if (this.currToken[v.FIELDS.TYPE] === g.comment) {
          var ce = {};
          W && (ce.before = W, W = ""), fe = new a.default({ value: this.content(), source: R(this.currToken), sourceIndex: this.currToken[v.FIELDS.START_POS], spaces: ce }), ae.push(fe);
        }
      while (++this.position < _);
      if (W) {
        if (fe)
          fe.spaces.after = W;
        else if (!this.options.lossy) {
          var ge = this.tokens[N], pe = this.tokens[this.position - 1];
          ae.push(new s.default({ value: "", source: A(ge[v.FIELDS.START_LINE], ge[v.FIELDS.START_COL], pe[v.FIELDS.END_LINE], pe[v.FIELDS.END_COL]), sourceIndex: ge[v.FIELDS.START_POS], spaces: { before: W, after: "" } }));
        }
      }
      return ae;
    }, z.convertWhitespaceNodesToSpace = function(_, N) {
      var ae = this;
      N === void 0 && (N = false);
      var W = "", fe = "";
      _.forEach(function(ge) {
        var pe = ae.lossySpace(ge.spaces.before, N), xe = ae.lossySpace(ge.rawSpaceBefore, N);
        W += pe + ae.lossySpace(ge.spaces.after, N && pe.length === 0), fe += pe + ge.value + ae.lossySpace(ge.rawSpaceAfter, N && xe.length === 0);
      }), fe === W && (fe = void 0);
      var ce = { space: W, rawSpace: fe };
      return ce;
    }, z.isNamedCombinator = function(_) {
      return _ === void 0 && (_ = this.position), this.tokens[_ + 0] && this.tokens[_ + 0][v.FIELDS.TYPE] === g.slash && this.tokens[_ + 1] && this.tokens[_ + 1][v.FIELDS.TYPE] === g.word && this.tokens[_ + 2] && this.tokens[_ + 2][v.FIELDS.TYPE] === g.slash;
    }, z.namedCombinator = function() {
      if (this.isNamedCombinator()) {
        var _ = this.content(this.tokens[this.position + 1]), N = (0, b.unesc)(_).toLowerCase(), ae = {};
        N !== _ && (ae.value = "/" + _ + "/");
        var W = new p2.default({ value: "/" + N + "/", source: A(this.currToken[v.FIELDS.START_LINE], this.currToken[v.FIELDS.START_COL], this.tokens[this.position + 2][v.FIELDS.END_LINE], this.tokens[this.position + 2][v.FIELDS.END_COL]), sourceIndex: this.currToken[v.FIELDS.START_POS], raws: ae });
        return this.position = this.position + 3, W;
      } else
        this.unexpected();
    }, z.combinator = function() {
      var _ = this;
      if (this.content() === "|")
        return this.namespace();
      var N = this.locateNextMeaningfulToken(this.position);
      if (N < 0 || this.tokens[N][v.FIELDS.TYPE] === g.comma) {
        var ae = this.parseWhitespaceEquivalentTokens(N);
        if (ae.length > 0) {
          var W = this.current.last;
          if (W) {
            var fe = this.convertWhitespaceNodesToSpace(ae), ce = fe.space, ge = fe.rawSpace;
            ge !== void 0 && (W.rawSpaceAfter += ge), W.spaces.after += ce;
          } else
            ae.forEach(function(nt) {
              return _.newNode(nt);
            });
        }
        return;
      }
      var pe = this.currToken, xe = void 0;
      N > this.position && (xe = this.parseWhitespaceEquivalentTokens(N));
      var _e;
      if (this.isNamedCombinator() ? _e = this.namedCombinator() : this.currToken[v.FIELDS.TYPE] === g.combinator ? (_e = new p2.default({ value: this.content(), source: R(this.currToken), sourceIndex: this.currToken[v.FIELDS.START_POS] }), this.position++) : M[this.currToken[v.FIELDS.TYPE]] || xe || this.unexpected(), _e) {
        if (xe) {
          var he = this.convertWhitespaceNodesToSpace(xe), ye = he.space, Ge = he.rawSpace;
          _e.spaces.before = ye, _e.rawSpaceBefore = Ge;
        }
      } else {
        var tt = this.convertWhitespaceNodesToSpace(xe, true), We = tt.space, Be = tt.rawSpace;
        Be || (Be = We);
        var He = {}, rt = { spaces: {} };
        We.endsWith(" ") && Be.endsWith(" ") ? (He.before = We.slice(0, We.length - 1), rt.spaces.before = Be.slice(0, Be.length - 1)) : We.startsWith(" ") && Be.startsWith(" ") ? (He.after = We.slice(1), rt.spaces.after = Be.slice(1)) : rt.value = Be, _e = new p2.default({ value: " ", source: O(pe, this.tokens[this.position - 1]), sourceIndex: pe[v.FIELDS.START_POS], spaces: He, raws: rt });
      }
      return this.currToken && this.currToken[v.FIELDS.TYPE] === g.space && (_e.spaces.after = this.optionalSpace(this.content()), this.position++), this.newNode(_e);
    }, z.comma = function() {
      if (this.position === this.tokens.length - 1) {
        this.root.trailingComma = true, this.position++;
        return;
      }
      this.current._inferEndPosition();
      var _ = new n.default({ source: { start: q(this.tokens[this.position + 1]) } });
      this.current.parent.append(_), this.current = _, this.position++;
    }, z.comment = function() {
      var _ = this.currToken;
      this.newNode(new a.default({ value: this.content(), source: R(_), sourceIndex: _[v.FIELDS.START_POS] })), this.position++;
    }, z.error = function(_, N) {
      throw this.root.error(_, N);
    }, z.missingBackslash = function() {
      return this.error("Expected a backslash preceding the semicolon.", { index: this.currToken[v.FIELDS.START_POS] });
    }, z.missingParenthesis = function() {
      return this.expected("opening parenthesis", this.currToken[v.FIELDS.START_POS]);
    }, z.missingSquareBracket = function() {
      return this.expected("opening square bracket", this.currToken[v.FIELDS.START_POS]);
    }, z.unexpected = function() {
      return this.error("Unexpected '" + this.content() + "'. Escaping special characters with \\ may help.", this.currToken[v.FIELDS.START_POS]);
    }, z.namespace = function() {
      var _ = this.prevToken && this.content(this.prevToken) || true;
      if (this.nextToken[v.FIELDS.TYPE] === g.word)
        return this.position++, this.word(_);
      if (this.nextToken[v.FIELDS.TYPE] === g.asterisk)
        return this.position++, this.universal(_);
    }, z.nesting = function() {
      if (this.nextToken) {
        var _ = this.content(this.nextToken);
        if (_ === "|") {
          this.position++;
          return;
        }
      }
      var N = this.currToken;
      this.newNode(new d.default({ value: this.content(), source: R(N), sourceIndex: N[v.FIELDS.START_POS] })), this.position++;
    }, z.parentheses = function() {
      var _ = this.current.last, N = 1;
      if (this.position++, _ && _.type === y.PSEUDO) {
        var ae = new n.default({ source: { start: q(this.tokens[this.position - 1]) } }), W = this.current;
        for (_.append(ae), this.current = ae; this.position < this.tokens.length && N; )
          this.currToken[v.FIELDS.TYPE] === g.openParenthesis && N++, this.currToken[v.FIELDS.TYPE] === g.closeParenthesis && N--, N ? this.parse() : (this.current.source.end = ee(this.currToken), this.current.parent.source.end = ee(this.currToken), this.position++);
        this.current = W;
      } else {
        for (var fe = this.currToken, ce = "(", ge; this.position < this.tokens.length && N; )
          this.currToken[v.FIELDS.TYPE] === g.openParenthesis && N++, this.currToken[v.FIELDS.TYPE] === g.closeParenthesis && N--, ge = this.currToken, ce += this.parseParenthesisToken(this.currToken), this.position++;
        _ ? _.appendToPropertyAndEscape("value", ce, ce) : this.newNode(new s.default({ value: ce, source: A(fe[v.FIELDS.START_LINE], fe[v.FIELDS.START_COL], ge[v.FIELDS.END_LINE], ge[v.FIELDS.END_COL]), sourceIndex: fe[v.FIELDS.START_POS] }));
      }
      if (N)
        return this.expected("closing parenthesis", this.currToken[v.FIELDS.START_POS]);
    }, z.pseudo = function() {
      for (var _ = this, N = "", ae = this.currToken; this.currToken && this.currToken[v.FIELDS.TYPE] === g.colon; )
        N += this.content(), this.position++;
      if (!this.currToken)
        return this.expected(["pseudo-class", "pseudo-element"], this.position - 1);
      if (this.currToken[v.FIELDS.TYPE] === g.word)
        this.splitWord(false, function(W, fe) {
          N += W, _.newNode(new l.default({ value: N, source: O(ae, _.currToken), sourceIndex: ae[v.FIELDS.START_POS] })), fe > 1 && _.nextToken && _.nextToken[v.FIELDS.TYPE] === g.openParenthesis && _.error("Misplaced parenthesis.", { index: _.nextToken[v.FIELDS.START_POS] });
        });
      else
        return this.expected(["pseudo-class", "pseudo-element"], this.currToken[v.FIELDS.START_POS]);
    }, z.space = function() {
      var _ = this.content();
      this.position === 0 || this.prevToken[v.FIELDS.TYPE] === g.comma || this.prevToken[v.FIELDS.TYPE] === g.openParenthesis || this.current.nodes.every(function(N) {
        return N.type === "comment";
      }) ? (this.spaces = this.optionalSpace(_), this.position++) : this.position === this.tokens.length - 1 || this.nextToken[v.FIELDS.TYPE] === g.comma || this.nextToken[v.FIELDS.TYPE] === g.closeParenthesis ? (this.current.last.spaces.after = this.optionalSpace(_), this.position++) : this.combinator();
    }, z.string = function() {
      var _ = this.currToken;
      this.newNode(new s.default({ value: this.content(), source: R(_), sourceIndex: _[v.FIELDS.START_POS] })), this.position++;
    }, z.universal = function(_) {
      var N = this.nextToken;
      if (N && this.content(N) === "|")
        return this.position++, this.namespace();
      var ae = this.currToken;
      this.newNode(new c.default({ value: this.content(), source: R(ae), sourceIndex: ae[v.FIELDS.START_POS] }), _), this.position++;
    }, z.splitWord = function(_, N) {
      for (var ae = this, W = this.nextToken, fe = this.content(); W && ~[g.dollar, g.caret, g.equals, g.word].indexOf(W[v.FIELDS.TYPE]); ) {
        this.position++;
        var ce = this.content();
        if (fe += ce, ce.lastIndexOf("\\") === ce.length - 1) {
          var ge = this.nextToken;
          ge && ge[v.FIELDS.TYPE] === g.space && (fe += this.requiredSpace(this.content(ge)), this.position++);
        }
        W = this.nextToken;
      }
      var pe = Z(fe, ".").filter(function(ye) {
        var Ge = fe[ye - 1] === "\\", tt = /^\d+\.\d+%$/.test(fe);
        return !Ge && !tt;
      }), xe = Z(fe, "#").filter(function(ye) {
        return fe[ye - 1] !== "\\";
      }), _e = Z(fe, "#{");
      _e.length && (xe = xe.filter(function(ye) {
        return !~_e.indexOf(ye);
      }));
      var he = (0, D.default)(te([0].concat(pe, xe)));
      he.forEach(function(ye, Ge) {
        var tt = he[Ge + 1] || fe.length, We = fe.slice(ye, tt);
        if (Ge === 0 && N)
          return N.call(ae, We, he.length);
        var Be, He = ae.currToken, rt = He[v.FIELDS.START_POS] + he[Ge], nt = A(He[1], He[2] + ye, He[3], He[2] + (tt - 1));
        if (~pe.indexOf(ye)) {
          var it = { value: We.slice(1), source: nt, sourceIndex: rt };
          Be = new i.default(Y(it, "value"));
        } else if (~xe.indexOf(ye)) {
          var at = { value: We.slice(1), source: nt, sourceIndex: rt };
          Be = new o.default(Y(at, "value"));
        } else {
          var Xe = { value: We, source: nt, sourceIndex: rt };
          Y(Xe, "value"), Be = new u.default(Xe);
        }
        ae.newNode(Be, _), _ = null;
      }), this.position++;
    }, z.word = function(_) {
      var N = this.nextToken;
      return N && this.content(N) === "|" ? (this.position++, this.namespace()) : this.splitWord(_);
    }, z.loop = function() {
      for (; this.position < this.tokens.length; )
        this.parse(true);
      return this.current._inferEndPosition(), this.root;
    }, z.parse = function(_) {
      switch (this.currToken[v.FIELDS.TYPE]) {
        case g.space:
          this.space();
          break;
        case g.comment:
          this.comment();
          break;
        case g.openParenthesis:
          this.parentheses();
          break;
        case g.closeParenthesis:
          _ && this.missingParenthesis();
          break;
        case g.openSquare:
          this.attribute();
          break;
        case g.dollar:
        case g.caret:
        case g.equals:
        case g.word:
          this.word();
          break;
        case g.colon:
          this.pseudo();
          break;
        case g.comma:
          this.comma();
          break;
        case g.asterisk:
          this.universal();
          break;
        case g.ampersand:
          this.nesting();
          break;
        case g.slash:
        case g.combinator:
          this.combinator();
          break;
        case g.str:
          this.string();
          break;
        case g.closeSquare:
          this.missingSquareBracket();
        case g.semicolon:
          this.missingBackslash();
        default:
          this.unexpected();
      }
    }, z.expected = function(_, N, ae) {
      if (Array.isArray(_)) {
        var W = _.pop();
        _ = _.join(", ") + " or " + W;
      }
      var fe = /^[aeiou]/.test(_[0]) ? "an" : "a";
      return ae ? this.error("Expected " + fe + " " + _ + ', found "' + ae + '" instead.', { index: N }) : this.error("Expected " + fe + " " + _ + ".", { index: N });
    }, z.requiredSpace = function(_) {
      return this.options.lossy ? " " : _;
    }, z.optionalSpace = function(_) {
      return this.options.lossy ? "" : _;
    }, z.lossySpace = function(_, N) {
      return this.options.lossy ? N ? " " : "" : _;
    }, z.parseParenthesisToken = function(_) {
      var N = this.content(_);
      return _[v.FIELDS.TYPE] === g.space ? this.requiredSpace(N) : N;
    }, z.newNode = function(_, N) {
      return N && (/^ +$/.test(N) && (this.options.lossy || (this.spaces = (this.spaces || "") + N), N = true), _.namespace = N, Y(_, "namespace")), this.spaces && (_.spaces.before = this.spaces, this.spaces = ""), this.current.append(_);
    }, z.content = function(_) {
      return _ === void 0 && (_ = this.currToken), this.css.slice(_[v.FIELDS.START_POS], _[v.FIELDS.END_POS]);
    }, z.locateNextMeaningfulToken = function(_) {
      _ === void 0 && (_ = this.position + 1);
      for (var N = _; N < this.tokens.length; )
        if (H[this.tokens[N][v.FIELDS.TYPE]]) {
          N++;
          continue;
        } else
          return N;
      return -1;
    }, U(B, [{ key: "currToken", get: function() {
      return this.tokens[this.position];
    } }, { key: "nextToken", get: function() {
      return this.tokens[this.position + 1];
    } }, { key: "prevToken", get: function() {
      return this.tokens[this.position - 1];
    } }]), B;
  }();
  e.default = ie, t.exports = e.default;
});
var Jv = le((e, t) => {
  "use strict";
  e.__esModule = true, e.default = void 0;
  var r2 = n(Zv());
  function n(a) {
    return a && a.__esModule ? a : { default: a };
  }
  var i = function() {
    function a(u, s) {
      this.func = u || function() {
      }, this.funcRes = null, this.options = s;
    }
    var o = a.prototype;
    return o._shouldUpdateSelector = function(u, s) {
      s === void 0 && (s = {});
      var l = Object.assign({}, this.options, s);
      return l.updateSelector === false ? false : typeof u != "string";
    }, o._isLossy = function(u) {
      u === void 0 && (u = {});
      var s = Object.assign({}, this.options, u);
      return s.lossless === false;
    }, o._root = function(u, s) {
      s === void 0 && (s = {});
      var l = new r2.default(u, this._parseOptions(s));
      return l.root;
    }, o._parseOptions = function(u) {
      return { lossy: this._isLossy(u) };
    }, o._run = function(u, s) {
      var l = this;
      return s === void 0 && (s = {}), new Promise(function(f, c) {
        try {
          var p2 = l._root(u, s);
          Promise.resolve(l.func(p2)).then(function(d) {
            var D = void 0;
            return l._shouldUpdateSelector(u, s) && (D = p2.toString(), u.selector = D), { transform: d, root: p2, string: D };
          }).then(f, c);
        } catch (d) {
          c(d);
          return;
        }
      });
    }, o._runSync = function(u, s) {
      s === void 0 && (s = {});
      var l = this._root(u, s), f = this.func(l);
      if (f && typeof f.then == "function")
        throw new Error("Selector processor returned a promise to a synchronous call.");
      var c = void 0;
      return s.updateSelector && typeof u != "string" && (c = l.toString(), u.selector = c), { transform: f, root: l, string: c };
    }, o.ast = function(u, s) {
      return this._run(u, s).then(function(l) {
        return l.root;
      });
    }, o.astSync = function(u, s) {
      return this._runSync(u, s).root;
    }, o.transform = function(u, s) {
      return this._run(u, s).then(function(l) {
        return l.transform;
      });
    }, o.transformSync = function(u, s) {
      return this._runSync(u, s).transform;
    }, o.process = function(u, s) {
      return this._run(u, s).then(function(l) {
        return l.string || l.root.toString();
      });
    }, o.processSync = function(u, s) {
      var l = this._runSync(u, s);
      return l.string || l.root.toString();
    }, a;
  }();
  e.default = i, t.exports = e.default;
});
var Kv = le((e) => {
  "use strict";
  e.__esModule = true, e.universal = e.tag = e.string = e.selector = e.root = e.pseudo = e.nesting = e.id = e.comment = e.combinator = e.className = e.attribute = void 0;
  var t = d(Ju()), r2 = d(Vu()), n = d(Qu()), i = d(Hu()), a = d(Xu()), o = d(el()), u = d(Zu()), s = d(ju()), l = d(zu()), f = d(Yu()), c = d(qu()), p2 = d(Ku());
  function d(M) {
    return M && M.__esModule ? M : { default: M };
  }
  var D = function(M) {
    return new t.default(M);
  };
  e.attribute = D;
  var v = function(M) {
    return new r2.default(M);
  };
  e.className = v;
  var g = function(M) {
    return new n.default(M);
  };
  e.combinator = g;
  var y = function(M) {
    return new i.default(M);
  };
  e.comment = y;
  var b = function(M) {
    return new a.default(M);
  };
  e.id = b;
  var C = function(M) {
    return new o.default(M);
  };
  e.nesting = C;
  var k = function(M) {
    return new u.default(M);
  };
  e.pseudo = k;
  var S = function(M) {
    return new s.default(M);
  };
  e.root = S;
  var E = function(M) {
    return new l.default(M);
  };
  e.selector = E;
  var L = function(M) {
    return new f.default(M);
  };
  e.string = L;
  var T = function(M) {
    return new c.default(M);
  };
  e.tag = T;
  var U = function(M) {
    return new p2.default(M);
  };
  e.universal = U;
});
var Qv = le((e) => {
  "use strict";
  e.__esModule = true, e.isNode = i, e.isPseudoElement = b, e.isPseudoClass = C, e.isContainer = k, e.isNamespace = S, e.isUniversal = e.isTag = e.isString = e.isSelector = e.isRoot = e.isPseudo = e.isNesting = e.isIdentifier = e.isComment = e.isCombinator = e.isClassName = e.isAttribute = void 0;
  var t = ut(), r2, n = (r2 = {}, r2[t.ATTRIBUTE] = true, r2[t.CLASS] = true, r2[t.COMBINATOR] = true, r2[t.COMMENT] = true, r2[t.ID] = true, r2[t.NESTING] = true, r2[t.PSEUDO] = true, r2[t.ROOT] = true, r2[t.SELECTOR] = true, r2[t.STRING] = true, r2[t.TAG] = true, r2[t.UNIVERSAL] = true, r2);
  function i(E) {
    return typeof E == "object" && n[E.type];
  }
  function a(E, L) {
    return i(L) && L.type === E;
  }
  var o = a.bind(null, t.ATTRIBUTE);
  e.isAttribute = o;
  var u = a.bind(null, t.CLASS);
  e.isClassName = u;
  var s = a.bind(null, t.COMBINATOR);
  e.isCombinator = s;
  var l = a.bind(null, t.COMMENT);
  e.isComment = l;
  var f = a.bind(null, t.ID);
  e.isIdentifier = f;
  var c = a.bind(null, t.NESTING);
  e.isNesting = c;
  var p2 = a.bind(null, t.PSEUDO);
  e.isPseudo = p2;
  var d = a.bind(null, t.ROOT);
  e.isRoot = d;
  var D = a.bind(null, t.SELECTOR);
  e.isSelector = D;
  var v = a.bind(null, t.STRING);
  e.isString = v;
  var g = a.bind(null, t.TAG);
  e.isTag = g;
  var y = a.bind(null, t.UNIVERSAL);
  e.isUniversal = y;
  function b(E) {
    return p2(E) && E.value && (E.value.startsWith("::") || E.value.toLowerCase() === ":before" || E.value.toLowerCase() === ":after" || E.value.toLowerCase() === ":first-letter" || E.value.toLowerCase() === ":first-line");
  }
  function C(E) {
    return p2(E) && !b(E);
  }
  function k(E) {
    return !!(i(E) && E.walk);
  }
  function S(E) {
    return o(E) || g(E);
  }
});
var eg = le((e) => {
  "use strict";
  e.__esModule = true;
  var t = ut();
  Object.keys(t).forEach(function(i) {
    i === "default" || i === "__esModule" || i in e && e[i] === t[i] || (e[i] = t[i]);
  });
  var r2 = Kv();
  Object.keys(r2).forEach(function(i) {
    i === "default" || i === "__esModule" || i in e && e[i] === r2[i] || (e[i] = r2[i]);
  });
  var n = Qv();
  Object.keys(n).forEach(function(i) {
    i === "default" || i === "__esModule" || i in e && e[i] === n[i] || (e[i] = n[i]);
  });
});
var tg = le((e, t) => {
  "use strict";
  e.__esModule = true, e.default = void 0;
  var r2 = o(Jv()), n = a(eg());
  function i() {
    if (typeof WeakMap != "function")
      return null;
    var l = /* @__PURE__ */ new WeakMap();
    return i = function() {
      return l;
    }, l;
  }
  function a(l) {
    if (l && l.__esModule)
      return l;
    if (l === null || typeof l != "object" && typeof l != "function")
      return { default: l };
    var f = i();
    if (f && f.has(l))
      return f.get(l);
    var c = {}, p2 = Object.defineProperty && Object.getOwnPropertyDescriptor;
    for (var d in l)
      if (Object.prototype.hasOwnProperty.call(l, d)) {
        var D = p2 ? Object.getOwnPropertyDescriptor(l, d) : null;
        D && (D.get || D.set) ? Object.defineProperty(c, d, D) : c[d] = l[d];
      }
    return c.default = l, f && f.set(l, c), c;
  }
  function o(l) {
    return l && l.__esModule ? l : { default: l };
  }
  var u = function(l) {
    return new r2.default(l);
  };
  Object.assign(u, n), delete u.__esModule;
  var s = u;
  e.default = s, t.exports = e.default;
});
var rg = le((e) => {
  "use strict";
  Object.defineProperty(e, "__esModule", { value: true }), Object.defineProperty(e, "default", { enumerable: true, get: () => t });
  function t(r2) {
    return r2.replace(/\\,/g, "\\2c ");
  }
});
var ng = le((e, t) => {
  "use strict";
  t.exports = { aliceblue: [240, 248, 255], antiquewhite: [250, 235, 215], aqua: [0, 255, 255], aquamarine: [127, 255, 212], azure: [240, 255, 255], beige: [245, 245, 220], bisque: [255, 228, 196], black: [0, 0, 0], blanchedalmond: [255, 235, 205], blue: [0, 0, 255], blueviolet: [138, 43, 226], brown: [165, 42, 42], burlywood: [222, 184, 135], cadetblue: [95, 158, 160], chartreuse: [127, 255, 0], chocolate: [210, 105, 30], coral: [255, 127, 80], cornflowerblue: [100, 149, 237], cornsilk: [255, 248, 220], crimson: [220, 20, 60], cyan: [0, 255, 255], darkblue: [0, 0, 139], darkcyan: [0, 139, 139], darkgoldenrod: [184, 134, 11], darkgray: [169, 169, 169], darkgreen: [0, 100, 0], darkgrey: [169, 169, 169], darkkhaki: [189, 183, 107], darkmagenta: [139, 0, 139], darkolivegreen: [85, 107, 47], darkorange: [255, 140, 0], darkorchid: [153, 50, 204], darkred: [139, 0, 0], darksalmon: [233, 150, 122], darkseagreen: [143, 188, 143], darkslateblue: [72, 61, 139], darkslategray: [47, 79, 79], darkslategrey: [47, 79, 79], darkturquoise: [0, 206, 209], darkviolet: [148, 0, 211], deeppink: [255, 20, 147], deepskyblue: [0, 191, 255], dimgray: [105, 105, 105], dimgrey: [105, 105, 105], dodgerblue: [30, 144, 255], firebrick: [178, 34, 34], floralwhite: [255, 250, 240], forestgreen: [34, 139, 34], fuchsia: [255, 0, 255], gainsboro: [220, 220, 220], ghostwhite: [248, 248, 255], gold: [255, 215, 0], goldenrod: [218, 165, 32], gray: [128, 128, 128], green: [0, 128, 0], greenyellow: [173, 255, 47], grey: [128, 128, 128], honeydew: [240, 255, 240], hotpink: [255, 105, 180], indianred: [205, 92, 92], indigo: [75, 0, 130], ivory: [255, 255, 240], khaki: [240, 230, 140], lavender: [230, 230, 250], lavenderblush: [255, 240, 245], lawngreen: [124, 252, 0], lemonchiffon: [255, 250, 205], lightblue: [173, 216, 230], lightcoral: [240, 128, 128], lightcyan: [224, 255, 255], lightgoldenrodyellow: [250, 250, 210], lightgray: [211, 211, 211], lightgreen: [144, 238, 144], lightgrey: [211, 211, 211], lightpink: [255, 182, 193], lightsalmon: [255, 160, 122], lightseagreen: [32, 178, 170], lightskyblue: [135, 206, 250], lightslategray: [119, 136, 153], lightslategrey: [119, 136, 153], lightsteelblue: [176, 196, 222], lightyellow: [255, 255, 224], lime: [0, 255, 0], limegreen: [50, 205, 50], linen: [250, 240, 230], magenta: [255, 0, 255], maroon: [128, 0, 0], mediumaquamarine: [102, 205, 170], mediumblue: [0, 0, 205], mediumorchid: [186, 85, 211], mediumpurple: [147, 112, 219], mediumseagreen: [60, 179, 113], mediumslateblue: [123, 104, 238], mediumspringgreen: [0, 250, 154], mediumturquoise: [72, 209, 204], mediumvioletred: [199, 21, 133], midnightblue: [25, 25, 112], mintcream: [245, 255, 250], mistyrose: [255, 228, 225], moccasin: [255, 228, 181], navajowhite: [255, 222, 173], navy: [0, 0, 128], oldlace: [253, 245, 230], olive: [128, 128, 0], olivedrab: [107, 142, 35], orange: [255, 165, 0], orangered: [255, 69, 0], orchid: [218, 112, 214], palegoldenrod: [238, 232, 170], palegreen: [152, 251, 152], paleturquoise: [175, 238, 238], palevioletred: [219, 112, 147], papayawhip: [255, 239, 213], peachpuff: [255, 218, 185], peru: [205, 133, 63], pink: [255, 192, 203], plum: [221, 160, 221], powderblue: [176, 224, 230], purple: [128, 0, 128], rebeccapurple: [102, 51, 153], red: [255, 0, 0], rosybrown: [188, 143, 143], royalblue: [65, 105, 225], saddlebrown: [139, 69, 19], salmon: [250, 128, 114], sandybrown: [244, 164, 96], seagreen: [46, 139, 87], seashell: [255, 245, 238], sienna: [160, 82, 45], silver: [192, 192, 192], skyblue: [135, 206, 235], slateblue: [106, 90, 205], slategray: [112, 128, 144], slategrey: [112, 128, 144], snow: [255, 250, 250], springgreen: [0, 255, 127], steelblue: [70, 130, 180], tan: [210, 180, 140], teal: [0, 128, 128], thistle: [216, 191, 216], tomato: [255, 99, 71], turquoise: [64, 224, 208], violet: [238, 130, 238], wheat: [245, 222, 179], white: [255, 255, 255], whitesmoke: [245, 245, 245], yellow: [255, 255, 0], yellowgreen: [154, 205, 50] };
});
var rl = le((e) => {
  "use strict";
  Object.defineProperty(e, "__esModule", { value: true });
  function t(D, v) {
    for (var g in v)
      Object.defineProperty(D, g, { enumerable: true, get: v[g] });
  }
  t(e, { parseColor: () => p2, formatColor: () => d });
  var r2 = n(ng());
  function n(D) {
    return D && D.__esModule ? D : { default: D };
  }
  var i = /^#([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})?$/i, a = /^#([a-f\d])([a-f\d])([a-f\d])([a-f\d])?$/i, o = /(?:\d+|\d*\.\d+)%?/, u = /(?:\s*,\s*|\s+)/, s = /\s*[,/]\s*/, l = /var\(--(?:[^ )]*?)\)/, f = new RegExp(`^(rgb)a?\\(\\s*(${o.source}|${l.source})(?:${u.source}(${o.source}|${l.source}))?(?:${u.source}(${o.source}|${l.source}))?(?:${s.source}(${o.source}|${l.source}))?\\s*\\)$`), c = new RegExp(`^(hsl)a?\\(\\s*((?:${o.source})(?:deg|rad|grad|turn)?|${l.source})(?:${u.source}(${o.source}|${l.source}))?(?:${u.source}(${o.source}|${l.source}))?(?:${s.source}(${o.source}|${l.source}))?\\s*\\)$`);
  function p2(D, { loose: v = false } = {}) {
    var g, y;
    if (typeof D != "string")
      return null;
    if (D = D.trim(), D === "transparent")
      return { mode: "rgb", color: ["0", "0", "0"], alpha: "0" };
    if (D in r2.default)
      return { mode: "rgb", color: r2.default[D].map((E) => E.toString()) };
    let b = D.replace(a, (E, L, T, U, M) => ["#", L, L, T, T, U, U, M ? M + M : ""].join("")).match(i);
    if (b !== null)
      return { mode: "rgb", color: [parseInt(b[1], 16), parseInt(b[2], 16), parseInt(b[3], 16)].map((E) => E.toString()), alpha: b[4] ? (parseInt(b[4], 16) / 255).toString() : void 0 };
    var C;
    let k = (C = D.match(f)) !== null && C !== void 0 ? C : D.match(c);
    if (k === null)
      return null;
    let S = [k[2], k[3], k[4]].filter(Boolean).map((E) => E.toString());
    return !v && S.length !== 3 || S.length < 3 && !S.some((E) => /^var\(.*?\)$/.test(E)) ? null : { mode: k[1], color: S, alpha: (g = k[5]) === null || g === void 0 || (y = g.toString) === null || y === void 0 ? void 0 : y.call(g) };
  }
  function d({ mode: D, color: v, alpha: g }) {
    let y = g !== void 0;
    return `${D}(${v.join(" ")}${y ? ` / ${g}` : ""})`;
  }
});
var nl = le((e) => {
  "use strict";
  Object.defineProperty(e, "__esModule", { value: true });
  function t(a, o) {
    for (var u in o)
      Object.defineProperty(a, u, { enumerable: true, get: o[u] });
  }
  t(e, { withAlphaValue: () => n, default: () => i });
  var r2 = rl();
  function n(a, o, u) {
    if (typeof a == "function")
      return a({ opacityValue: o });
    let s = (0, r2.parseColor)(a, { loose: true });
    return s === null ? u : (0, r2.formatColor)({ ...s, alpha: o });
  }
  function i({ color: a, property: o, variable: u }) {
    let s = [].concat(o);
    if (typeof a == "function")
      return { [u]: "1", ...Object.fromEntries(s.map((f) => [f, a({ opacityVariable: u, opacityValue: `var(${u})` })])) };
    let l = (0, r2.parseColor)(a);
    return l === null ? Object.fromEntries(s.map((f) => [f, a])) : l.alpha !== void 0 ? Object.fromEntries(s.map((f) => [f, a])) : { [u]: "1", ...Object.fromEntries(s.map((f) => [f, (0, r2.formatColor)({ ...l, alpha: `var(${u})` })])) };
  }
});
var ig = le((e) => {
  "use strict";
  Object.defineProperty(e, "__esModule", { value: true });
  function t(p2, d) {
    for (var D in d)
      Object.defineProperty(p2, D, { enumerable: true, get: d[D] });
  }
  t(e, { pattern: () => a, withoutCapturing: () => o, any: () => u, optional: () => s, zeroOrMore: () => l, nestedBrackets: () => f, escape: () => c });
  var r2 = /[\\^$.*+?()[\]{}|]/g, n = RegExp(r2.source);
  function i(p2) {
    return p2 = Array.isArray(p2) ? p2 : [p2], p2 = p2.map((d) => d instanceof RegExp ? d.source : d), p2.join("");
  }
  function a(p2) {
    return new RegExp(i(p2), "g");
  }
  function o(p2) {
    return new RegExp(`(?:${i(p2)})`, "g");
  }
  function u(p2) {
    return `(?:${p2.map(i).join("|")})`;
  }
  function s(p2) {
    return `(?:${i(p2)})?`;
  }
  function l(p2) {
    return `(?:${i(p2)})*`;
  }
  function f(p2, d, D = 1) {
    return o([c(p2), /[^\s]*/, D === 1 ? `[^${c(p2)}${c(d)}s]*` : u([`[^${c(p2)}${c(d)}s]*`, f(p2, d, D - 1)]), /[^\s]*/, c(d)]);
  }
  function c(p2) {
    return p2 && n.test(p2) ? p2.replace(r2, "\\$&") : p2 || "";
  }
});
var ag = le((e) => {
  "use strict";
  Object.defineProperty(e, "__esModule", { value: true }), Object.defineProperty(e, "splitAtTopLevelOnly", { enumerable: true, get: () => i });
  var t = n(ig());
  function r2(a) {
    if (typeof WeakMap != "function")
      return null;
    var o = /* @__PURE__ */ new WeakMap(), u = /* @__PURE__ */ new WeakMap();
    return (r2 = function(s) {
      return s ? u : o;
    })(a);
  }
  function n(a, o) {
    if (!o && a && a.__esModule)
      return a;
    if (a === null || typeof a != "object" && typeof a != "function")
      return { default: a };
    var u = r2(o);
    if (u && u.has(a))
      return u.get(a);
    var s = {}, l = Object.defineProperty && Object.getOwnPropertyDescriptor;
    for (var f in a)
      if (f !== "default" && Object.prototype.hasOwnProperty.call(a, f)) {
        var c = l ? Object.getOwnPropertyDescriptor(a, f) : null;
        c && (c.get || c.set) ? Object.defineProperty(s, f, c) : s[f] = a[f];
      }
    return s.default = a, u && u.set(a, s), s;
  }
  function* i(a, o) {
    let u = new RegExp(`[(){}\\[\\]${t.escape(o)}]`, "g"), s = 0, l = 0, f = false, c = 0, p2 = 0, d = o.length;
    for (let D of a.matchAll(u)) {
      let v = D[0] === o[c], g = c === d - 1, y = v && g;
      D[0] === "(" && s++, D[0] === ")" && s--, D[0] === "[" && s++, D[0] === "]" && s--, D[0] === "{" && s++, D[0] === "}" && s--, v && s === 0 && (p2 === 0 && (p2 = D.index), c++), y && s === 0 && (f = true, yield a.substring(l, p2), l = p2 + d), c === d && (c = 0, p2 = 0);
    }
    f ? yield a.substring(l) : yield a;
  }
});
var og = le((e) => {
  "use strict";
  Object.defineProperty(e, "__esModule", { value: true });
  function t(s, l) {
    for (var f in l)
      Object.defineProperty(s, f, { enumerable: true, get: l[f] });
  }
  t(e, { parseBoxShadowValue: () => o, formatBoxShadowValue: () => u });
  var r2 = ag(), n = /* @__PURE__ */ new Set(["inset", "inherit", "initial", "revert", "unset"]), i = /\ +(?![^(]*\))/g, a = /^-?(\d+|\.\d+)(.*?)$/g;
  function o(s) {
    return Array.from((0, r2.splitAtTopLevelOnly)(s, ",")).map((l) => {
      let f = l.trim(), c = { raw: f }, p2 = f.split(i), d = /* @__PURE__ */ new Set();
      for (let D of p2)
        a.lastIndex = 0, !d.has("KEYWORD") && n.has(D) ? (c.keyword = D, d.add("KEYWORD")) : a.test(D) ? d.has("X") ? d.has("Y") ? d.has("BLUR") ? d.has("SPREAD") || (c.spread = D, d.add("SPREAD")) : (c.blur = D, d.add("BLUR")) : (c.y = D, d.add("Y")) : (c.x = D, d.add("X")) : c.color ? (c.unknown || (c.unknown = []), c.unknown.push(D)) : c.color = D;
      return c.valid = c.x !== void 0 && c.y !== void 0, c;
    });
  }
  function u(s) {
    return s.map((l) => l.valid ? [l.keyword, l.x, l.y, l.blur, l.spread, l.color].filter(Boolean).join(" ") : l.raw).join(", ");
  }
});
var sg = le((e) => {
  "use strict";
  Object.defineProperty(e, "__esModule", { value: true });
  function t(A, R) {
    for (var O in R)
      Object.defineProperty(A, O, { enumerable: true, get: R[O] });
  }
  t(e, { normalize: () => u, url: () => s, number: () => l, percentage: () => f, length: () => d, lineWidth: () => v, shadow: () => g, color: () => y, image: () => b, gradient: () => k, position: () => E, familyName: () => L, genericName: () => U, absoluteSize: () => H, relativeSize: () => ee });
  var r2 = rl(), n = og(), i = ["min", "max", "clamp", "calc"], a = /,(?![^(]*\))/g, o = /_(?![^(]*\))/g;
  function u(A, R = true) {
    return A.includes("url(") ? A.split(/(url\(.*?\))/g).filter(Boolean).map((O) => /^url\(.*?\)$/.test(O) ? O : u(O, false)).join("") : (A = A.replace(/([^\\])_+/g, (O, Y) => Y + " ".repeat(O.length - 1)).replace(/^_/g, " ").replace(/\\_/g, "_"), R && (A = A.trim()), A = A.replace(/(calc|min|max|clamp)\(.+\)/g, (O) => O.replace(/(-?\d*\.?\d(?!\b-.+[,)](?![^+\-/*])\D)(?:%|[a-z]+)?|\))([+\-/*])/g, "$1 $2 ")), A);
  }
  function s(A) {
    return A.startsWith("url(");
  }
  function l(A) {
    return !isNaN(Number(A)) || i.some((R) => new RegExp(`^${R}\\(.+?`).test(A));
  }
  function f(A) {
    return A.split(o).every((R) => /%$/g.test(R) || i.some((O) => new RegExp(`^${O}\\(.+?%`).test(R)));
  }
  var c = ["cm", "mm", "Q", "in", "pc", "pt", "px", "em", "ex", "ch", "rem", "lh", "vw", "vh", "vmin", "vmax"], p2 = `(?:${c.join("|")})`;
  function d(A) {
    return A.split(o).every((R) => R === "0" || new RegExp(`${p2}$`).test(R) || i.some((O) => new RegExp(`^${O}\\(.+?${p2}`).test(R)));
  }
  var D = /* @__PURE__ */ new Set(["thin", "medium", "thick"]);
  function v(A) {
    return D.has(A);
  }
  function g(A) {
    let R = (0, n.parseBoxShadowValue)(u(A));
    for (let O of R)
      if (!O.valid)
        return false;
    return true;
  }
  function y(A) {
    let R = 0;
    return A.split(o).every((O) => (O = u(O), O.startsWith("var(") ? true : (0, r2.parseColor)(O, { loose: true }) !== null ? (R++, true) : false)) ? R > 0 : false;
  }
  function b(A) {
    let R = 0;
    return A.split(a).every((O) => (O = u(O), O.startsWith("var(") ? true : s(O) || k(O) || ["element(", "image(", "cross-fade(", "image-set("].some((Y) => O.startsWith(Y)) ? (R++, true) : false)) ? R > 0 : false;
  }
  var C = /* @__PURE__ */ new Set(["linear-gradient", "radial-gradient", "repeating-linear-gradient", "repeating-radial-gradient", "conic-gradient"]);
  function k(A) {
    A = u(A);
    for (let R of C)
      if (A.startsWith(`${R}(`))
        return true;
    return false;
  }
  var S = /* @__PURE__ */ new Set(["center", "top", "right", "bottom", "left"]);
  function E(A) {
    let R = 0;
    return A.split(o).every((O) => (O = u(O), O.startsWith("var(") ? true : S.has(O) || d(O) || f(O) ? (R++, true) : false)) ? R > 0 : false;
  }
  function L(A) {
    let R = 0;
    return A.split(a).every((O) => (O = u(O), O.startsWith("var(") ? true : O.includes(" ") && !/(['"])([^"']+)\1/g.test(O) || /^\d/g.test(O) ? false : (R++, true))) ? R > 0 : false;
  }
  var T = /* @__PURE__ */ new Set(["serif", "sans-serif", "monospace", "cursive", "fantasy", "system-ui", "ui-serif", "ui-sans-serif", "ui-monospace", "ui-rounded", "math", "emoji", "fangsong"]);
  function U(A) {
    return T.has(A);
  }
  var M = /* @__PURE__ */ new Set(["xx-small", "x-small", "small", "medium", "large", "x-large", "x-large", "xxx-large"]);
  function H(A) {
    return M.has(A);
  }
  var q = /* @__PURE__ */ new Set(["larger", "smaller"]);
  function ee(A) {
    return q.has(A);
  }
});
var ug = le((e) => {
  "use strict";
  Object.defineProperty(e, "__esModule", { value: true });
  function t(E, L) {
    for (var T in L)
      Object.defineProperty(E, T, { enumerable: true, get: L[T] });
  }
  t(e, { updateAllClasses: () => s, asValue: () => c, parseColorFormat: () => D, asColor: () => v, asLookupValue: () => g, coerceValue: () => S });
  var r2 = u(tg()), n = u(rg()), i = nl(), a = sg(), o = u(Mu());
  function u(E) {
    return E && E.__esModule ? E : { default: E };
  }
  function s(E, L) {
    return (0, r2.default)((T) => {
      T.walkClasses((U) => {
        let M = L(U.value);
        U.value = M, U.raws && U.raws.value && (U.raws.value = (0, n.default)(U.raws.value));
      });
    }).processSync(E);
  }
  function l(E, L) {
    if (!p2(E))
      return;
    let T = E.slice(1, -1);
    if (L(T))
      return (0, a.normalize)(T);
  }
  function f(E, L = {}, T) {
    let U = L[E];
    if (U !== void 0)
      return (0, o.default)(U);
    if (p2(E)) {
      let M = l(E, T);
      return M === void 0 ? void 0 : (0, o.default)(M);
    }
  }
  function c(E, L = {}, { validate: T = () => true } = {}) {
    var U;
    let M = (U = L.values) === null || U === void 0 ? void 0 : U[E];
    return M !== void 0 ? M : L.supportsNegativeValues && E.startsWith("-") ? f(E.slice(1), L.values, T) : l(E, T);
  }
  function p2(E) {
    return E.startsWith("[") && E.endsWith("]");
  }
  function d(E) {
    let L = E.lastIndexOf("/");
    return L === -1 || L === E.length - 1 ? [E] : [E.slice(0, L), E.slice(L + 1)];
  }
  function D(E) {
    if (typeof E == "string" && E.includes("<alpha-value>")) {
      let L = E;
      return ({ opacityValue: T = 1 }) => L.replace("<alpha-value>", T);
    }
    return E;
  }
  function v(E, L = {}, { tailwindConfig: T = {} } = {}) {
    var U;
    if (((U = L.values) === null || U === void 0 ? void 0 : U[E]) !== void 0) {
      var M;
      return D((M = L.values) === null || M === void 0 ? void 0 : M[E]);
    }
    let [H, q] = d(E);
    if (q !== void 0) {
      var ee, A, R, O;
      let Y = (O = (ee = L.values) === null || ee === void 0 ? void 0 : ee[H]) !== null && O !== void 0 ? O : p2(H) ? H.slice(1, -1) : void 0;
      return Y === void 0 ? void 0 : (Y = D(Y), p2(q) ? (0, i.withAlphaValue)(Y, q.slice(1, -1)) : ((A = T.theme) === null || A === void 0 || (R = A.opacity) === null || R === void 0 ? void 0 : R[q]) === void 0 ? void 0 : (0, i.withAlphaValue)(Y, T.theme.opacity[q]));
    }
    return c(E, L, { validate: a.color });
  }
  function g(E, L = {}) {
    var T;
    return (T = L.values) === null || T === void 0 ? void 0 : T[E];
  }
  function y(E) {
    return (L, T) => c(L, T, { validate: E });
  }
  var b = { any: c, color: v, url: y(a.url), image: y(a.image), length: y(a.length), percentage: y(a.percentage), position: y(a.position), lookup: g, "generic-name": y(a.genericName), "family-name": y(a.familyName), number: y(a.number), "line-width": y(a.lineWidth), "absolute-size": y(a.absoluteSize), "relative-size": y(a.relativeSize), shadow: y(a.shadow) }, C = Object.keys(b);
  function k(E, L) {
    let T = E.indexOf(L);
    return T === -1 ? [void 0, E] : [E.slice(0, T), E.slice(T + 1)];
  }
  function S(E, L, T, U) {
    if (p2(L)) {
      let M = L.slice(1, -1), [H, q] = k(M, ":");
      if (!/^[\w-_]+$/g.test(H))
        q = M;
      else if (H !== void 0 && !C.includes(H))
        return [];
      if (q.length > 0 && C.includes(H))
        return [c(`[${q}]`, T), H];
    }
    for (let M of [].concat(E)) {
      let H = b[M](L, T, { tailwindConfig: U });
      if (H !== void 0)
        return [H, M];
    }
    return [];
  }
});
var lg = le((e) => {
  "use strict";
  Object.defineProperty(e, "__esModule", { value: true }), Object.defineProperty(e, "default", { enumerable: true, get: () => t });
  function t(r2) {
    return typeof r2 == "function" ? r2({}) : r2;
  }
});
var fg = le((e) => {
  "use strict";
  Object.defineProperty(e, "__esModule", { value: true }), Object.defineProperty(e, "default", { enumerable: true, get: () => ee });
  var t = D(Mu()), r2 = D(Uv()), n = D(Bv()), i = D(Gu()), a = D(Nv()), o = Mv(), u = Gv(), s = Wv(), l = D($v()), f = jv(), c = ug(), p2 = nl(), d = D(lg());
  function D(A) {
    return A && A.__esModule ? A : { default: A };
  }
  function v(A) {
    return typeof A == "function";
  }
  function g(A) {
    return typeof A == "object" && A !== null;
  }
  function y(A, ...R) {
    let O = R.pop();
    for (let Y of R)
      for (let Z in Y) {
        let te = O(A[Z], Y[Z]);
        te === void 0 ? g(A[Z]) && g(Y[Z]) ? A[Z] = y(A[Z], Y[Z], O) : A[Z] = Y[Z] : A[Z] = te;
      }
    return A;
  }
  var b = { colors: a.default, negative(A) {
    return Object.keys(A).filter((R) => A[R] !== "0").reduce((R, O) => {
      let Y = (0, t.default)(A[O]);
      return Y !== void 0 && (R[`-${O}`] = Y), R;
    }, {});
  }, breakpoints(A) {
    return Object.keys(A).filter((R) => typeof A[R] == "string").reduce((R, O) => ({ ...R, [`screen-${O}`]: A[O] }), {});
  } };
  function C(A, ...R) {
    return v(A) ? A(...R) : A;
  }
  function k(A) {
    return A.reduce((R, { extend: O }) => y(R, O, (Y, Z) => Y === void 0 ? [Z] : Array.isArray(Y) ? [Z, ...Y] : [Z, Y]), {});
  }
  function S(A) {
    return { ...A.reduce((R, O) => (0, o.defaults)(R, O), {}), extend: k(A) };
  }
  function E(A, R) {
    if (Array.isArray(A) && g(A[0]))
      return A.concat(R);
    if (Array.isArray(R) && g(R[0]) && g(A))
      return [A, ...R];
    if (Array.isArray(R))
      return R;
  }
  function L({ extend: A, ...R }) {
    return y(R, A, (O, Y) => !v(O) && !Y.some(v) ? y({}, O, ...Y, E) : (Z, te) => y({}, ...[O, ...Y].map((ie) => C(ie, Z, te)), E));
  }
  function* T(A) {
    let R = (0, u.toPath)(A);
    if (R.length === 0 || (yield R, Array.isArray(A)))
      return;
    let O = /^(.*?)\s*\/\s*([^/]+)$/, Y = A.match(O);
    if (Y !== null) {
      let [, Z, te] = Y, ie = (0, u.toPath)(Z);
      ie.alpha = te, yield ie;
    }
  }
  function U(A) {
    let R = (O, Y) => {
      for (let Z of T(O)) {
        let te = 0, ie = A;
        for (; ie != null && te < Z.length; )
          ie = ie[Z[te++]], ie = v(ie) && (Z.alpha === void 0 || te <= Z.length - 1) ? ie(R, b) : ie;
        if (ie !== void 0) {
          if (Z.alpha !== void 0) {
            let B = (0, c.parseColorFormat)(ie);
            return (0, p2.withAlphaValue)(B, Z.alpha, (0, d.default)(B));
          }
          return (0, l.default)(ie) ? (0, f.cloneDeep)(ie) : ie;
        }
      }
      return Y;
    };
    return Object.assign(R, { theme: R, ...b }), Object.keys(A).reduce((O, Y) => (O[Y] = v(A[Y]) ? A[Y](R, b) : A[Y], O), {});
  }
  function M(A) {
    let R = [];
    return A.forEach((O) => {
      R = [...R, O];
      var Y;
      let Z = (Y = O?.plugins) !== null && Y !== void 0 ? Y : [];
      Z.length !== 0 && Z.forEach((te) => {
        te.__isOptionsFunction && (te = te());
        var ie;
        R = [...R, ...M([(ie = te?.config) !== null && ie !== void 0 ? ie : {}])];
      });
    }), R;
  }
  function H(A) {
    return [...A].reduceRight((R, O) => v(O) ? O({ corePlugins: R }) : (0, n.default)(O, R), r2.default);
  }
  function q(A) {
    return [...A].reduceRight((R, O) => [...R, ...O], []);
  }
  function ee(A) {
    let R = [...M(A), { prefix: "", important: false, separator: ":", variantOrder: i.default.variantOrder }];
    var O, Y;
    return (0, s.normalizeConfig)((0, o.defaults)({ theme: U(L(S(R.map((Z) => (O = Z?.theme) !== null && O !== void 0 ? O : {})))), corePlugins: H(R.map((Z) => Z.corePlugins)), plugins: q(A.map((Z) => (Y = Z?.plugins) !== null && Y !== void 0 ? Y : [])) }, ...R));
  }
});
var il = {};
Aa(il, { default: () => al });
var al;
var cg = _a(() => {
  al = { yellow: (e) => e };
});
var pg = le((e) => {
  "use strict";
  Object.defineProperty(e, "__esModule", { value: true });
  function t(c, p2) {
    for (var d in p2)
      Object.defineProperty(c, d, { enumerable: true, get: p2[d] });
  }
  t(e, { flagEnabled: () => u, issueFlagNotices: () => l, default: () => f });
  var r2 = i((cg(), Xn(il))), n = i((Oa(), Xn(Zn)));
  function i(c) {
    return c && c.__esModule ? c : { default: c };
  }
  var a = { optimizeUniversalDefaults: false }, o = { future: ["hoverOnlyWhenSupported", "respectDefaultRingColorOpacity"], experimental: ["optimizeUniversalDefaults", "matchVariant"] };
  function u(c, p2) {
    if (o.future.includes(p2)) {
      var d, D, v;
      return c.future === "all" || ((v = (D = c == null || (d = c.future) === null || d === void 0 ? void 0 : d[p2]) !== null && D !== void 0 ? D : a[p2]) !== null && v !== void 0 ? v : false);
    }
    if (o.experimental.includes(p2)) {
      var g, y, b;
      return c.experimental === "all" || ((b = (y = c == null || (g = c.experimental) === null || g === void 0 ? void 0 : g[p2]) !== null && y !== void 0 ? y : a[p2]) !== null && b !== void 0 ? b : false);
    }
    return false;
  }
  function s(c) {
    if (c.experimental === "all")
      return o.experimental;
    var p2;
    return Object.keys((p2 = c?.experimental) !== null && p2 !== void 0 ? p2 : {}).filter((d) => o.experimental.includes(d) && c.experimental[d]);
  }
  function l(c) {
    if (process.env.JEST_WORKER_ID === void 0 && s(c).length > 0) {
      let p2 = s(c).map((d) => r2.default.yellow(d)).join(", ");
      n.default.warn("experimental-flags-enabled", [`You have enabled experimental features: ${p2}`, "Experimental features in Tailwind CSS are not covered by semver, may introduce breaking changes, and can change at any time."]);
    }
  }
  var f = o;
});
var hg = le((e) => {
  "use strict";
  Object.defineProperty(e, "__esModule", { value: true }), Object.defineProperty(e, "default", { enumerable: true, get: () => i });
  var t = n(Gu()), r2 = pg();
  function n(a) {
    return a && a.__esModule ? a : { default: a };
  }
  function i(a) {
    var o;
    let u = ((o = a?.presets) !== null && o !== void 0 ? o : [t.default]).slice().reverse().flatMap((f) => i(typeof f == "function" ? f() : f)), s = { respectDefaultRingColorOpacity: { theme: { ringColor: { DEFAULT: "#3b82f67f" } } } }, l = Object.keys(s).filter((f) => (0, r2.flagEnabled)(a, f)).map((f) => s[f]);
    return [a, ...l, ...u];
  }
});
var dg = le((e) => {
  "use strict";
  Object.defineProperty(e, "__esModule", { value: true }), Object.defineProperty(e, "default", { enumerable: true, get: () => i });
  var t = n(fg()), r2 = n(hg());
  function n(a) {
    return a && a.__esModule ? a : { default: a };
  }
  function i(...a) {
    let [, ...o] = (0, r2.default)(a[0]);
    return (0, t.default)([...a, ...o]);
  }
});
var vg = le((e, t) => {
  var r2 = dg();
  t.exports = (r2.__esModule ? r2 : { default: r2 }).default;
});
var Qr;
function ol(e) {
  Qr = e;
}
var qr = null;
async function Kn() {
  return Qr || (qr ? (await qr, Qr) : (qr = Promise.resolve().then(() => (Rv(), Nu)).then((e) => e.getYogaModule()).then((e) => Qr = e), await qr, qr = null, Qr));
}
var nn = (e, t) => () => (t || e((t = { exports: {} }).exports, t), t.exports);
var gg = nn((e, t) => {
  t.exports = ["em", "ex", "ch", "rem", "vh", "vw", "vmin", "vmax", "px", "mm", "cm", "in", "pt", "pc", "mozmm"];
});
var mg = nn((e, t) => {
  t.exports = ["deg", "grad", "rad", "turn"];
});
var Dg = nn((e, t) => {
  t.exports = ["dpi", "dpcm", "dppx"];
});
var yg = nn((e, t) => {
  t.exports = ["Hz", "kHz"];
});
var bg = nn((e, t) => {
  t.exports = ["s", "ms"];
});
var xg = gg();
var sl = mg();
var ul = Dg();
var ll = yg();
var fl = bg();
function Ra(e) {
  if (/\.\D?$/.test(e))
    throw new Error("The dot should be followed by a number");
  if (/^[+-]{2}/.test(e))
    throw new Error("Only one leading +/- is allowed");
  if (wg(e) > 1)
    throw new Error("Only one dot is allowed");
  if (/%$/.test(e)) {
    this.type = "percentage", this.value = fa(e), this.unit = "%";
    return;
  }
  var t = Fg(e);
  if (!t) {
    this.type = "number", this.value = fa(e);
    return;
  }
  this.type = Sg(t), this.value = fa(e.substr(0, e.length - t.length)), this.unit = t;
}
Ra.prototype.valueOf = function() {
  return this.value;
};
Ra.prototype.toString = function() {
  return this.value + (this.unit || "");
};
function Qn(e) {
  return new Ra(e);
}
function wg(e) {
  var t = e.match(/\./g);
  return t ? t.length : 0;
}
function fa(e) {
  var t = parseFloat(e);
  if (isNaN(t))
    throw new Error("Invalid number: " + e);
  return t;
}
var Eg = [].concat(sl, ll, xg, ul, fl);
function Fg(e) {
  var t = e.match(/\D+$/), r2 = t && t[0];
  if (r2 && Eg.indexOf(r2) === -1)
    throw new Error("Invalid unit: " + r2);
  return r2;
}
var Cg = Object.assign(In(sl, "angle"), In(ll, "frequency"), In(ul, "resolution"), In(fl, "time"));
function In(e, t) {
  return Object.fromEntries(e.map((r2) => [r2, t]));
}
function Sg(e) {
  return Cg[e] || "length";
}
function jn(e) {
  let t = typeof e;
  return !(t === "number" || t === "bigint" || t === "string" || t === "boolean");
}
function kg(e) {
  return /^class\s/.test(e.toString());
}
function Tg(e) {
  return "dangerouslySetInnerHTML" in e;
}
function _g(e) {
  let t = typeof e > "u" ? [] : [].concat(e).flat(1 / 0), r2 = [];
  for (let n = 0; n < t.length; n++) {
    let i = t[n];
    typeof i > "u" || typeof i == "boolean" || i === null || (typeof i == "number" && (i = String(i)), typeof i == "string" && r2.length && typeof r2[r2.length - 1] == "string" ? r2[r2.length - 1] += i : r2.push(i));
  }
  return r2;
}
function Ie(e, t, r2, n, i = false) {
  if (typeof e == "number")
    return e;
  try {
    if (e = e.trim(), /[ /\(,]/.test(e))
      return;
    if (e === String(+e))
      return +e;
    let a = new Qn(e);
    if (a.type === "length")
      switch (a.unit) {
        case "em":
          return a.value * t;
        case "rem":
          return a.value * 16;
        case "vw":
          return ~~(a.value * n._viewportWidth / 100);
        case "vh":
          return ~~(a.value * n._viewportHeight / 100);
        default:
          return a.value;
      }
    else if (a.type === "angle")
      switch (a.unit) {
        case "deg":
          return a.value;
        case "rad":
          return a.value * 180 / Math.PI;
        default:
          return a.value;
      }
    else if (a.type === "percentage" && i)
      return a.value / 100 * r2;
  } catch {
  }
}
function zn(e, t) {
  return [e[0] * t[0] + e[2] * t[1], e[1] * t[0] + e[3] * t[1], e[0] * t[2] + e[2] * t[3], e[1] * t[2] + e[3] * t[3], e[0] * t[4] + e[2] * t[5] + e[4], e[1] * t[4] + e[3] * t[5] + e[5]];
}
function Lt(e, t, r2, n) {
  let i = t[e];
  if (typeof i > "u") {
    if (n && typeof e < "u")
      throw new Error(`Invalid value for CSS property "${n}". Allowed values: ${Object.keys(t).map((a) => `"${a}"`).join(" | ")}. Received: "${e}".`);
    i = r2;
  }
  return i;
}
var ca;
var pa;
var Ag = [32, 160, 4961, 65792, 65793, 4153, 4241, 10].map((e) => String.fromCodePoint(e));
function Pt(e, t, r2) {
  if (!ca || !pa) {
    if (!(typeof Intl < "u" && "Segmenter" in Intl))
      throw new Error("Intl.Segmenter does not exist, please use import a polyfill.");
    ca = new Intl.Segmenter(r2, { granularity: "word" }), pa = new Intl.Segmenter(r2, { granularity: "grapheme" });
  }
  if (t === "grapheme")
    return [...pa.segment(e)].map((n) => n.segment);
  {
    let n = [...ca.segment(e)].map((o) => o.segment), i = [], a = 0;
    for (; a < n.length; ) {
      let o = n[a];
      if (o == "\xA0") {
        let u = a === 0 ? "" : i.pop(), s = a === n.length - 1 ? "" : n[a + 1];
        i.push(u + "\xA0" + s), a += 2;
      } else
        i.push(o), a++;
    }
    return i;
  }
}
function ue(e, t, r2) {
  let n = "";
  for (let [i, a] of Object.entries(t))
    typeof a < "u" && (n += ` ${i}="${a}"`);
  return r2 ? `<${e}${n}>${r2}</${e}>` : `<${e}${n}/>`;
}
function Og(e = 20) {
  let t = /* @__PURE__ */ new Map();
  function r2(a, o) {
    if (t.size >= e) {
      let u = t.keys().next().value;
      t.delete(u);
    }
    t.set(a, o);
  }
  function n(a) {
    if (!t.has(a))
      return;
    let o = t.get(a);
    return t.delete(a), t.set(a, o), o;
  }
  function i() {
    t.clear();
  }
  return { set: r2, get: n, clear: i };
}
function Ua(e) {
  return e ? e.split(/[, ]/).filter(Boolean).map(Number) : null;
}
function Lg(e) {
  return Object.prototype.toString.call(e);
}
function cl(e) {
  return typeof e == "string";
}
function Ig(e) {
  return typeof e == "number";
}
function Pg(e) {
  return Lg(e) === "[object Undefined]";
}
function Rg(e, t) {
  if (t === "break-all")
    return { words: Pt(e, "grapheme"), requiredBreaks: [] };
  if (t === "keep-all")
    return { words: Pt(e, "word"), requiredBreaks: [] };
  let r2 = new Ei(e), n = 0, i = r2.nextBreak(), a = [], o = [false];
  for (; i; ) {
    let u = e.slice(n, i.position);
    a.push(u), i.required ? o.push(true) : o.push(false), n = i.position, i = r2.nextBreak();
  }
  return { words: a, requiredBreaks: o };
}
var Ug = (e) => e.replaceAll(/([A-Z])/g, (t, r2) => `-${r2.toLowerCase()}`);
function pl(e, t = ",") {
  let r2 = [], n = 0, i = 0;
  t = new RegExp(t);
  for (let a = 0; a < e.length; a++)
    e[a] === "(" ? i++ : e[a] === ")" && i--, i === 0 && t.test(e[a]) && (r2.push(e.slice(n, a).trim()), n = a + 1);
  return r2.push(e.slice(n).trim()), r2;
}
var Bg = "image/avif";
var Ng = "image/webp";
var ei = "image/apng";
var ti = "image/png";
var ri = "image/jpeg";
var ni = "image/gif";
var Ba = "image/svg+xml";
function hl(e) {
  let t = new DataView(e), r2 = 4, n = t.byteLength;
  for (; r2 < n; ) {
    let i = t.getUint16(r2, false);
    if (i > n)
      throw new TypeError("Invalid JPEG");
    let a = t.getUint8(i + 1 + r2);
    if (a === 192 || a === 193 || a === 194)
      return [t.getUint16(i + 7 + r2, false), t.getUint16(i + 5 + r2, false)];
    r2 += i + 2;
  }
  throw new TypeError("Invalid JPEG");
}
function dl(e) {
  let t = new Uint8Array(e.slice(6, 10));
  return [t[0] | t[1] << 8, t[2] | t[3] << 8];
}
function vl(e) {
  let t = new DataView(e);
  return [t.getUint16(18, false), t.getUint16(22, false)];
}
var cr = Og(100);
var ha = /* @__PURE__ */ new Map();
var Mg = [ti, ei, ri, ni, Ba];
function Gg(e) {
  let t = "", r2 = new Uint8Array(e);
  for (let n = 0; n < r2.byteLength; n++)
    t += String.fromCharCode(r2[n]);
  return btoa(t);
}
function Wg(e) {
  let t = atob(e), r2 = t.length, n = new Uint8Array(r2);
  for (let i = 0; i < r2; i++)
    n[i] = t.charCodeAt(i);
  return n.buffer;
}
function lu(e, t) {
  let r2 = t.match(/<svg[^>]*>/)[0], n = r2.match(/viewBox=['"](.+)['"]/), i = n ? Ua(n[1]) : null, a = r2.match(/width=['"](\d*\.\d+|\d+)['"]/), o = r2.match(/height=['"](\d*\.\d+|\d+)['"]/);
  if (!i && (!a || !o))
    throw new Error(`Failed to parse SVG from ${e}: missing "viewBox"`);
  let u = i ? [i[2], i[3]] : [+a[1], +o[1]], s = u[0] / u[1];
  return a && o ? [+a[1], +o[1]] : a ? [+a[1], +a[1] / s] : o ? [+o[1] * s, +o[1]] : [u[0], u[1]];
}
function fu(e) {
  let t, r2 = $g(new Uint8Array(e));
  switch (r2) {
    case ti:
    case ei:
      t = vl(e);
      break;
    case ni:
      t = dl(e);
      break;
    case ri:
      t = hl(e);
      break;
  }
  if (!Mg.includes(r2))
    throw new Error(`Unsupported image type: ${r2 || "unknown"}`);
  return [`data:${r2};base64,${Gg(e)}`, t];
}
async function Na(e) {
  if (!e)
    throw new Error("Image source is not provided.");
  if (typeof e == "object") {
    let [i, a] = fu(e);
    return [i, ...a];
  }
  if ((e.startsWith('"') && e.endsWith('"') || e.startsWith("'") && e.endsWith("'")) && (e = e.slice(1, -1)), typeof window > "u" && !e.startsWith("http") && !e.startsWith("data:"))
    throw new Error(`Image source must be an absolute URL: ${e}`);
  if (e.startsWith("data:")) {
    let i;
    try {
      i = /data:(?<imageType>[a-z/+]+)(;(charset=)?(?<encodingType>.*))?,(?<dataString>.*)/g.exec(e).groups;
    } catch {
      return console.warn("Image data URI resolved without size:" + e), [e];
    }
    let { imageType: a, encodingType: o, dataString: u } = i;
    if (a === Ba) {
      let s = o === "base64" ? atob(u) : decodeURIComponent(u.replace(/ /g, "%20")), l = o === "base64" ? e : `data:image/svg+xml;base64,${btoa(s)}`, f = lu(e, s);
      return cr.set(e, [l, ...f]), [l, ...f];
    } else if (o === "base64") {
      let s, l = Wg(u);
      switch (a) {
        case ti:
        case ei:
          s = vl(l);
          break;
        case ni:
          s = dl(l);
          break;
        case ri:
          s = hl(l);
          break;
      }
      return cr.set(e, [e, ...s]), [e, ...s];
    } else
      return console.warn("Image data URI resolved without size:" + e), cr.set(e, [e]), [e];
  }
  if (!globalThis.fetch)
    throw new Error("`fetch` is required to be polyfilled to load images.");
  if (ha.has(e))
    return ha.get(e);
  let t = cr.get(e);
  if (t)
    return t;
  let r2 = e, n = fetch(r2).then((i) => {
    let a = i.headers.get("content-type");
    return a === "image/svg+xml" || a === "application/svg+xml" ? i.text() : i.arrayBuffer();
  }).then((i) => {
    if (typeof i == "string")
      try {
        let u = `data:image/svg+xml;base64,${btoa(i)}`, s = lu(r2, i);
        return [u, ...s];
      } catch (u) {
        throw new Error(`Failed to parse SVG image: ${u.message}`);
      }
    let [a, o] = fu(i);
    return [a, ...o];
  }).then((i) => (cr.set(r2, i), i)).catch((i) => (console.error(`Can't load image ${r2}: ` + i.message), cr.set(r2, []), []));
  return ha.set(r2, n), n;
}
function $g(e) {
  return [255, 216, 255].every((t, r2) => e[r2] === t) ? ri : [137, 80, 78, 71, 13, 10, 26, 10].every((t, r2) => e[r2] === t) ? jg(e) ? ei : ti : [71, 73, 70, 56].every((t, r2) => e[r2] === t) ? ni : [82, 73, 70, 70, 0, 0, 0, 0, 87, 69, 66, 80].every((t, r2) => !t || e[r2] === t) ? Ng : [60, 63, 120, 109, 108].every((t, r2) => e[r2] === t) ? Ba : [0, 0, 0, 0, 102, 116, 121, 112, 97, 118, 105, 102].every((t, r2) => !t || e[r2] === t) ? Bg : null;
}
function jg(e) {
  let t = new DataView(e.buffer), r2, n, i = 8, a = false;
  for (; !a && r2 !== "IEND" && i < e.length; ) {
    n = t.getUint32(i);
    let o = e.subarray(i + 4, i + 8);
    r2 = String.fromCharCode(...o), a = r2 === "acTL", i += 12 + n;
  }
  return a;
}
var wa = { accentHeight: "accent-height", alignmentBaseline: "alignment-baseline", arabicForm: "arabic-form", baselineShift: "baseline-shift", capHeight: "cap-height", clipPath: "clip-path", clipRule: "clip-rule", colorInterpolation: "color-interpolation", colorInterpolationFilters: "color-interpolation-filters", colorProfile: "color-profile", colorRendering: "color-rendering", dominantBaseline: "dominant-baseline", enableBackground: "enable-background", fillOpacity: "fill-opacity", fillRule: "fill-rule", floodColor: "flood-color", floodOpacity: "flood-opacity", fontFamily: "font-family", fontSize: "font-size", fontSizeAdjust: "font-size-adjust", fontStretch: "font-stretch", fontStyle: "font-style", fontVariant: "font-variant", fontWeight: "font-weight", glyphName: "glyph-name", glyphOrientationHorizontal: "glyph-orientation-horizontal", glyphOrientationVertical: "glyph-orientation-vertical", horizAdvX: "horiz-adv-x", horizOriginX: "horiz-origin-x", href: "href", imageRendering: "image-rendering", letterSpacing: "letter-spacing", lightingColor: "lighting-color", markerEnd: "marker-end", markerMid: "marker-mid", markerStart: "marker-start", overlinePosition: "overline-position", overlineThickness: "overline-thickness", paintOrder: "paint-order", panose1: "panose-1", pointerEvents: "pointer-events", renderingIntent: "rendering-intent", shapeRendering: "shape-rendering", stopColor: "stop-color", stopOpacity: "stop-opacity", strikethroughPosition: "strikethrough-position", strikethroughThickness: "strikethrough-thickness", strokeDasharray: "stroke-dasharray", strokeDashoffset: "stroke-dashoffset", strokeLinecap: "stroke-linecap", strokeLinejoin: "stroke-linejoin", strokeMiterlimit: "stroke-miterlimit", strokeOpacity: "stroke-opacity", strokeWidth: "stroke-width", textAnchor: "text-anchor", textDecoration: "text-decoration", textRendering: "text-rendering", underlinePosition: "underline-position", underlineThickness: "underline-thickness", unicodeBidi: "unicode-bidi", unicodeRange: "unicode-range", unitsPerEm: "units-per-em", vAlphabetic: "v-alphabetic", vHanging: "v-hanging", vIdeographic: "v-ideographic", vMathematical: "v-mathematical", vectorEffect: "vector-effect", vertAdvY: "vert-adv-y", vertOriginX: "vert-origin-x", vertOriginY: "vert-origin-y", wordSpacing: "word-spacing", writingMode: "writing-mode", xHeight: "x-height", xlinkActuate: "xlink:actuate", xlinkArcrole: "xlink:arcrole", xlinkHref: "xlink:href", xlinkRole: "xlink:role", xlinkShow: "xlink:show", xlinkTitle: "xlink:title", xlinkType: "xlink:type", xmlBase: "xml:base", xmlLang: "xml:lang", xmlSpace: "xml:space", xmlnsXlink: "xmlns:xlink" };
var zg = /[\r\n%#()<>?[\\\]^`{|}"']/g;
function Ea(e, t) {
  if (!e)
    return "";
  if (Array.isArray(e))
    return e.map((l) => Ea(l, t)).join("");
  if (typeof e != "object")
    return String(e);
  let r2 = e.type;
  if (r2 === "text")
    throw new Error("<text> nodes are not currently supported, please convert them to <path>");
  let { children: n, style: i, ...a } = e.props || {}, o = i?.color || t, u = `${Object.entries(a).map(([l, f]) => (typeof f == "string" && f.toLowerCase() === "currentcolor" && (f = o), l === "href" && r2 === "image" ? ` ${wa[l] || l}="${cr.get(f)[0]}"` : ` ${wa[l] || l}="${f}"`)).join("")}`, s = i ? ` style="${Object.entries(i).map(([l, f]) => `${Ug(l)}:${f}`).join(";")}"` : "";
  return `<${r2}${u}${s}>${Ea(n, o)}</${r2}>`;
}
async function Vg(e) {
  let t = /* @__PURE__ */ new Set(), r2 = (n) => {
    if (n && jn(n)) {
      if (Array.isArray(n)) {
        n.forEach((i) => r2(i));
        return;
      } else
        typeof n == "object" && (n.type === "image" ? t.has(n.props.href) || t.add(n.props.href) : n.type === "img" && (t.has(n.props.src) || t.add(n.props.src)));
      Array.isArray(n.props.children) ? n.props.children.map((i) => r2(i)) : r2(n.props.children);
    }
  };
  return r2(e), Promise.all(Array.from(t).map((n) => Na(n)));
}
async function Hg(e, t) {
  let { viewBox: r2, viewbox: n, width: i, height: a, className: o, style: u, children: s, ...l } = e.props || {};
  r2 ||= n, l.xmlns = "http://www.w3.org/2000/svg";
  let f = u?.color || t, c = Ua(r2), p2 = c ? c[3] / c[2] : null;
  return i = i || p2 && a ? a / p2 : null, a = a || p2 && i ? i * p2 : null, l.width = i, l.height = a, r2 && (l.viewBox = r2), `data:image/svg+xml;utf8,${`<svg ${Object.entries(l).map(([d, D]) => (typeof D == "string" && D.toLowerCase() === "currentcolor" && (D = f), ` ${wa[d] || d}="${D}"`)).join("")}>${Ea(s, f)}</svg>`.replace(zg, encodeURIComponent)}`;
}
var Et = "flex";
var Xg = { p: { display: Et, marginTop: "1em", marginBottom: "1em" }, div: { display: Et }, blockquote: { display: Et, marginTop: "1em", marginBottom: "1em", marginLeft: 40, marginRight: 40 }, center: { display: Et, textAlign: "center" }, hr: { display: Et, marginTop: "0.5em", marginBottom: "0.5em", marginLeft: "auto", marginRight: "auto", borderWidth: 1, borderStyle: "solid" }, h1: { display: Et, fontSize: "2em", marginTop: "0.67em", marginBottom: "0.67em", marginLeft: 0, marginRight: 0, fontWeight: "bold" }, h2: { display: Et, fontSize: "1.5em", marginTop: "0.83em", marginBottom: "0.83em", marginLeft: 0, marginRight: 0, fontWeight: "bold" }, h3: { display: Et, fontSize: "1.17em", marginTop: "1em", marginBottom: "1em", marginLeft: 0, marginRight: 0, fontWeight: "bold" }, h4: { display: Et, marginTop: "1.33em", marginBottom: "1.33em", marginLeft: 0, marginRight: 0, fontWeight: "bold" }, h5: { display: Et, fontSize: "0.83em", marginTop: "1.67em", marginBottom: "1.67em", marginLeft: 0, marginRight: 0, fontWeight: "bold" }, h6: { display: Et, fontSize: "0.67em", marginTop: "2.33em", marginBottom: "2.33em", marginLeft: 0, marginRight: 0, fontWeight: "bold" }, u: { textDecoration: "underline" }, strong: { fontWeight: "bold" }, b: { fontWeight: "bold" }, i: { fontStyle: "italic" }, em: { fontStyle: "italic" }, code: { fontFamily: "monospace" }, kbd: { fontFamily: "monospace" }, pre: { display: Et, fontFamily: "monospace", whiteSpace: "pre", marginTop: "1em", marginBottom: "1em" }, mark: { backgroundColor: "yellow", color: "black" }, big: { fontSize: "larger" }, small: { fontSize: "smaller" }, s: { textDecoration: "line-through" } };
var qg = /* @__PURE__ */ new Set(["color", "font", "fontFamily", "fontSize", "fontStyle", "fontWeight", "letterSpacing", "lineHeight", "textAlign", "textTransform", "textShadowOffset", "textShadowColor", "textShadowRadius", "textDecorationLine", "textDecorationStyle", "textDecorationColor", "whiteSpace", "transform", "wordBreak", "tabSize", "opacity", "filter", "_viewportWidth", "_viewportHeight", "_inheritedClipPathId", "_inheritedMaskId", "_inheritedBackgroundClipTextPath"]);
function Yg(e) {
  let t = {};
  for (let r2 in e)
    qg.has(r2) && (t[r2] = e[r2]);
  return t;
}
function Zg(e, t) {
  try {
    let r2 = new Qn(e);
    switch (r2.unit) {
      case "px":
        return { absolute: r2.value };
      case "em":
        return { absolute: r2.value * t };
      case "rem":
        return { absolute: r2.value * 16 };
      case "%":
        return { relative: r2.value };
      default:
        return {};
    }
  } catch {
    return {};
  }
}
function da(e, t, r2) {
  switch (e) {
    case "top":
      return { yRelative: 0 };
    case "left":
      return { xRelative: 0 };
    case "right":
      return { xRelative: 100 };
    case "bottom":
      return { yRelative: 100 };
    case "center":
      return {};
    default: {
      let n = Zg(e, t);
      return n.absolute ? { [r2 ? "xAbsolute" : "yAbsolute"]: n.absolute } : n.relative ? { [r2 ? "xRelative" : "yRelative"]: n.relative } : {};
    }
  }
}
function Jg(e, t) {
  if (typeof e == "number")
    return { xAbsolute: e };
  let r2;
  try {
    r2 = (0, yl.default)(e).nodes.filter((n) => n.type === "word").map((n) => n.value);
  } catch {
    return {};
  }
  return r2.length === 1 ? da(r2[0], t, true) : r2.length === 2 ? ((r2[0] === "top" || r2[0] === "bottom" || r2[1] === "left" || r2[1] === "right") && r2.reverse(), { ...da(r2[0], t, true), ...da(r2[1], t, false) }) : {};
}
function Yr(e, t) {
  let r2 = (0, bl.getPropertyName)(`mask-${t}`);
  return e[r2] || e[`WebkitM${r2.substring(1)}`];
}
function Kg(e) {
  let t = e.maskImage || e.WebkitMaskImage, r2 = { position: Yr(e, "position") || "0% 0%", size: Yr(e, "size") || "100% 100%", repeat: Yr(e, "repeat") || "repeat", origin: Yr(e, "origin") || "border-box", clip: Yr(e, "origin") || "border-box" };
  return pl(t).filter((n) => n && n !== "none").reverse().map((n) => ({ image: n, ...r2 }));
}
var Qg = /* @__PURE__ */ new Set(["flex", "flexGrow", "flexShrink", "flexBasis", "fontWeight", "lineHeight", "opacity", "scale", "scaleX", "scaleY"]);
var e1 = /* @__PURE__ */ new Set(["lineHeight"]);
function t1(e, t, r2, n) {
  return e === "textDecoration" && !r2.includes(t.textDecorationColor) && (t.textDecorationColor = n), t;
}
function en(e, t) {
  let r2 = Number(t);
  return isNaN(r2) ? t : Qg.has(e) ? e1.has(e) ? r2 : String(t) : r2 + "px";
}
function r1(e, t, r2) {
  if (e === "lineHeight")
    return { lineHeight: en(e, t) };
  if (e === "fontFamily")
    return { fontFamily: t.split(",").map((n) => n.trim().replace(/(^['"])|(['"]$)/g, "").toLocaleLowerCase()) };
  if (e === "borderRadius") {
    if (typeof t != "string" || !t.includes("/"))
      return;
    let [n, i] = t.split("/"), a = (0, It.getStylesForProperty)(e, n, true), o = (0, It.getStylesForProperty)(e, i, true);
    for (let u in a)
      o[u] = en(e, a[u]) + " " + en(e, o[u]);
    return o;
  }
  if (/^border(Top|Right|Bottom|Left)?$/.test(e)) {
    let n = (0, It.getStylesForProperty)("border", t, true);
    n.borderWidth === 1 && !String(t).includes("1px") && (n.borderWidth = 3), n.borderColor === "black" && !String(t).includes("black") && (n.borderColor = r2);
    let i = { Width: en(e + "Width", n.borderWidth), Style: Lt(n.borderStyle, { solid: "solid", dashed: "dashed" }, "solid", e + "Style"), Color: n.borderColor }, a = {};
    for (let o of e === "border" ? ["Top", "Right", "Bottom", "Left"] : [e.slice(6)])
      for (let u in i)
        a["border" + o + u] = i[u];
    return a;
  }
  if (e === "boxShadow") {
    if (!t)
      throw new Error('Invalid `boxShadow` value: "' + t + '".');
    return { [e]: typeof t == "string" ? (0, ml.parse)(t) : t };
  }
  if (e === "transform") {
    if (typeof t != "string")
      throw new Error("Invalid `transform` value.");
    let n = {}, i = t.replace(/(-?[\d.]+%)/g, (o, u) => {
      let s = ~~(Math.random() * 1e9);
      return n[s] = u, s + "px";
    }), a = (0, It.getStylesForProperty)("transform", i, true);
    for (let o of a.transform)
      for (let u in o)
        n[o[u]] && (o[u] = n[o[u]]);
    return a;
  }
  if (e === "background")
    return t = t.toString().trim(), /^(linear-gradient|radial-gradient|url)\(/.test(t) ? (0, It.getStylesForProperty)("backgroundImage", t, true) : (0, It.getStylesForProperty)("background", t, true);
  if (e === "textShadow") {
    t = t.toString().trim();
    let n = {}, i = pl(t);
    for (let a of i) {
      let o = (0, It.getStylesForProperty)("textShadow", a, true);
      for (let u in o)
        n[u] ? n[u].push(o[u]) : n[u] = [o[u]];
    }
    return n;
  }
}
function cu(e) {
  return e === "transform" ? " Only absolute lengths such as `10px` are supported." : "";
}
var pu = /rgb\((\d+)\s+(\d+)\s+(\d+)\s*\/\s*([\.\d]+)\)/;
function xl(e) {
  if (typeof e == "string" && pu.test(e.trim()))
    return e.trim().replace(pu, (t, r2, n, i, a) => `rgba(${r2}, ${n}, ${i}, ${a})`);
  if (typeof e == "object" && e !== null) {
    for (let t in e)
      e[t] = xl(e[t]);
    return e;
  }
  return e;
}
function hu(e, t) {
  let r2 = {};
  if (e) {
    let i = i1(e.color, t.color);
    r2.color = i;
    for (let a in e) {
      if (a.startsWith("_")) {
        r2[a] = e[a];
        continue;
      }
      if (a === "color")
        continue;
      let o = (0, It.getPropertyName)(a), u = o1(e[a], i);
      try {
        let s = r1(o, u, i) || t1(o, (0, It.getStylesForProperty)(o, en(o, u), true), u, i);
        Object.assign(r2, s);
      } catch (s) {
        throw new Error(s.message + (s.message.includes(u) ? `
  ` + cu(o) : `
  in CSS rule \`${o}: ${u}\`.${cu(o)}`));
      }
    }
  }
  if (r2.backgroundImage) {
    let { backgrounds: i } = (0, gl.parseElementStyle)(r2);
    r2.backgroundImage = i;
  }
  (r2.maskImage || r2.WebkitMaskImage) && (r2.maskImage = Kg(r2));
  let n = n1(r2.fontSize, t.fontSize);
  typeof r2.fontSize < "u" && (r2.fontSize = n), r2.transformOrigin && (r2.transformOrigin = Jg(r2.transformOrigin, n));
  for (let i in r2) {
    let a = r2[i];
    if (i === "lineHeight")
      typeof a == "string" && (a = r2[i] = Ie(a, n, n, t, true) / n);
    else {
      if (typeof a == "string") {
        let o = Ie(a, n, n, t);
        typeof o < "u" && (r2[i] = o), a = r2[i];
      }
      if (typeof a == "string" || typeof a == "object") {
        let o = xl(a);
        o && (r2[i] = o), a = r2[i];
      }
    }
    if (i === "opacity" && typeof a == "number" && (r2.opacity = a * t.opacity), i === "transform") {
      let o = a;
      for (let u of o) {
        let s = Object.keys(u)[0], l = u[s], f = typeof l == "string" ? Ie(l, n, n, t) ?? l : l;
        u[s] = f;
      }
    }
    if (i === "textShadowRadius") {
      let o = a;
      r2.textShadowRadius = o.map((u) => Ie(u, n, 0, t, false));
    }
    if (i === "textShadowOffset") {
      let o = a;
      r2.textShadowOffset = o.map(({ height: u, width: s }) => ({ height: Ie(u, n, 0, t, false), width: Ie(s, n, 0, t, false) }));
    }
  }
  return r2;
}
function n1(e, t) {
  if (typeof e == "number")
    return e;
  try {
    let r2 = new Qn(e);
    switch (r2.unit) {
      case "em":
        return r2.value * t;
      case "rem":
        return r2.value * 16;
    }
  } catch {
    return t;
  }
}
function du(e) {
  if (e.startsWith("hsl")) {
    let t = (0, Dl.default)(e), [r2, n, i] = t.values;
    return `hsl(${[r2, `${n}%`, `${i}%`].concat(t.alpha === 1 ? [] : [t.alpha]).join(",")})`;
  }
  return e;
}
function i1(e, t) {
  return e && e.toLowerCase() !== "currentcolor" ? du(e) : du(t);
}
function a1(e, t) {
  return e.replace(/currentcolor/gi, t);
}
function o1(e, t) {
  return cl(e) && (e = a1(e, t)), e;
}
async function s1(e, t, r2, n, i) {
  let a = await Kn(), o = { ...r2, ...hu(Xg[t], r2), ...hu(n, r2) };
  if (t === "img") {
    let [u, s, l] = await Na(i.src);
    if (s === void 0 && l === void 0) {
      if (i.width === void 0 || i.height === void 0)
        throw new Error("Image size cannot be determined. Please provide the width and height of the image.");
      s = parseInt(i.width), l = parseInt(i.height);
    }
    let f = l / s, c = (o.borderLeftWidth || 0) + (o.borderRightWidth || 0) + (o.paddingLeft || 0) + (o.paddingRight || 0), p2 = (o.borderTopWidth || 0) + (o.borderBottomWidth || 0) + (o.paddingTop || 0) + (o.paddingBottom || 0), d = o.width || i.width, D = o.height || i.height, v = typeof d == "number" && typeof D == "number";
    v && (d -= c, D -= p2), d === void 0 && D === void 0 ? (d = "100%", e.setAspectRatio(1 / f)) : d === void 0 ? typeof D == "number" ? d = D / f : e.setAspectRatio(1 / f) : D === void 0 && (typeof d == "number" ? D = d * f : e.setAspectRatio(1 / f)), o.width = v ? d + c : d, o.height = v ? D + p2 : D, o.__src = u;
  }
  if (t === "svg") {
    let u = i.viewBox || i.viewbox, s = Ua(u), l = s ? s[3] / s[2] : null, { width: f, height: c } = i;
    typeof f > "u" && c ? l == null ? f = 0 : typeof c == "string" && c.endsWith("%") ? f = parseInt(c) / l + "%" : (c = Ie(c, r2.fontSize, 1, r2), f = c / l) : typeof c > "u" && f ? l == null ? f = 0 : typeof f == "string" && f.endsWith("%") ? c = parseInt(f) * l + "%" : (f = Ie(f, r2.fontSize, 1, r2), c = f * l) : (typeof f < "u" && (f = Ie(f, r2.fontSize, 1, r2) || f), typeof c < "u" && (c = Ie(c, r2.fontSize, 1, r2) || c), f ||= s?.[2], c ||= s?.[3]), !o.width && f && (o.width = f), !o.height && c && (o.height = c);
  }
  return e.setDisplay(Lt(o.display, { flex: a.DISPLAY_FLEX, block: a.DISPLAY_FLEX, none: a.DISPLAY_NONE, "-webkit-box": a.DISPLAY_FLEX }, a.DISPLAY_FLEX, "display")), e.setAlignContent(Lt(o.alignContent, { stretch: a.ALIGN_STRETCH, center: a.ALIGN_CENTER, "flex-start": a.ALIGN_FLEX_START, "flex-end": a.ALIGN_FLEX_END, "space-between": a.ALIGN_SPACE_BETWEEN, "space-around": a.ALIGN_SPACE_AROUND, baseline: a.ALIGN_BASELINE, normal: a.ALIGN_AUTO }, a.ALIGN_AUTO, "alignContent")), e.setAlignItems(Lt(o.alignItems, { stretch: a.ALIGN_STRETCH, center: a.ALIGN_CENTER, "flex-start": a.ALIGN_FLEX_START, "flex-end": a.ALIGN_FLEX_END, baseline: a.ALIGN_BASELINE, normal: a.ALIGN_AUTO }, a.ALIGN_STRETCH, "alignItems")), e.setAlignSelf(Lt(o.alignSelf, { stretch: a.ALIGN_STRETCH, center: a.ALIGN_CENTER, "flex-start": a.ALIGN_FLEX_START, "flex-end": a.ALIGN_FLEX_END, baseline: a.ALIGN_BASELINE, normal: a.ALIGN_AUTO }, a.ALIGN_AUTO, "alignSelf")), e.setJustifyContent(Lt(o.justifyContent, { center: a.JUSTIFY_CENTER, "flex-start": a.JUSTIFY_FLEX_START, "flex-end": a.JUSTIFY_FLEX_END, "space-between": a.JUSTIFY_SPACE_BETWEEN, "space-around": a.JUSTIFY_SPACE_AROUND }, a.JUSTIFY_FLEX_START, "justifyContent")), e.setFlexDirection(Lt(o.flexDirection, { row: a.FLEX_DIRECTION_ROW, column: a.FLEX_DIRECTION_COLUMN, "row-reverse": a.FLEX_DIRECTION_ROW_REVERSE, "column-reverse": a.FLEX_DIRECTION_COLUMN_REVERSE }, a.FLEX_DIRECTION_ROW, "flexDirection")), e.setFlexWrap(Lt(o.flexWrap, { wrap: a.WRAP_WRAP, nowrap: a.WRAP_NO_WRAP, "wrap-reverse": a.WRAP_WRAP_REVERSE }, a.WRAP_NO_WRAP, "flexWrap")), typeof o.gap < "u" && e.setGap(a.GUTTER_ALL, o.gap), typeof o.rowGap < "u" && e.setGap(a.GUTTER_ROW, o.rowGap), typeof o.columnGap < "u" && e.setGap(a.GUTTER_COLUMN, o.columnGap), typeof o.flexBasis < "u" && e.setFlexBasis(o.flexBasis), e.setFlexGrow(typeof o.flexGrow > "u" ? 0 : o.flexGrow), e.setFlexShrink(typeof o.flexShrink > "u" ? 0 : o.flexShrink), typeof o.maxHeight < "u" && e.setMaxHeight(o.maxHeight), typeof o.maxWidth < "u" && e.setMaxWidth(o.maxWidth), typeof o.minHeight < "u" && e.setMinHeight(o.minHeight), typeof o.minWidth < "u" && e.setMinWidth(o.minWidth), e.setOverflow(Lt(o.overflow, { visible: a.OVERFLOW_VISIBLE, hidden: a.OVERFLOW_HIDDEN }, a.OVERFLOW_VISIBLE, "overflow")), e.setMargin(a.EDGE_TOP, o.marginTop || 0), e.setMargin(a.EDGE_BOTTOM, o.marginBottom || 0), e.setMargin(a.EDGE_LEFT, o.marginLeft || 0), e.setMargin(a.EDGE_RIGHT, o.marginRight || 0), e.setBorder(a.EDGE_TOP, o.borderTopWidth || 0), e.setBorder(a.EDGE_BOTTOM, o.borderBottomWidth || 0), e.setBorder(a.EDGE_LEFT, o.borderLeftWidth || 0), e.setBorder(a.EDGE_RIGHT, o.borderRightWidth || 0), e.setPadding(a.EDGE_TOP, o.paddingTop || 0), e.setPadding(a.EDGE_BOTTOM, o.paddingBottom || 0), e.setPadding(a.EDGE_LEFT, o.paddingLeft || 0), e.setPadding(a.EDGE_RIGHT, o.paddingRight || 0), e.setPositionType(Lt(o.position, { absolute: a.POSITION_TYPE_ABSOLUTE, relative: a.POSITION_TYPE_RELATIVE }, a.POSITION_TYPE_RELATIVE, "position")), typeof o.top < "u" && e.setPosition(a.EDGE_TOP, o.top), typeof o.bottom < "u" && e.setPosition(a.EDGE_BOTTOM, o.bottom), typeof o.left < "u" && e.setPosition(a.EDGE_LEFT, o.left), typeof o.right < "u" && e.setPosition(a.EDGE_RIGHT, o.right), typeof o.height < "u" ? e.setHeight(o.height) : e.setHeightAuto(), typeof o.width < "u" ? e.setWidth(o.width) : e.setWidthAuto(), [o, Yg(o)];
}
var vu = [1, 0, 0, 1, 0, 0];
function u1(e, t, r2) {
  let n = [...vu];
  for (let i of e) {
    let a = Object.keys(i)[0], o = i[a];
    if (typeof o == "string")
      if (a === "translateX")
        o = parseFloat(o) / 100 * t, i[a] = o;
      else if (a === "translateY")
        o = parseFloat(o) / 100 * r2, i[a] = o;
      else
        throw new Error(`Invalid transform: "${a}: ${o}".`);
    let u = o, s = [...vu];
    switch (a) {
      case "translateX":
        s[4] = u;
        break;
      case "translateY":
        s[5] = u;
        break;
      case "scale":
        s[0] = u, s[3] = u;
        break;
      case "scaleX":
        s[0] = u;
        break;
      case "scaleY":
        s[3] = u;
        break;
      case "rotate": {
        let l = u * Math.PI / 180, f = Math.cos(l), c = Math.sin(l);
        s[0] = f, s[1] = c, s[2] = -c, s[3] = f;
        break;
      }
      case "skewX":
        s[2] = Math.tan(u * Math.PI / 180);
        break;
      case "skewY":
        s[1] = Math.tan(u * Math.PI / 180);
        break;
    }
    n = zn(s, n);
  }
  e.splice(0, e.length), e.push(...n), e.__resolved = true;
}
function wl({ left: e, top: t, width: r2, height: n }, i, a, o) {
  let u;
  i.__resolved || u1(i, r2, n);
  let s = i;
  if (a)
    u = s;
  else {
    let l = o?.xAbsolute ?? (o?.xRelative ?? 50) * r2 / 100, f = o?.yAbsolute ?? (o?.yRelative ?? 50) * n / 100, c = e + l, p2 = t + f;
    u = zn([1, 0, 0, 1, c, p2], zn(s, [1, 0, 0, 1, -c, -p2])), s.__parent && (u = zn(s.__parent, u)), s.splice(0, 6, ...u);
  }
  return `matrix(${u.map((l) => l.toFixed(2)).join(",")})`;
}
function l1({ left: e, top: t, width: r2, height: n, isInheritingTransform: i }, a) {
  let o = "", u = 1;
  return a.transform && (o = wl({ left: e, top: t, width: r2, height: n }, a.transform, i, a.transformOrigin)), a.opacity !== void 0 && (u = +a.opacity), { matrix: o, opacity: u };
}
function f1({ id: e, content: t, filter: r2, left: n, top: i, width: a, height: o, matrix: u, opacity: s, image: l, clipPathId: f, debug: c, shape: p2, decorationShape: d }, D) {
  let v = "";
  if (c && (v = ue("rect", { x: n, y: i - o, width: a, height: o, fill: "transparent", stroke: "#575eff", "stroke-width": 1, transform: u || void 0, "clip-path": f ? `url(#${f})` : void 0 })), l) {
    let y = { href: l, x: n, y: i, width: a, height: o, transform: u || void 0, "clip-path": f ? `url(#${f})` : void 0, style: D.filter ? `filter:${D.filter}` : void 0 };
    return [(r2 ? `${r2}<g filter="url(#satori_s-${e})">` : "") + ue("image", { ...y, opacity: s !== 1 ? s : void 0 }) + (d || "") + (r2 ? "</g>" : "") + v, ""];
  }
  let g = { x: n, y: i, width: a, height: o, "font-weight": D.fontWeight, "font-style": D.fontStyle, "font-size": D.fontSize, "font-family": D.fontFamily, "letter-spacing": D.letterSpacing || void 0, transform: u || void 0, "clip-path": f ? `url(#${f})` : void 0, style: D.filter ? `filter:${D.filter}` : void 0 };
  return [(r2 ? `${r2}<g filter="url(#satori_s-${e})">` : "") + ue("text", { ...g, fill: D.color, opacity: s !== 1 ? s : void 0 }, (0, Fa.default)(t)) + (d || "") + (r2 ? "</g>" : "") + v, p2 ? ue("text", g, (0, Fa.default)(t)) : ""];
}
function c1(e, t, r2) {
  return e.replace(/([MA])([0-9.-]+),([0-9.-]+)/g, function(n, i, a, o) {
    return i + (parseFloat(a) + t) + "," + (parseFloat(o) + r2);
  });
}
var Pn = 1.1;
function p1({ id: e, width: t, height: r2 }, n) {
  if (!n.shadowColor || !n.shadowOffset || typeof n.shadowRadius > "u")
    return "";
  let i = n.shadowColor.length, a = "", o = "", u = 0, s = t, l = 0, f = r2;
  for (let c = 0; c < i; c++) {
    let p2 = n.shadowRadius[c] * n.shadowRadius[c] / 4;
    u = Math.min(n.shadowOffset[c].width - p2, u), s = Math.max(n.shadowOffset[c].width + p2 + t, s), l = Math.min(n.shadowOffset[c].height - p2, l), f = Math.max(n.shadowOffset[c].height + p2 + r2, f), a += ue("feDropShadow", { dx: n.shadowOffset[c].width, dy: n.shadowOffset[c].height, stdDeviation: n.shadowRadius[c] / 2, "flood-color": n.shadowColor[c], "flood-opacity": 1, ...i > 1 ? { in: "SourceGraphic", result: `satori_s-${e}-result-${c}` } : {} }), i > 1 && (o = ue("feMergeNode", { in: `satori_s-${e}-result-${c}` }) + o);
  }
  return ue("filter", { id: `satori_s-${e}`, x: (u / t * 100 * Pn).toFixed(2) + "%", y: (l / r2 * 100 * Pn).toFixed(2) + "%", width: ((s - u) / t * 100 * Pn).toFixed(2) + "%", height: ((f - l) / r2 * 100 * Pn).toFixed(2) + "%" }, a + (o ? ue("feMerge", {}, o) : ""));
}
function h1({ width: e, height: t, shape: r2, opacity: n, id: i }, a) {
  if (!a.boxShadow)
    return null;
  let o = "", u = "";
  for (let s = a.boxShadow.length - 1; s >= 0; s--) {
    let l = "", f = a.boxShadow[s];
    f.spreadRadius && f.inset && (f.spreadRadius = -f.spreadRadius);
    let c = f.blurRadius * f.blurRadius / 4 + (f.spreadRadius || 0), p2 = Math.min(-c - (f.inset ? f.offsetX : 0), 0), d = Math.max(c + e - (f.inset ? f.offsetX : 0), e), D = Math.min(-c - (f.inset ? f.offsetY : 0), 0), v = Math.max(c + t - (f.inset ? f.offsetY : 0), t), g = `satori_s-${i}-${s}`, y = `satori_ms-${i}-${s}`, b = f.spreadRadius ? r2.replace('stroke-width="0"', `stroke-width="${f.spreadRadius * 2}"`) : r2;
    l += ue("mask", { id: y, maskUnits: "userSpaceOnUse" }, ue("rect", { x: 0, y: 0, width: a._viewportWidth || "100%", height: a._viewportHeight || "100%", fill: f.inset ? "#000" : "#fff" }) + b.replace('fill="#fff"', f.inset ? 'fill="#fff"' : 'fill="#000"').replace('stroke="#fff"', ""));
    let C = b.replace(/d="([^"]+)"/, (k, S) => 'd="' + c1(S, f.offsetX, f.offsetY) + '"').replace(/x="([^"]+)"/, (k, S) => 'x="' + (parseFloat(S) + f.offsetX) + '"').replace(/y="([^"]+)"/, (k, S) => 'y="' + (parseFloat(S) + f.offsetY) + '"');
    f.spreadRadius && f.spreadRadius < 0 && (l += ue("mask", { id: y + "-neg", maskUnits: "userSpaceOnUse" }, C.replace('stroke="#fff"', 'stroke="#000"').replace(/stroke-width="[^"]+"/, `stroke-width="${-f.spreadRadius * 2}"`))), f.spreadRadius && f.spreadRadius < 0 && (C = ue("g", { mask: `url(#${y}-neg)` }, C)), l += ue("defs", {}, ue("filter", { id: g, x: `${p2 / e * 100}%`, y: `${D / t * 100}%`, width: `${(d - p2) / e * 100}%`, height: `${(v - D) / t * 100}%` }, ue("feGaussianBlur", { stdDeviation: f.blurRadius / 2, result: "b" }) + ue("feFlood", { "flood-color": f.color, in: "SourceGraphic", result: "f" }) + ue("feComposite", { in: "f", in2: "b", operator: f.inset ? "out" : "in" }))) + ue("g", { mask: `url(#${y})`, filter: `url(#${g})`, opacity: n }, C), f.inset ? u += l : o += l;
  }
  return [o, u];
}
function d1({ width: e, left: t, top: r2, ascender: n, clipPathId: i }, a) {
  let { textDecorationColor: o, textDecorationStyle: u, textDecorationLine: s, fontSize: l, color: f } = a;
  if (!s || s === "none")
    return "";
  let c = Math.max(1, l * 0.1), p2 = s === "line-through" ? r2 + n * 0.7 : s === "underline" ? r2 + n * 1.1 : r2, d = u === "dashed" ? `${c * 1.2} ${c * 2}` : u === "dotted" ? `0 ${c * 2}` : void 0;
  return ue("line", { x1: t, y1: p2, x2: t + e, y2: p2, stroke: o || f, "stroke-width": c, "stroke-dasharray": d, "stroke-linecap": u === "dotted" ? "round" : "square", "clip-path": i ? `url(#${i})` : void 0 });
}
function Ma(e) {
  return e = e.replace("U+", "0x"), String.fromCodePoint(Number(e));
}
var rn = Ma("U+0020");
var El = Ma("U+0009");
var Vn = Ma("U+2026");
function v1(e, t, r2) {
  let { fontSize: n, letterSpacing: i } = r2, a = /* @__PURE__ */ new Map();
  function o(l) {
    if (a.has(l))
      return a.get(l);
    let f = e.measure(l, { fontSize: n, letterSpacing: i });
    return a.set(l, f), f;
  }
  function u(l) {
    let f = 0;
    for (let c of l)
      t(c) ? f += n : f += o(c);
    return f;
  }
  function s(l) {
    return u(Pt(l, "grapheme"));
  }
  return { measureGrapheme: o, measureGraphemeArray: u, measureText: s };
}
function g1(e, t, r2) {
  let { textTransform: n, whiteSpace: i, wordBreak: a } = t;
  e = m1(e, n, r2);
  let { content: o, shouldCollapseTabsAndSpaces: u, allowSoftWrap: s } = b1(e, i), { words: l, requiredBreaks: f, allowBreakWord: c } = y1(o, a), [p2, d] = D1(t, s);
  return { words: l, requiredBreaks: f, allowSoftWrap: s, allowBreakWord: c, processedContent: o, shouldCollapseTabsAndSpaces: u, lineLimit: p2, blockEllipsis: d };
}
function m1(e, t, r2) {
  return t === "uppercase" ? e = e.toLocaleUpperCase(r2) : t === "lowercase" ? e = e.toLocaleLowerCase(r2) : t === "capitalize" && (e = Pt(e, "word", r2).map((n) => Pt(n, "grapheme", r2).map((i, a) => a === 0 ? i.toLocaleUpperCase(r2) : i).join("")).join("")), e;
}
function D1(e, t) {
  let { textOverflow: r2, lineClamp: n, WebkitLineClamp: i, WebkitBoxOrient: a, overflow: o, display: u } = e;
  if (u === "block" && n) {
    let [s, l = Vn] = x1(n);
    if (s)
      return [s, l];
  }
  return r2 === "ellipsis" && u === "-webkit-box" && a === "vertical" && Ig(i) && i > 0 ? [i, Vn] : r2 === "ellipsis" && o === "hidden" && !t ? [1, Vn] : [1 / 0];
}
function y1(e, t) {
  let r2 = ["break-all", "break-word"].includes(t), { words: n, requiredBreaks: i } = Rg(e, t);
  return { words: n, requiredBreaks: i, allowBreakWord: r2 };
}
function b1(e, t) {
  let r2 = ["pre", "pre-wrap", "pre-line"].includes(t), n = ["normal", "nowrap", "pre-line"].includes(t), i = !["pre", "nowrap"].includes(t);
  return r2 || (e = e.replace(/\n/g, rn)), n && (e = e.replace(/([ ]|\t)+/g, rn).replace(/^[ ]|[ ]$/g, "")), { content: e, shouldCollapseTabsAndSpaces: n, allowSoftWrap: i };
}
function x1(e) {
  if (typeof e == "number")
    return [e];
  let t = /^(\d+)\s*"(.*)"$/, r2 = /^(\d+)\s*'(.*)'$/, n = t.exec(e), i = r2.exec(e);
  if (n) {
    let a = +n[1], o = n[2];
    return [a, o];
  } else if (i) {
    let a = +i[1], o = i[2];
    return [a, o];
  }
  return [];
}
var w1 = /* @__PURE__ */ new Set([El]);
function E1(e) {
  return w1.has(e);
}
async function* F1(e, t) {
  let r2 = await Kn(), { parentStyle: n, inheritedStyle: i, parent: a, font: o, id: u, isInheritingTransform: s, debug: l, embedFont: f, graphemeImages: c, locale: p2, canLoadAdditionalAssets: d } = t, { textAlign: D, lineHeight: v, textWrap: g, fontSize: y, filter: b, tabSize: C = 8, letterSpacing: k, _inheritedBackgroundClipTextPath: S, flexShrink: E } = n, { words: L, requiredBreaks: T, allowSoftWrap: U, allowBreakWord: M, processedContent: H, shouldCollapseTabsAndSpaces: q, lineLimit: ee, blockEllipsis: A } = g1(e, n, p2), R = C1(r2, D);
  a.insertChild(R, a.getChildCount()), Pg(E) && a.setFlexShrink(1);
  let O = o.getEngine(y, v, n, p2), Y = d ? Pt(H, "grapheme").filter((ve) => !E1(ve) && !O.has(ve)) : [];
  yield Y.map((ve) => ({ word: ve, locale: p2 })), Y.length && (O = o.getEngine(y, v, n, p2));
  function Z(ve) {
    return !!(c && c[ve]);
  }
  let { measureGrapheme: te, measureGraphemeArray: ie, measureText: B } = v1(O, Z, { fontSize: y, letterSpacing: k }), z = cl(C) ? Ie(C, y, 1, n) : te(rn) * C, _ = (ve, Le) => {
    if (ve.length === 0)
      return { originWidth: 0, endingSpacesWidth: 0, text: ve };
    let { index: Ue, tabCount: we } = S1(ve), Ne = 0;
    if (we > 0) {
      let $e = ve.slice(0, Ue), Fe = ve.slice(Ue + we), Ce = B($e), pt = Ce + Le;
      Ne = (z === 0 ? Ce : (Math.floor(pt / z) + we) * z) + B(Fe);
    } else
      Ne = B(ve);
    let Ae = ve.trimEnd() === ve ? Ne : B(ve.trimEnd());
    return { originWidth: Ne, endingSpacesWidth: Ne - Ae, text: ve };
  }, N = [], ae = [], W = [], fe = [], ce = [];
  function ge(ve) {
    let Le = 0, Ue = 0, we = -1, Ne = 0, Ae = 0, $e = 0, Fe = 0;
    N = [], W = [0], fe = [], ce = [];
    let Ce = 0, pt = 0;
    for (; Ce < L.length && Le < ee; ) {
      let me = L[Ce], Bt = T[Ce], Ke = 0, { originWidth: yt, endingSpacesWidth: rr, text: bt } = _(me, Ae);
      me = bt, Ke = yt;
      let Pe = rr;
      Bt && $e === 0 && ($e = O.height(me));
      let Ye = ",.!?:-@)>]}%#".indexOf(me[0]) < 0, ht = !Ae, wr = Ce && Ye && Ae + Ke > ve + Pe && U;
      if (M && Ke > ve && (!Ae || wr || Bt)) {
        let Qe = Pt(me, "grapheme");
        L.splice(Ce, 1, ...Qe), Ae > 0 && (N.push(Ae - pt), ae.push(Fe), Le++, Ne += $e, Ae = 0, $e = 0, Fe = 0, W.push(1), we = -1), pt = Pe;
        continue;
      }
      if (Bt || wr)
        q && me === rn && (Ke = 0), N.push(Ae - pt), ae.push(Fe), Le++, Ne += $e, Ae = Ke, $e = Ke ? O.height(me) : 0, Fe = Ke ? O.baseline(me) : 0, W.push(1), we = -1, Bt || (Ue = Math.max(Ue, ve));
      else {
        Ae += Ke;
        let Qe = O.height(me);
        Qe > $e && ($e = Qe, Fe = O.baseline(me)), ht && W[W.length - 1]++;
      }
      ht && we++, Ue = Math.max(Ue, Ae);
      let hr = Ae - Ke;
      if (Ke === 0)
        ce.push({ y: Ne, x: hr, width: 0, line: Le, lineIndex: we, isImage: false });
      else {
        let Qe = Pt(me, "word");
        for (let dt = 0; dt < Qe.length; dt++) {
          let Vt = Qe[dt], xt = 0, Nt = false;
          Z(Vt) ? (xt = y, Nt = true) : xt = te(Vt), fe.push(Vt), ce.push({ y: Ne, x: hr, width: xt, line: Le, lineIndex: we, isImage: Nt }), hr += xt;
        }
      }
      Ce++, pt = Pe;
    }
    return Ae && (Le < ee && (Ne += $e), Le++, N.push(Ae), ae.push(Fe)), { width: Ue, height: Ne };
  }
  let pe = { width: 0, height: 0 };
  R.setMeasureFunc((ve) => {
    let { width: Le, height: Ue } = ge(ve);
    if (g === "balance") {
      let Ne = Le / 2, Ae = Le, $e = Le;
      for (; Ne + 1 < Ae; ) {
        $e = (Ne + Ae) / 2;
        let { height: Ce } = ge($e);
        Ce > Ue ? Ne = $e : Ae = $e;
      }
      ge(Ae);
      let Fe = Math.ceil(Ae);
      return pe = { width: Fe, height: Ue }, { width: Fe, height: Ue };
    }
    let we = Math.ceil(Le);
    return pe = { width: we, height: Ue }, { width: we, height: Ue };
  });
  let [xe, _e] = yield, he = "", ye = "", Ge = i._inheritedClipPathId, tt = i._inheritedMaskId, { left: We, top: Be, width: He, height: rt } = R.getComputedLayout(), nt = a.getComputedWidth() - a.getComputedPadding(r2.EDGE_LEFT) - a.getComputedPadding(r2.EDGE_RIGHT) - a.getComputedBorder(r2.EDGE_LEFT) - a.getComputedBorder(r2.EDGE_RIGHT), it = xe + We, at = _e + Be, { matrix: Xe, opacity: Ct } = l1({ left: We, top: Be, width: He, height: rt, isInheritingTransform: s }, n), Dt = "";
  if (n.textShadowOffset) {
    let { textShadowColor: ve, textShadowOffset: Le, textShadowRadius: Ue } = n;
    Dt = p1({ width: pe.width, height: pe.height, id: u }, { shadowColor: ve, shadowOffset: Le, shadowRadius: Ue }), Dt = ue("defs", {}, Dt);
  }
  let ft = "", ct = "", zt = "", lt = -1, Ut = {}, qe = null, xr = 0;
  for (let ve = 0; ve < fe.length; ve++) {
    let Le = ce[ve], Ue = ce[ve + 1];
    if (!Le)
      continue;
    let we = fe[ve], Ne = null, Ae = false, $e = c ? c[we] : null, Fe = Le.y, Ce = Le.x, pt = Le.width, me = Le.line;
    if (me === lt)
      continue;
    let Bt = false;
    if (N.length > 1) {
      let Pe = He - N[me];
      if (D === "right" || D === "end")
        Ce += Pe;
      else if (D === "center")
        Ce += Pe / 2;
      else if (D === "justify" && me < N.length - 1) {
        let Ye = W[me], ht = Ye > 1 ? Pe / (Ye - 1) : 0;
        Ce += ht * Le.lineIndex, Bt = true;
      }
    }
    let Ke = ae[me], yt = O.baseline(we), rr = O.height(we), bt = Ke - yt;
    if (Ut[me] || (Ut[me] = [Ce, at + Fe + bt, yt, Bt ? He : N[me]]), ee !== 1 / 0) {
      let Pe = function(Qe, dt) {
        let Vt = Pt(dt, "grapheme", p2), xt = "", Nt = 0;
        for (let Or of Vt) {
          let pn = Qe + ie([xt + Or]);
          if (xt && pn + ht > nt)
            break;
          xt += Or, Nt = pn;
        }
        return { subset: xt, resolvedWidth: Nt };
      }, Ye = A, ht = te(A);
      ht > nt && (Ye = Vn, ht = te(Ye));
      let wr = te(rn), hr = me < N.length - 1;
      if (me + 1 === ee && (hr || N[me] > nt)) {
        if (Ce + pt + ht + wr > nt) {
          let { subset: Qe, resolvedWidth: dt } = Pe(Ce, we);
          we = Qe + Ye, lt = me, Ut[me][2] = dt, Ae = true;
        } else if (Ue && Ue.line !== me)
          if (D === "center") {
            let { subset: Qe, resolvedWidth: dt } = Pe(Ce, we);
            we = Qe + Ye, lt = me, Ut[me][2] = dt, Ae = true;
          } else {
            let Qe = fe[ve + 1], { subset: dt, resolvedWidth: Vt } = Pe(pt + Ce, Qe);
            we = we + dt + Ye, lt = me, Ut[me][2] = Vt, Ae = true;
          }
      }
    }
    if ($e)
      Fe += 0;
    else if (f) {
      if (!we.includes(El) && !Ag.includes(we) && fe[ve + 1] && Ue && !Ue.isImage && Fe === Ue.y && !Ae) {
        qe === null && (xr = Ce), qe = qe === null ? we : qe + we;
        continue;
      }
      let Pe = qe === null ? we : qe + we, Ye = qe === null ? Ce : xr, ht = Le.width + Ce - Ye;
      Ne = O.getSVG(Pe.replace(/(\t)+/g, ""), { fontSize: y, left: it + Ye, top: at + Fe + yt + bt, letterSpacing: k }), qe = null, l && (zt += ue("rect", { x: it + Ye, y: at + Fe + bt, width: ht, height: rr, fill: "transparent", stroke: "#575eff", "stroke-width": 1, transform: Xe || void 0, "clip-path": Ge ? `url(#${Ge})` : void 0 }) + ue("line", { x1: it + Ce, x2: it + Ce + Le.width, y1: at + Fe + bt + yt, y2: at + Fe + bt + yt, stroke: "#14c000", "stroke-width": 1, transform: Xe || void 0, "clip-path": Ge ? `url(#${Ge})` : void 0 }));
    } else
      Fe += yt + bt;
    if (n.textDecorationLine) {
      let Pe = Ut[me];
      Pe && !Pe[4] && (ft += d1({ left: it + Pe[0], top: Pe[1], width: Pe[3], ascender: Pe[2], clipPathId: Ge }, n), Pe[4] = 1);
    }
    if (Ne !== null)
      ct += Ne + " ";
    else {
      let [Pe, Ye] = f1({ content: we, filter: Dt, id: u, left: it + Ce, top: at + Fe, width: pt, height: rr, matrix: Xe, opacity: Ct, image: $e, clipPathId: Ge, debug: l, shape: !!S, decorationShape: ft }, n);
      he += Pe, ye += Ye, ft = "";
    }
    if (Ae)
      break;
  }
  if (ct) {
    let ve = n.color !== "transparent" && Ct !== 0 ? ue("path", { fill: n.color, d: ct, transform: Xe || void 0, opacity: Ct !== 1 ? Ct : void 0, "clip-path": Ge ? `url(#${Ge})` : void 0, mask: tt ? `url(#${tt})` : void 0, style: b ? `filter:${b}` : void 0 }) : "";
    S && (ye = ue("path", { d: ct, transform: Xe || void 0 })), he += (Dt ? Dt + ue("g", { filter: `url(#satori_s-${u})` }, ve + ft) : ve + ft) + zt;
  }
  return ye && (n._inheritedBackgroundClipTextPath.value += ye), he;
}
function C1(e, t) {
  let r2 = e.Node.create();
  return r2.setAlignItems(e.ALIGN_BASELINE), r2.setJustifyContent(Lt(t, { left: e.JUSTIFY_FLEX_START, right: e.JUSTIFY_FLEX_END, center: e.JUSTIFY_CENTER, justify: e.JUSTIFY_SPACE_BETWEEN, start: e.JUSTIFY_FLEX_START, end: e.JUSTIFY_FLEX_END }, e.JUSTIFY_FLEX_START, "textAlign")), r2;
}
function S1(e) {
  let t = /(\t)+/.exec(e);
  return t ? { index: t.index, tabCount: t[0].length } : { index: null, tabCount: 0 };
}
var Ga = Ga || {};
var gu = { type: "directional", value: "bottom" };
Ga.parse = function() {
  var e = { linearGradient: /^(\-(webkit|o|ms|moz)\-)?(linear\-gradient)/i, repeatingLinearGradient: /^(\-(webkit|o|ms|moz)\-)?(repeating\-linear\-gradient)/i, radialGradient: /^(\-(webkit|o|ms|moz)\-)?(radial\-gradient)/i, repeatingRadialGradient: /^(\-(webkit|o|ms|moz)\-)?(repeating\-radial\-gradient)/i, sideOrCorner: /^to (left (top|bottom)|right (top|bottom)|top (left|right)|bottom (left|right)|left|right|top|bottom)/i, extentKeywords: /^(closest\-side|closest\-corner|farthest\-side|farthest\-corner|contain|cover)/, positionKeywords: /^(left|center|right|top|bottom)/i, pixelValue: /^(-?(([0-9]*\.[0-9]+)|([0-9]+\.?)))px/, percentageValue: /^(-?(([0-9]*\.[0-9]+)|([0-9]+\.?)))\%/, emLikeValue: /^(-?(([0-9]*\.[0-9]+)|([0-9]+\.?)))(r?em|vw|vh)/, angleValue: /^(-?(([0-9]*\.[0-9]+)|([0-9]+\.?)))deg/, zeroValue: /[0]/, startCall: /^\(/, endCall: /^\)/, comma: /^,/, hexColor: /^\#([0-9a-fA-F]+)/, literalColor: /^([a-zA-Z]+)/, rgbColor: /^rgb/i, rgbaColor: /^rgba/i, number: /^(([0-9]*\.[0-9]+)|([0-9]+\.?))/ }, t = "";
  function r2(B) {
    var z = new Error(t + ": " + B);
    throw z.source = t, z;
  }
  function n() {
    var B = i();
    return t.length > 0 && r2("Invalid input not EOF"), B;
  }
  function i() {
    return E(a);
  }
  function a() {
    return u("linear-gradient", e.linearGradient, l, gu) || u("repeating-linear-gradient", e.repeatingLinearGradient, l, gu) || u("radial-gradient", e.radialGradient, d) || u("repeating-radial-gradient", e.repeatingRadialGradient, d);
  }
  function o(B = {}) {
    var z, _, N, ae;
    let W = { ...B };
    return Object.assign(W, { style: (W.style || []).length > 0 ? W.style : [{ type: "extent-keyword", value: "farthest-corner" }], at: { type: "position", value: { x: { type: "position-keyword", value: "center", ...((_ = (z = W.at) == null ? void 0 : z.value) == null ? void 0 : _.x) || {} }, y: { type: "position-keyword", value: "center", ...((ae = (N = W.at) == null ? void 0 : N.value) == null ? void 0 : ae.y) || {} } } } }), B.value || Object.assign(W, { type: "shape", value: W.style.some((fe) => ["%", "extent-keyword"].includes(fe.type)) ? "ellipse" : "circle" }), W;
  }
  function u(B, z, _, N) {
    return s(z, function(ae) {
      var W = _();
      return W ? te(e.comma) || r2("Missing comma before color stops") : W = N, { type: B, orientation: B.endsWith("radial-gradient") ? W?.map((fe) => o(fe)) ?? [o()] : W, colorStops: E(L) };
    });
  }
  function s(B, z) {
    var _ = te(B);
    if (_) {
      te(e.startCall) || r2("Missing (");
      var N = z(_);
      return te(e.endCall) || r2("Missing )"), N;
    }
  }
  function l() {
    return f() || c() || p2();
  }
  function f() {
    return Z("directional", e.sideOrCorner, 1);
  }
  function c() {
    return Z("angular", e.angleValue, 1);
  }
  function p2() {
    return Z("directional", e.zeroValue, 0);
  }
  function d() {
    var B, z = D(), _;
    return z && (B = [], B.push(z), _ = t, te(e.comma) && (z = D(), z ? B.push(z) : t = _)), B;
  }
  function D() {
    let B = v(), z = C();
    if (!(!B && !z))
      return { ...B, at: z };
  }
  function v() {
    let B = g() || y(), z = b() || O() || A(), _ = Z("%", e.percentageValue, 1);
    if (B)
      return { ...B, style: [z, _].filter((N) => N) };
    if (z)
      return { style: [z, _].filter((N) => N), ...g() || y() };
  }
  function g() {
    return Z("shape", /^(circle)/i, 0);
  }
  function y() {
    return Z("shape", /^(ellipse)/i, 0);
  }
  function b() {
    return Z("extent-keyword", e.extentKeywords, 1);
  }
  function C() {
    if (Z("position", /^at/, 0)) {
      var B = k();
      return B || r2("Missing positioning value"), B;
    }
  }
  function k() {
    var B = S();
    if (B.x || B.y)
      return { type: "position", value: B };
  }
  function S() {
    return { x: A(), y: A() };
  }
  function E(B) {
    var z = B(), _ = [];
    if (z)
      for (_.push(z); te(e.comma); )
        z = B(), z ? _.push(z) : r2("One extra comma");
    return _;
  }
  function L() {
    var B = T();
    return B || r2("Expected color definition"), B.length = A(), B;
  }
  function T() {
    return M() || q() || H() || U();
  }
  function U() {
    return Z("literal", e.literalColor, 0);
  }
  function M() {
    return Z("hex", e.hexColor, 1);
  }
  function H() {
    return s(e.rgbColor, function() {
      return { type: "rgb", value: E(ee) };
    });
  }
  function q() {
    return s(e.rgbaColor, function() {
      return { type: "rgba", value: E(ee) };
    });
  }
  function ee() {
    return te(e.number)[1];
  }
  function A() {
    return Z("%", e.percentageValue, 1) || R() || O();
  }
  function R() {
    return Z("position-keyword", e.positionKeywords, 1);
  }
  function O() {
    return Z("px", e.pixelValue, 1) || Y(e.emLikeValue, 1);
  }
  function Y(B, z) {
    var _ = te(B);
    if (_)
      return { type: _[5], value: _[z] };
  }
  function Z(B, z, _) {
    var N = te(z);
    if (N)
      return { type: B, value: N[_] };
  }
  function te(B) {
    var z, _;
    return _ = /^[\n\r\t\s]+/.exec(t), _ && ie(_[0].length), z = B.exec(t), z && ie(z[0].length), z;
  }
  function ie(B) {
    t = t.substr(B);
  }
  return function(B) {
    return t = B.toString(), n();
  };
}();
var mu = Ga;
function k1(e) {
  return e.type === "literal" ? e.value : e.type === "hex" ? `#${e.value}` : e.type === "rgb" ? `rgb(${e.value.join(",")})` : e.type === "rgba" ? `rgba(${e.value.join(",")})` : "transparent";
}
function T1(e) {
  let t = 0, r2 = 0, n = 0, i = 0;
  return e.includes("top") ? r2 = 1 : e.includes("bottom") && (i = 1), e.includes("left") ? t = 1 : e.includes("right") && (n = 1), !t && !n && !r2 && !i && (r2 = 1), [t, r2, n, i];
}
function _1(e, t) {
  return typeof e == "string" && e.endsWith("%") ? t * parseFloat(e) / 100 : +e;
}
function va(e, { x: t, y: r2, defaultX: n, defaultY: i }) {
  return (e ? e.split(" ").map((a) => {
    try {
      let o = new Qn(a);
      return o.type === "length" || o.type === "number" ? o.value : o.value + o.unit;
    } catch {
      return null;
    }
  }).filter((a) => a !== null) : [n, i]).map((a, o) => _1(a, [t, r2][o]));
}
function Du(e, t, r2) {
  let n = [];
  for (let u of t) {
    let s = k1(u);
    if (!n.length && (n.push({ offset: 0, color: s }), typeof u.length > "u" || u.length.value === "0"))
      continue;
    let l = typeof u.length > "u" ? void 0 : u.length.type === "%" ? u.length.value / 100 : u.length.value / e;
    n.push({ offset: l, color: s });
  }
  n.length || n.push({ offset: 0, color: "transparent" });
  let i = n[n.length - 1];
  i.offset !== 1 && (typeof i.offset > "u" ? i.offset = 1 : n.push({ offset: 1, color: i.color }));
  let a = 0, o = 1;
  for (let u = 0; u < n.length; u++)
    if (typeof n[u].offset > "u") {
      for (o < u && (o = u); typeof n[o].offset > "u"; )
        o++;
      n[u].offset = (n[o].offset - n[a].offset) / (o - a) * (u - a) + n[a].offset;
    } else
      a = u;
  return r2 === "mask" ? n.map((u) => {
    let s = (0, Fl.default)(u.color);
    return s.alpha === 0 ? { ...u, color: "rgba(0, 0, 0, 1)" } : { ...u, color: `rgba(255, 255, 255, ${s.alpha})` };
  }) : n;
}
async function Cl({ id: e, width: t, height: r2, left: n, top: i }, { image: a, size: o, position: u, repeat: s }, l, f) {
  s = s || "repeat", f = f || "background";
  let c = s === "repeat-x" || s === "repeat", p2 = s === "repeat-y" || s === "repeat", d = va(o, { x: t, y: r2, defaultX: t, defaultY: r2 }), D = va(u, { x: t, y: r2, defaultX: 0, defaultY: 0 });
  if (a.startsWith("linear-gradient(")) {
    let v = mu.parse(a)[0], [g, y] = d, b, C, k, S, E;
    if (v.orientation.type === "directional")
      [b, C, k, S] = T1(v.orientation.value), E = Math.sqrt(Math.pow((k - b) * g, 2) + Math.pow((S - C) * y, 2));
    else if (v.orientation.type === "angular") {
      let H = function(ee) {
        if (ee = (ee % (Math.PI * 2) + Math.PI * 2) % (Math.PI * 2), Math.abs(ee - Math.PI / 2) < 1e-6) {
          b = 0, C = 0, k = 1, S = 0, E = g;
          return;
        } else if (Math.abs(ee) < 1e-6) {
          b = 0, C = 1, k = 0, S = 0, E = y;
          return;
        }
        if (ee >= Math.PI / 2 && ee < Math.PI) {
          H(Math.PI - ee), C = 1 - C, S = 1 - S;
          return;
        } else if (ee >= Math.PI) {
          H(ee - Math.PI);
          let B = b;
          b = k, k = B, B = C, C = S, S = B;
          return;
        }
        let A = Math.tan(ee), R = A * q, O = Math.atan(R), Y = Math.sqrt(2) * Math.cos(Math.PI / 4 - O);
        b = 0, C = 1, k = Math.sin(O) * Y, S = 1 - Math.cos(O) * Y;
        let Z = 1, te = 1 / A, ie = Math.abs((Z * q + te) / Math.sqrt(Z * Z + te * te) / Math.sqrt(q * q + 1));
        E = Math.sqrt(g * g + y * y) * ie;
      }, q = g / y;
      H(+v.orientation.value / 180 * Math.PI);
    }
    let L = Du(E, v.colorStops, f), T = `satori_bi${e}`, U = `satori_pattern_${e}`, M = ue("pattern", { id: U, x: D[0] / t, y: D[1] / r2, width: c ? g / t : "1", height: p2 ? y / r2 : "1", patternUnits: "objectBoundingBox" }, ue("linearGradient", { id: T, x1: b, y1: C, x2: k, y2: S }, L.map((H) => ue("stop", { offset: H.offset * 100 + "%", "stop-color": H.color })).join("")) + ue("rect", { x: 0, y: 0, width: g, height: y, fill: `url(#${T})` }));
    return [U, M];
  }
  if (a.startsWith("radial-gradient(")) {
    let v = mu.parse(a)[0], g = v.orientation[0], [y, b] = d, C = "circle", k = y / 2, S = b / 2;
    if (g.type === "shape") {
      if (C = g.value, g.at)
        if (g.at.type === "position") {
          let q = A1(g.at.value.x, g.at.value.y, y, b, l.fontSize, l);
          k = q.x, S = q.y;
        } else
          throw new Error("orientation.at.type not implemented: " + g.at.type);
    } else
      throw new Error("orientation.type not implemented: " + g.type);
    let E = Du(t, v.colorStops, f), L = `satori_radial_${e}`, T = `satori_pattern_${e}`, U = `satori_mask_${e}`, M = O1(C, g.style, l.fontSize, { x: k, y: S }, [y, b], l), H = ue("pattern", { id: T, x: D[0] / t, y: D[1] / r2, width: c ? y / t : "1", height: p2 ? b / r2 : "1", patternUnits: "objectBoundingBox" }, ue("radialGradient", { id: L }, E.map((q) => ue("stop", { offset: q.offset, "stop-color": q.color })).join("")) + ue("mask", { id: U }, ue("rect", { x: 0, y: 0, width: y, height: b, fill: "#fff" })) + ue("rect", { x: 0, y: 0, width: y, height: b, fill: E.at(-1).color }) + ue(C, { cx: k, cy: S, width: y, height: b, ...M, fill: `url(#${L})`, mask: `url(#${U})` }));
    return [T, H];
  }
  if (a.startsWith("url(")) {
    let v = va(o, { x: t, y: r2, defaultX: 0, defaultY: 0 }), [g, y, b] = await Na(a.slice(4, -1)), C = f === "mask" ? y || v[0] : v[0] || y, k = f === "mask" ? b || v[1] : v[1] || b;
    return [`satori_bi${e}`, ue("pattern", { id: `satori_bi${e}`, patternContentUnits: "userSpaceOnUse", patternUnits: "userSpaceOnUse", x: D[0] + n, y: D[1] + i, width: c ? C : "100%", height: p2 ? k : "100%" }, ue("image", { x: 0, y: 0, width: C, height: k, preserveAspectRatio: "none", href: g }))];
  }
  throw new Error(`Invalid background image: "${a}"`);
}
function A1(e, t, r2, n, i, a) {
  let o = { x: r2 / 2, y: n / 2 };
  return e.type === "position-keyword" ? Object.assign(o, yu(e.value, r2, n, "x")) : o.x = Ie(`${e.value}${e.type}`, i, r2, a, true), t.type === "position-keyword" ? Object.assign(o, yu(t.value, r2, n, "y")) : o.y = Ie(`${t.value}${t.type}`, i, n, a, true), o;
}
function yu(e, t, r2, n) {
  switch (e) {
    case "center":
      return { [n]: n === "x" ? t / 2 : r2 / 2 };
    case "left":
      return { x: 0 };
    case "top":
      return { y: 0 };
    case "right":
      return { x: t };
    case "bottom":
      return { y: r2 };
  }
}
function O1(e, t, r2, n, i, a) {
  let [o, u] = i, { x: s, y: l } = n, f = {}, c = 0, p2 = 0;
  if (!t.some((d) => d.type === "extent-keyword")) {
    if (t.some((d) => d.value.startsWith("-")))
      throw new Error("disallow setting negative values to the size of the shape. Check https://w3c.github.io/csswg-drafts/css-images/#valdef-rg-size-length-0");
    return e === "circle" ? { r: Ie(`${t[0].value}${t[0].type}`, r2, o, a, true) } : { rx: Ie(`${t[0].value}${t[0].type}`, r2, o, a, true), ry: Ie(`${t[1].value}${t[1].type}`, r2, u, a, true) };
  }
  switch (t[0].value) {
    case "farthest-corner":
      c = Math.max(Math.abs(o - s), Math.abs(s)), p2 = Math.max(Math.abs(u - l), Math.abs(l));
      break;
    case "closest-corner":
      c = Math.min(Math.abs(o - s), Math.abs(s)), p2 = Math.min(Math.abs(u - l), Math.abs(l));
      break;
    case "farthest-side":
      return e === "circle" ? f.r = Math.max(Math.abs(o - s), Math.abs(s), Math.abs(u - l), Math.abs(l)) : (f.rx = Math.max(Math.abs(o - s), Math.abs(s)), f.ry = Math.max(Math.abs(u - l), Math.abs(l))), f;
    case "closest-side":
      return e === "circle" ? f.r = Math.min(Math.abs(o - s), Math.abs(s), Math.abs(u - l), Math.abs(l)) : (f.rx = Math.min(Math.abs(o - s), Math.abs(s)), f.ry = Math.min(Math.abs(u - l), Math.abs(l))), f;
  }
  if (e === "circle")
    f.r = Math.sqrt(c * c + p2 * p2);
  else {
    let d = p2 !== 0 ? c / p2 : 1;
    c === 0 ? (f.rx = 0, f.ry = 0) : (f.ry = Math.sqrt(c * c + p2 * p2 * d * d) / d, f.rx = f.ry * d);
  }
  return f;
}
function L1([e, t]) {
  return Math.round(e * 1e3) === 0 && Math.round(t * 1e3) === 0 ? 0 : Math.round(e * t / Math.sqrt(e * e + t * t) * 1e3) / 1e3;
}
function Rn(e, t, r2) {
  return r2 < e + t && (r2 / 2 < e && r2 / 2 < t ? e = t = r2 / 2 : r2 / 2 < e ? e = r2 - t : r2 / 2 < t && (t = r2 - e)), [e, t];
}
function Un(e) {
  e[0] = e[1] = Math.min(e[0], e[1]);
}
function Bn(e, t, r2, n, i) {
  if (typeof e == "string") {
    let a = e.split(" ").map((u) => u.trim()), o = !a[1] && !a[0].endsWith("%");
    return a[1] = a[1] || a[0], [o, [Math.min(Ie(a[0], n, t, i, true), t), Math.min(Ie(a[1], n, r2, i, true), r2)]];
  }
  return typeof e == "number" ? [true, [Math.min(e, t), Math.min(e, r2)]] : [true, void 0];
}
var Nn = (e) => e && e[0] !== 0 && e[1] !== 0;
function qn({ left: e, top: t, width: r2, height: n }, i, a) {
  let { borderTopLeftRadius: o, borderTopRightRadius: u, borderBottomLeftRadius: s, borderBottomRightRadius: l, fontSize: f } = i, c, p2, d, D;
  if ([c, o] = Bn(o, r2, n, f, i), [p2, u] = Bn(u, r2, n, f, i), [d, s] = Bn(s, r2, n, f, i), [D, l] = Bn(l, r2, n, f, i), !a && !Nn(o) && !Nn(u) && !Nn(s) && !Nn(l))
    return "";
  o ||= [0, 0], u ||= [0, 0], s ||= [0, 0], l ||= [0, 0], [o[0], u[0]] = Rn(o[0], u[0], r2), [s[0], l[0]] = Rn(s[0], l[0], r2), [o[1], s[1]] = Rn(o[1], s[1], n), [u[1], l[1]] = Rn(u[1], l[1], n), c && Un(o), p2 && Un(u), d && Un(s), D && Un(l);
  let v = [];
  v[0] = [u, u], v[1] = [l, [-l[0], l[1]]], v[2] = [s, [-s[0], -s[1]]], v[3] = [o, [o[0], -o[1]]];
  let g = `h${r2 - o[0] - u[0]} a${v[0][0]} 0 0 1 ${v[0][1]}`, y = `v${n - u[1] - l[1]} a${v[1][0]} 0 0 1 ${v[1][1]}`, b = `h${l[0] + s[0] - r2} a${v[2][0]} 0 0 1 ${v[2][1]}`, C = `v${s[1] + o[1] - n} a${v[3][0]} 0 0 1 ${v[3][1]}`;
  if (a) {
    let k = function(q) {
      let ee = L1([o, u, l, s][q]);
      return q === 0 ? [[e + o[0] - ee, t + o[1] - ee], [e + o[0], t]] : q === 1 ? [[e + r2 - u[0] + ee, t + u[1] - ee], [e + r2, t + u[1]]] : q === 2 ? [[e + r2 - l[0] + ee, t + n - l[1] + ee], [e + r2 - l[0], t + n]] : [[e + s[0] - ee, t + n - s[1] + ee], [e, t + n - s[1]]];
    }, S = a.indexOf(false);
    if (!a.includes(true))
      throw new Error("Invalid `partialSides`.");
    if (S === -1)
      S = 0;
    else
      for (; !a[S]; )
        S = (S + 1) % 4;
    let E = "", L = k(S), T = `M${L[0]} A${v[(S + 3) % 4][0]} 0 0 1 ${L[1]}`, U = 0;
    for (; U < 4 && a[(S + U) % 4]; U++)
      E += T + " ", T = [g, y, b, C][(S + U) % 4];
    let M = (S + U) % 4;
    E += T.split(" ")[0];
    let H = k(M);
    return E += ` A${v[(M + 3) % 4][0]} 0 0 1 ${H[0]}`, E;
  }
  return `M${e + o[0]},${t} ${g} ${y} ${b} ${C}`;
}
function bu(e, t, r2) {
  return r2[e + "Width"] === r2[t + "Width"] && r2[e + "Style"] === r2[t + "Style"] && r2[e + "Color"] === r2[t + "Color"];
}
function I1({ id: e, currentClipPathId: t, borderPath: r2, borderType: n, left: i, top: a, width: o, height: u }, s) {
  if (!(s.borderTopWidth || s.borderRightWidth || s.borderBottomWidth || s.borderLeftWidth))
    return null;
  let l = `satori_bc-${e}`;
  return [ue("clipPath", { id: l, "clip-path": t ? `url(#${t})` : void 0 }, ue(n, { x: i, y: a, width: o, height: u, d: r2 || void 0 })), l];
}
function Sl({ left: e, top: t, width: r2, height: n, props: i, asContentMask: a, maskBorderOnly: o }, u) {
  let s = ["borderTop", "borderRight", "borderBottom", "borderLeft"];
  if (!a && !s.some((d) => u[d + "Width"]))
    return "";
  let l = "", f = 0;
  for (; f > 0 && bu(s[f], s[(f + 3) % 4], u); )
    f = (f + 3) % 4;
  let c = [false, false, false, false], p2 = [];
  for (let d = 0; d < 4; d++) {
    let D = (f + d) % 4, v = (f + d + 1) % 4, g = s[D], y = s[v];
    if (c[D] = true, p2 = [u[g + "Width"], u[g + "Style"], u[g + "Color"], g], !bu(g, y, u)) {
      let b = (p2[0] || 0) + (a && !o && u[g.replace("border", "padding")] || 0);
      b && (l += ue("path", { width: r2, height: n, ...i, fill: "none", stroke: a ? "#000" : p2[2], "stroke-width": b * 2, "stroke-dasharray": !a && p2[1] === "dashed" ? b * 2 + " " + b : void 0, d: qn({ left: e, top: t, width: r2, height: n }, u, c) })), c = [false, false, false, false];
    }
  }
  if (c.some(Boolean)) {
    let d = (p2[0] || 0) + (a && !o && u[p2[3].replace("border", "padding")] || 0);
    d && (l += ue("path", { width: r2, height: n, ...i, fill: "none", stroke: a ? "#000" : p2[2], "stroke-width": d * 2, "stroke-dasharray": !a && p2[1] === "dashed" ? d * 2 + " " + d : void 0, d: qn({ left: e, top: t, width: r2, height: n }, u, c) }));
  }
  return l;
}
function P1({ id: e, left: t, top: r2, width: n, height: i, matrix: a, borderOnly: o }, u) {
  let s = (u.borderLeftWidth || 0) + (o ? 0 : u.paddingLeft || 0), l = (u.borderTopWidth || 0) + (o ? 0 : u.paddingTop || 0), f = (u.borderRightWidth || 0) + (o ? 0 : u.paddingRight || 0), c = (u.borderBottomWidth || 0) + (o ? 0 : u.paddingBottom || 0), p2 = { x: t + s, y: r2 + l, width: n - s - f, height: i - l - c };
  return ue("mask", { id: e }, ue("rect", { ...p2, fill: "#fff", mask: u._inheritedMaskId ? `url(#${u._inheritedMaskId})` : void 0 }) + Sl({ left: t, top: r2, width: n, height: i, props: { transform: a || void 0 }, asContentMask: true, maskBorderOnly: o }, u));
}
var Zr = { circle: /circle\((.+)\)/, ellipse: /ellipse\((.+)\)/, path: /path\((.+)\)/, polygon: /polygon\((.+)\)/, inset: /inset\((.+)\)/ };
function R1({ width: e, height: t }, r2, n) {
  function i(l) {
    let f = l.match(Zr.circle);
    if (!f)
      return null;
    let [, c] = f, [p2, d = ""] = c.split("at").map((g) => g.trim()), { x: D, y: v } = wu(d, e, t);
    return { type: "circle", r: Ie(p2, n.fontSize, Math.sqrt(Math.pow(e, 2) + Math.pow(t, 2)) / Math.sqrt(2), n, true), cx: Ie(D, n.fontSize, e, n, true), cy: Ie(v, n.fontSize, t, n, true) };
  }
  function a(l) {
    let f = l.match(Zr.ellipse);
    if (!f)
      return null;
    let [, c] = f, [p2, d = ""] = c.split("at").map((b) => b.trim()), [D, v] = p2.split(" "), { x: g, y } = wu(d, e, t);
    return { type: "ellipse", rx: Ie(D || "50%", n.fontSize, e, n, true), ry: Ie(v || "50%", n.fontSize, t, n, true), cx: Ie(g, n.fontSize, e, n, true), cy: Ie(y, n.fontSize, t, n, true) };
  }
  function o(l) {
    let f = l.match(Zr.path);
    if (!f)
      return null;
    let [c, p2] = xu(f[1]);
    return { type: "path", d: p2, "fill-rule": c };
  }
  function u(l) {
    let f = l.match(Zr.polygon);
    if (!f)
      return null;
    let [c, p2] = xu(f[1]);
    return { type: "polygon", "fill-rule": c, points: p2.split(",").map((d) => d.split(" ").map((D, v) => Ie(D, n.fontSize, v === 0 ? e : t, n, true)).join(" ")).join(",") };
  }
  function s(l) {
    let f = l.match(Zr.inset);
    if (!f)
      return null;
    let [c, p2] = (f[1].includes("round") ? f[1] : `${f[1].trim()} round 0`).split("round"), d = (0, Ca.getStylesForProperty)("borderRadius", p2, true), D = Object.values(d).map((k) => String(k)).map((k, S) => Ie(k, n.fontSize, S === 0 || S === 2 ? t : e, n, true) || 0), v = Object.values((0, Ca.getStylesForProperty)("margin", c, true)).map((k) => String(k)).map((k, S) => Ie(k, n.fontSize, S === 0 || S === 2 ? t : e, n, true) || 0), g = v[3], y = v[0], b = e - (v[1] + v[3]), C = t - (v[0] + v[2]);
    return D.some((k) => k > 0) ? { type: "path", d: qn({ left: g, top: y, width: b, height: C }, { ...r2, ...d }) } : { type: "rect", x: g, y, width: b, height: C };
  }
  return { parseCircle: i, parseEllipse: a, parsePath: o, parsePolygon: u, parseInset: s };
}
function xu(e) {
  let [, t = "nonzero", r2] = e.replace(/('|")/g, "").match(/^(nonzero|evenodd)?,?(.+)/) || [];
  return [t, r2];
}
function wu(e, t, r2) {
  let n = e.split(" "), i = { x: n[0] || "50%", y: n[1] || "50%" };
  return n.forEach((a) => {
    a === "top" ? i.y = 0 : a === "bottom" ? i.y = r2 : a === "left" ? i.x = 0 : a === "right" ? i.x = t : a === "center" && (i.x = t / 2, i.y = r2 / 2);
  }), i;
}
function Wa(e) {
  return `satori_cp-${e}`;
}
function U1(e) {
  return `url(#${Wa(e)})`;
}
function B1(e, t, r2) {
  if (t.clipPath === "none")
    return "";
  let n = R1(e, t, r2), i = t.clipPath, a = { type: "" };
  for (let o of Object.keys(n))
    if (a = n[o](i), a)
      break;
  if (a) {
    let { type: o, ...u } = a;
    return ue("clipPath", { id: Wa(e.id), "clip-path": e.currentClipPath, transform: `translate(${e.left}, ${e.top})` }, ue(o, u));
  }
  return "";
}
function N1({ left: e, top: t, width: r2, height: n, path: i, matrix: a, id: o, currentClipPath: u, src: s }, l, f) {
  let c = "", p2 = l.clipPath && l.clipPath !== "none" ? B1({ left: e, top: t, width: r2, height: n, path: i, id: o, matrix: a, currentClipPath: u, src: s }, l, f) : "";
  if (l.overflow !== "hidden" && !s)
    c = "";
  else {
    let D = p2 ? `satori_ocp-${o}` : Wa(o);
    c = ue("clipPath", { id: D, "clip-path": u }, ue(i ? "path" : "rect", { x: e, y: t, width: r2, height: n, d: i || void 0 }));
  }
  let d = P1({ id: `satori_om-${o}`, left: e, top: t, width: r2, height: n, matrix: a, borderOnly: !s }, l);
  return p2 + c + d;
}
var M1 = (e) => `satori_mi-${e}`;
async function G1(e, t, r2) {
  if (!t.maskImage)
    return ["", ""];
  let { left: n, top: i, width: a, height: o, id: u } = e, s = t.maskImage, l = s.length;
  if (!l)
    return ["", ""];
  let f = M1(u), c = "";
  for (let p2 = 0; p2 < l; p2++) {
    let d = s[p2], [D, v] = await Cl({ id: `${f}-${p2}`, left: n, top: i, width: a, height: o }, d, r2, "mask");
    c += v + ue("rect", { x: 0, y: 0, width: a, height: o, fill: `url(#${D})` });
  }
  return c = ue("mask", { id: f }, c), [f, c];
}
async function ga({ id: e, left: t, top: r2, width: n, height: i, isInheritingTransform: a, src: o, debug: u }, s, l) {
  if (s.display === "none")
    return "";
  let f = !!o, c = "rect", p2 = "", d = "", D = [], v = 1, g = "";
  s.backgroundColor && D.push(s.backgroundColor), s.opacity !== void 0 && (v = +s.opacity), s.transform && (p2 = wl({ left: t, top: r2, width: n, height: i }, s.transform, a, s.transformOrigin));
  let y = "";
  if (s.backgroundImage) {
    let A = [];
    for (let R = 0; R < s.backgroundImage.length; R++) {
      let O = s.backgroundImage[R], Y = await Cl({ id: e + "_" + R, width: n, height: i, left: t, top: r2 }, O, l);
      Y && A.unshift(Y);
    }
    for (let R of A)
      D.push(`url(#${R[0]})`), d += R[1], R[2] && (y += R[2]);
  }
  let [b, C] = await G1({ id: e, left: t, top: r2, width: n, height: i }, s, l);
  d += C;
  let k = b ? `url(#${b})` : s._inheritedMaskId ? `url(#${s._inheritedMaskId})` : void 0, S = qn({ left: t, top: r2, width: n, height: i }, s);
  S && (c = "path");
  let E = s._inheritedClipPathId;
  u && (g = ue("rect", { x: t, y: r2, width: n, height: i, fill: "transparent", stroke: "#ff5757", "stroke-width": 1, transform: p2 || void 0, "clip-path": E ? `url(#${E})` : void 0 }));
  let { backgroundClip: L, filter: T } = s, U = L === "text" ? `url(#satori_bct-${e})` : E ? `url(#${E})` : s.clipPath ? U1(e) : void 0, M = N1({ left: t, top: r2, width: n, height: i, path: S, id: e, matrix: p2, currentClipPath: U, src: o }, s, l), H = D.map((A) => ue(c, { x: t, y: r2, width: n, height: i, fill: A, d: S || void 0, transform: p2 || void 0, "clip-path": U, style: T ? `filter:${T}` : void 0, mask: k })).join(""), q = I1({ id: e, left: t, top: r2, width: n, height: i, currentClipPathId: E, borderPath: S, borderType: c }, s);
  if (f) {
    let A = (s.borderLeftWidth || 0) + (s.paddingLeft || 0), R = (s.borderTopWidth || 0) + (s.paddingTop || 0), O = (s.borderRightWidth || 0) + (s.paddingRight || 0), Y = (s.borderBottomWidth || 0) + (s.paddingBottom || 0), Z = s.objectFit === "contain" ? "xMidYMid" : s.objectFit === "cover" ? "xMidYMid slice" : "none";
    H += ue("image", { x: t + A, y: r2 + R, width: n - A - O, height: i - R - Y, href: o, preserveAspectRatio: Z, transform: p2 || void 0, style: T ? `filter:${T}` : void 0, "clip-path": `url(#satori_cp-${e})`, mask: b ? `url(#${b})` : `url(#satori_om-${e})` });
  }
  if (q) {
    d += q[0];
    let A = q[1];
    H += Sl({ left: t, top: r2, width: n, height: i, props: { transform: p2 || void 0, "clip-path": `url(#${A})` } }, s);
  }
  let ee = h1({ width: n, height: i, id: e, opacity: v, shape: ue(c, { x: t, y: r2, width: n, height: i, fill: "#fff", stroke: "#fff", "stroke-width": 0, d: S || void 0, transform: p2 || void 0, "clip-path": U, mask: k }) }, s);
  return (d ? ue("defs", {}, d) : "") + (ee ? ee[0] : "") + M + (v !== 1 ? `<g opacity="${v}">` : "") + (y || H) + (v !== 1 ? "</g>" : "") + (ee ? ee[1] : "") + g;
}
var W1 = () => /[#*0-9]\uFE0F?\u20E3|[\xA9\xAE\u203C\u2049\u2122\u2139\u2194-\u2199\u21A9\u21AA\u231A\u231B\u2328\u23CF\u23ED-\u23EF\u23F1\u23F2\u23F8-\u23FA\u24C2\u25AA\u25AB\u25B6\u25C0\u25FB\u25FC\u25FE\u2600-\u2604\u260E\u2611\u2614\u2615\u2618\u2620\u2622\u2623\u2626\u262A\u262E\u262F\u2638-\u263A\u2640\u2642\u2648-\u2653\u265F\u2660\u2663\u2665\u2666\u2668\u267B\u267E\u267F\u2692\u2694-\u2697\u2699\u269B\u269C\u26A0\u26A7\u26AA\u26B0\u26B1\u26BD\u26BE\u26C4\u26C8\u26CF\u26D1\u26D3\u26E9\u26F0-\u26F5\u26F7\u26F8\u26FA\u2702\u2708\u2709\u270F\u2712\u2714\u2716\u271D\u2721\u2733\u2734\u2744\u2747\u2757\u2763\u27A1\u2934\u2935\u2B05-\u2B07\u2B1B\u2B1C\u2B55\u3030\u303D\u3297\u3299]\uFE0F?|[\u261D\u270C\u270D](?:\uFE0F|\uD83C[\uDFFB-\uDFFF])?|[\u270A\u270B](?:\uD83C[\uDFFB-\uDFFF])?|[\u23E9-\u23EC\u23F0\u23F3\u25FD\u2693\u26A1\u26AB\u26C5\u26CE\u26D4\u26EA\u26FD\u2705\u2728\u274C\u274E\u2753-\u2755\u2795-\u2797\u27B0\u27BF\u2B50]|\u26F9(?:\uFE0F|\uD83C[\uDFFB-\uDFFF])?(?:\u200D[\u2640\u2642]\uFE0F?)?|\u2764\uFE0F?(?:\u200D(?:\uD83D\uDD25|\uD83E\uDE79))?|\uD83C(?:[\uDC04\uDD70\uDD71\uDD7E\uDD7F\uDE02\uDE37\uDF21\uDF24-\uDF2C\uDF36\uDF7D\uDF96\uDF97\uDF99-\uDF9B\uDF9E\uDF9F\uDFCD\uDFCE\uDFD4-\uDFDF\uDFF5\uDFF7]\uFE0F?|[\uDF85\uDFC2\uDFC7](?:\uD83C[\uDFFB-\uDFFF])?|[\uDFC3\uDFC4\uDFCA](?:\uD83C[\uDFFB-\uDFFF])?(?:\u200D[\u2640\u2642]\uFE0F?)?|[\uDFCB\uDFCC](?:\uFE0F|\uD83C[\uDFFB-\uDFFF])?(?:\u200D[\u2640\u2642]\uFE0F?)?|[\uDCCF\uDD8E\uDD91-\uDD9A\uDE01\uDE1A\uDE2F\uDE32-\uDE36\uDE38-\uDE3A\uDE50\uDE51\uDF00-\uDF20\uDF2D-\uDF35\uDF37-\uDF7C\uDF7E-\uDF84\uDF86-\uDF93\uDFA0-\uDFC1\uDFC5\uDFC6\uDFC8\uDFC9\uDFCF-\uDFD3\uDFE0-\uDFF0\uDFF8-\uDFFF]|\uDDE6\uD83C[\uDDE8-\uDDEC\uDDEE\uDDF1\uDDF2\uDDF4\uDDF6-\uDDFA\uDDFC\uDDFD\uDDFF]|\uDDE7\uD83C[\uDDE6\uDDE7\uDDE9-\uDDEF\uDDF1-\uDDF4\uDDF6-\uDDF9\uDDFB\uDDFC\uDDFE\uDDFF]|\uDDE8\uD83C[\uDDE6\uDDE8\uDDE9\uDDEB-\uDDEE\uDDF0-\uDDF5\uDDF7\uDDFA-\uDDFF]|\uDDE9\uD83C[\uDDEA\uDDEC\uDDEF\uDDF0\uDDF2\uDDF4\uDDFF]|\uDDEA\uD83C[\uDDE6\uDDE8\uDDEA\uDDEC\uDDED\uDDF7-\uDDFA]|\uDDEB\uD83C[\uDDEE-\uDDF0\uDDF2\uDDF4\uDDF7]|\uDDEC\uD83C[\uDDE6\uDDE7\uDDE9-\uDDEE\uDDF1-\uDDF3\uDDF5-\uDDFA\uDDFC\uDDFE]|\uDDED\uD83C[\uDDF0\uDDF2\uDDF3\uDDF7\uDDF9\uDDFA]|\uDDEE\uD83C[\uDDE8-\uDDEA\uDDF1-\uDDF4\uDDF6-\uDDF9]|\uDDEF\uD83C[\uDDEA\uDDF2\uDDF4\uDDF5]|\uDDF0\uD83C[\uDDEA\uDDEC-\uDDEE\uDDF2\uDDF3\uDDF5\uDDF7\uDDFC\uDDFE\uDDFF]|\uDDF1\uD83C[\uDDE6-\uDDE8\uDDEE\uDDF0\uDDF7-\uDDFB\uDDFE]|\uDDF2\uD83C[\uDDE6\uDDE8-\uDDED\uDDF0-\uDDFF]|\uDDF3\uD83C[\uDDE6\uDDE8\uDDEA-\uDDEC\uDDEE\uDDF1\uDDF4\uDDF5\uDDF7\uDDFA\uDDFF]|\uDDF4\uD83C\uDDF2|\uDDF5\uD83C[\uDDE6\uDDEA-\uDDED\uDDF0-\uDDF3\uDDF7-\uDDF9\uDDFC\uDDFE]|\uDDF6\uD83C\uDDE6|\uDDF7\uD83C[\uDDEA\uDDF4\uDDF8\uDDFA\uDDFC]|\uDDF8\uD83C[\uDDE6-\uDDEA\uDDEC-\uDDF4\uDDF7-\uDDF9\uDDFB\uDDFD-\uDDFF]|\uDDF9\uD83C[\uDDE6\uDDE8\uDDE9\uDDEB-\uDDED\uDDEF-\uDDF4\uDDF7\uDDF9\uDDFB\uDDFC\uDDFF]|\uDDFA\uD83C[\uDDE6\uDDEC\uDDF2\uDDF3\uDDF8\uDDFE\uDDFF]|\uDDFB\uD83C[\uDDE6\uDDE8\uDDEA\uDDEC\uDDEE\uDDF3\uDDFA]|\uDDFC\uD83C[\uDDEB\uDDF8]|\uDDFD\uD83C\uDDF0|\uDDFE\uD83C[\uDDEA\uDDF9]|\uDDFF\uD83C[\uDDE6\uDDF2\uDDFC]|\uDFF3\uFE0F?(?:\u200D(?:\u26A7\uFE0F?|\uD83C\uDF08))?|\uDFF4(?:\u200D\u2620\uFE0F?|\uDB40\uDC67\uDB40\uDC62\uDB40(?:\uDC65\uDB40\uDC6E\uDB40\uDC67|\uDC73\uDB40\uDC63\uDB40\uDC74|\uDC77\uDB40\uDC6C\uDB40\uDC73)\uDB40\uDC7F)?)|\uD83D(?:[\uDC08\uDC26](?:\u200D\u2B1B)?|[\uDC3F\uDCFD\uDD49\uDD4A\uDD6F\uDD70\uDD73\uDD76-\uDD79\uDD87\uDD8A-\uDD8D\uDDA5\uDDA8\uDDB1\uDDB2\uDDBC\uDDC2-\uDDC4\uDDD1-\uDDD3\uDDDC-\uDDDE\uDDE1\uDDE3\uDDE8\uDDEF\uDDF3\uDDFA\uDECB\uDECD-\uDECF\uDEE0-\uDEE5\uDEE9\uDEF0\uDEF3]\uFE0F?|[\uDC42\uDC43\uDC46-\uDC50\uDC66\uDC67\uDC6B-\uDC6D\uDC72\uDC74-\uDC76\uDC78\uDC7C\uDC83\uDC85\uDC8F\uDC91\uDCAA\uDD7A\uDD95\uDD96\uDE4C\uDE4F\uDEC0\uDECC](?:\uD83C[\uDFFB-\uDFFF])?|[\uDC6E\uDC70\uDC71\uDC73\uDC77\uDC81\uDC82\uDC86\uDC87\uDE45-\uDE47\uDE4B\uDE4D\uDE4E\uDEA3\uDEB4-\uDEB6](?:\uD83C[\uDFFB-\uDFFF])?(?:\u200D[\u2640\u2642]\uFE0F?)?|[\uDD74\uDD90](?:\uFE0F|\uD83C[\uDFFB-\uDFFF])?|[\uDC00-\uDC07\uDC09-\uDC14\uDC16-\uDC25\uDC27-\uDC3A\uDC3C-\uDC3E\uDC40\uDC44\uDC45\uDC51-\uDC65\uDC6A\uDC79-\uDC7B\uDC7D-\uDC80\uDC84\uDC88-\uDC8E\uDC90\uDC92-\uDCA9\uDCAB-\uDCFC\uDCFF-\uDD3D\uDD4B-\uDD4E\uDD50-\uDD67\uDDA4\uDDFB-\uDE2D\uDE2F-\uDE34\uDE37-\uDE44\uDE48-\uDE4A\uDE80-\uDEA2\uDEA4-\uDEB3\uDEB7-\uDEBF\uDEC1-\uDEC5\uDED0-\uDED2\uDED5-\uDED7\uDEDC-\uDEDF\uDEEB\uDEEC\uDEF4-\uDEFC\uDFE0-\uDFEB\uDFF0]|\uDC15(?:\u200D\uD83E\uDDBA)?|\uDC3B(?:\u200D\u2744\uFE0F?)?|\uDC41\uFE0F?(?:\u200D\uD83D\uDDE8\uFE0F?)?|\uDC68(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?\uDC68|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D(?:[\uDC68\uDC69]\u200D\uD83D(?:\uDC66(?:\u200D\uD83D\uDC66)?|\uDC67(?:\u200D\uD83D[\uDC66\uDC67])?)|[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uDC66(?:\u200D\uD83D\uDC66)?|\uDC67(?:\u200D\uD83D[\uDC66\uDC67])?)|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C(?:\uDFFB(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?\uDC68\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF-\uDDB3\uDDBC\uDDBD]|\uDD1D\u200D\uD83D\uDC68\uD83C[\uDFFC-\uDFFF])))?|\uDFFC(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?\uDC68\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF-\uDDB3\uDDBC\uDDBD]|\uDD1D\u200D\uD83D\uDC68\uD83C[\uDFFB\uDFFD-\uDFFF])))?|\uDFFD(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?\uDC68\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF-\uDDB3\uDDBC\uDDBD]|\uDD1D\u200D\uD83D\uDC68\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF])))?|\uDFFE(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?\uDC68\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF-\uDDB3\uDDBC\uDDBD]|\uDD1D\u200D\uD83D\uDC68\uD83C[\uDFFB-\uDFFD\uDFFF])))?|\uDFFF(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?\uDC68\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF-\uDDB3\uDDBC\uDDBD]|\uDD1D\u200D\uD83D\uDC68\uD83C[\uDFFB-\uDFFE])))?))?|\uDC69(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?[\uDC68\uDC69]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D(?:[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uDC66(?:\u200D\uD83D\uDC66)?|\uDC67(?:\u200D\uD83D[\uDC66\uDC67])?|\uDC69\u200D\uD83D(?:\uDC66(?:\u200D\uD83D\uDC66)?|\uDC67(?:\u200D\uD83D[\uDC66\uDC67])?))|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C(?:\uDFFB(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:[\uDC68\uDC69]|\uDC8B\u200D\uD83D[\uDC68\uDC69])\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF-\uDDB3\uDDBC\uDDBD]|\uDD1D\u200D\uD83D[\uDC68\uDC69]\uD83C[\uDFFC-\uDFFF])))?|\uDFFC(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:[\uDC68\uDC69]|\uDC8B\u200D\uD83D[\uDC68\uDC69])\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF-\uDDB3\uDDBC\uDDBD]|\uDD1D\u200D\uD83D[\uDC68\uDC69]\uD83C[\uDFFB\uDFFD-\uDFFF])))?|\uDFFD(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:[\uDC68\uDC69]|\uDC8B\u200D\uD83D[\uDC68\uDC69])\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF-\uDDB3\uDDBC\uDDBD]|\uDD1D\u200D\uD83D[\uDC68\uDC69]\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF])))?|\uDFFE(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:[\uDC68\uDC69]|\uDC8B\u200D\uD83D[\uDC68\uDC69])\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF-\uDDB3\uDDBC\uDDBD]|\uDD1D\u200D\uD83D[\uDC68\uDC69]\uD83C[\uDFFB-\uDFFD\uDFFF])))?|\uDFFF(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:[\uDC68\uDC69]|\uDC8B\u200D\uD83D[\uDC68\uDC69])\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF-\uDDB3\uDDBC\uDDBD]|\uDD1D\u200D\uD83D[\uDC68\uDC69]\uD83C[\uDFFB-\uDFFE])))?))?|\uDC6F(?:\u200D[\u2640\u2642]\uFE0F?)?|\uDD75(?:\uFE0F|\uD83C[\uDFFB-\uDFFF])?(?:\u200D[\u2640\u2642]\uFE0F?)?|\uDE2E(?:\u200D\uD83D\uDCA8)?|\uDE35(?:\u200D\uD83D\uDCAB)?|\uDE36(?:\u200D\uD83C\uDF2B\uFE0F?)?)|\uD83E(?:[\uDD0C\uDD0F\uDD18-\uDD1F\uDD30-\uDD34\uDD36\uDD77\uDDB5\uDDB6\uDDBB\uDDD2\uDDD3\uDDD5\uDEC3-\uDEC5\uDEF0\uDEF2-\uDEF8](?:\uD83C[\uDFFB-\uDFFF])?|[\uDD26\uDD35\uDD37-\uDD39\uDD3D\uDD3E\uDDB8\uDDB9\uDDCD-\uDDCF\uDDD4\uDDD6-\uDDDD](?:\uD83C[\uDFFB-\uDFFF])?(?:\u200D[\u2640\u2642]\uFE0F?)?|[\uDDDE\uDDDF](?:\u200D[\u2640\u2642]\uFE0F?)?|[\uDD0D\uDD0E\uDD10-\uDD17\uDD20-\uDD25\uDD27-\uDD2F\uDD3A\uDD3F-\uDD45\uDD47-\uDD76\uDD78-\uDDB4\uDDB7\uDDBA\uDDBC-\uDDCC\uDDD0\uDDE0-\uDDFF\uDE70-\uDE7C\uDE80-\uDE88\uDE90-\uDEBD\uDEBF-\uDEC2\uDECE-\uDEDB\uDEE0-\uDEE8]|\uDD3C(?:\u200D[\u2640\u2642]\uFE0F?|\uD83C[\uDFFB-\uDFFF])?|\uDDD1(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF-\uDDB3\uDDBC\uDDBD]|\uDD1D\u200D\uD83E\uDDD1))|\uD83C(?:\uDFFB(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1\uD83C[\uDFFC-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF-\uDDB3\uDDBC\uDDBD]|\uDD1D\u200D\uD83E\uDDD1\uD83C[\uDFFB-\uDFFF])))?|\uDFFC(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1\uD83C[\uDFFB\uDFFD-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF-\uDDB3\uDDBC\uDDBD]|\uDD1D\u200D\uD83E\uDDD1\uD83C[\uDFFB-\uDFFF])))?|\uDFFD(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF-\uDDB3\uDDBC\uDDBD]|\uDD1D\u200D\uD83E\uDDD1\uD83C[\uDFFB-\uDFFF])))?|\uDFFE(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1\uD83C[\uDFFB-\uDFFD\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF-\uDDB3\uDDBC\uDDBD]|\uDD1D\u200D\uD83E\uDDD1\uD83C[\uDFFB-\uDFFF])))?|\uDFFF(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1\uD83C[\uDFFB-\uDFFE]|\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF-\uDDB3\uDDBC\uDDBD]|\uDD1D\u200D\uD83E\uDDD1\uD83C[\uDFFB-\uDFFF])))?))?|\uDEF1(?:\uD83C(?:\uDFFB(?:\u200D\uD83E\uDEF2\uD83C[\uDFFC-\uDFFF])?|\uDFFC(?:\u200D\uD83E\uDEF2\uD83C[\uDFFB\uDFFD-\uDFFF])?|\uDFFD(?:\u200D\uD83E\uDEF2\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF])?|\uDFFE(?:\u200D\uD83E\uDEF2\uD83C[\uDFFB-\uDFFD\uDFFF])?|\uDFFF(?:\u200D\uD83E\uDEF2\uD83C[\uDFFB-\uDFFE])?))?)/g;
var $1 = new RegExp(W1(), "");
var Sa = { emoji: $1, symbol: /\p{Symbol}/u, math: /\p{Math}/u };
var ka = { "ja-JP": /\p{scx=Hira}|\p{scx=Kana}|\p{scx=Han}|[\u3000]|[\uFF00-\uFFEF]/u, "ko-KR": /\p{scx=Hangul}/u, "zh-CN": /\p{scx=Han}/u, "zh-TW": /\p{scx=Han}/u, "zh-HK": /\p{scx=Han}/u, "th-TH": /\p{scx=Thai}/u, "bn-IN": /\p{scx=Bengali}/u, "ar-AR": /\p{scx=Arabic}/u, "ta-IN": /\p{scx=Tamil}/u, "ml-IN": /\p{scx=Malayalam}/u, "he-IL": /\p{scx=Hebrew}/u, "te-IN": /\p{scx=Telugu}/u, devanagari: /\p{scx=Devanagari}/u, kannada: /\p{scx=Kannada}/u };
var $a = Object.keys({ ...ka, ...Sa });
function j1(e) {
  return $a.includes(e);
}
function z1(e, t) {
  for (let n of Object.keys(Sa))
    if (Sa[n].test(e))
      return [n];
  let r2 = Object.keys(ka).filter((n) => ka[n].test(e));
  if (r2.length === 0)
    return ["unknown"];
  if (t) {
    let n = r2.findIndex((i) => i === t);
    n !== -1 && (r2.splice(n, 1), r2.unshift(t));
  }
  return r2;
}
function V1(e) {
  if (e)
    return $a.find((t) => t.toLowerCase().startsWith(e.toLowerCase()));
}
async function* Ta(e, t) {
  var r2;
  let n = await Kn(), { id: i, inheritedStyle: a, parent: o, font: u, debug: s, locale: l, embedFont: f = true, graphemeImages: c, canLoadAdditionalAssets: p2, getTwStyles: d } = t;
  if (e === null || typeof e > "u")
    return yield, yield, "";
  if (!jn(e) || typeof e.type == "function") {
    let N;
    if (!jn(e))
      N = F1(String(e), t), yield (await N.next()).value;
    else {
      if (kg(e.type))
        throw new Error("Class component is not supported.");
      N = Ta(e.type(e.props), t), yield (await N.next()).value;
    }
    await N.next();
    let ae = yield;
    return (await N.next(ae)).value;
  }
  let { type: D, props: v } = e;
  if (v && Tg(v))
    throw new Error("dangerouslySetInnerHTML property is not supported. See documentation for more information https://github.com/vercel/satori#jsx.");
  let { style: g, children: y, tw: b, lang: C = l } = v || {}, k = V1(C);
  if (b) {
    let N = d(b, g);
    g = Object.assign(N, g);
  }
  let S = n.Node.create();
  o.insertChild(S, o.getChildCount());
  let [E, L] = await s1(S, D, a, g, v), T = E.transform === a.transform;
  if (T || (E.transform.__parent = a.transform), (E.overflow === "hidden" || E.clipPath && E.clipPath !== "none") && (L._inheritedClipPathId = `satori_cp-${i}`, L._inheritedMaskId = `satori_om-${i}`), E.maskImage && (L._inheritedMaskId = `satori_mi-${i}`), E.backgroundClip === "text") {
    let N = { value: "" };
    L._inheritedBackgroundClipTextPath = N, E._inheritedBackgroundClipTextPath = N;
  }
  let U = _g(y), M = [], H = 0, q = [];
  for (let N of U) {
    let ae = Ta(N, { id: i + "-" + H++, parentStyle: E, inheritedStyle: L, isInheritingTransform: true, parent: S, font: u, embedFont: f, debug: s, graphemeImages: c, canLoadAdditionalAssets: p2, locale: k, getTwStyles: d, onNodeDetected: t.onNodeDetected });
    p2 ? q.push(...(await ae.next()).value || []) : await ae.next(), M.push(ae);
  }
  yield q;
  for (let N of M)
    await N.next();
  let [ee, A] = yield, { left: R, top: O, width: Y, height: Z } = S.getComputedLayout();
  R += ee, O += A;
  let te = "", ie = "", B = "", { children: z, ..._ } = v;
  if ((r2 = t.onNodeDetected) == null || r2.call(t, { left: R, top: O, width: Y, height: Z, type: D, props: _, key: e.key, textContent: jn(z) ? void 0 : z }), D === "img") {
    let N = E.__src;
    ie = await ga({ id: i, left: R, top: O, width: Y, height: Z, src: N, isInheritingTransform: T, debug: s }, E, L);
  } else if (D === "svg") {
    let N = E.color, ae = await Hg(e, N);
    ie = await ga({ id: i, left: R, top: O, width: Y, height: Z, src: ae, isInheritingTransform: T, debug: s }, E, L);
  } else {
    let N = g?.display;
    if (D === "div" && y && typeof y != "string" && N !== "flex" && N !== "none")
      throw new Error('Expected <div> to have explicit "display: flex" or "display: none" if it has more than one child node.');
    ie = await ga({ id: i, left: R, top: O, width: Y, height: Z, isInheritingTransform: T, debug: s }, E, L);
  }
  for (let N of M)
    te += (await N.next([R, O])).value;
  return E._inheritedBackgroundClipTextPath && (B += ue("clipPath", { id: `satori_bct-${i}`, "clip-path": E._inheritedClipPathId ? `url(#${E._inheritedClipPathId})` : void 0 }, E._inheritedBackgroundClipTextPath.value)), B + ie + te;
}
var kl = "unknown";
function H1(e, t, [r2, n], [i, a]) {
  if (r2 !== i)
    return r2 ? !i || r2 === e ? -1 : i === e ? 1 : e === 400 && r2 === 500 || e === 500 && r2 === 400 ? -1 : e === 400 && i === 500 || e === 500 && i === 400 ? 1 : e < 400 ? r2 < e && i < e ? i - r2 : r2 < e ? -1 : i < e ? 1 : r2 - i : e < r2 && e < i ? r2 - i : e < r2 ? -1 : e < i ? 1 : i - r2 : 1;
  if (n !== a) {
    if (n === t)
      return -1;
    if (a === t)
      return 1;
  }
  return -1;
}
var X1 = class {
  defaultFont;
  fonts = /* @__PURE__ */ new Map();
  constructor(e) {
    this.addFonts(e);
  }
  get({ name: e, weight: t, style: r2 }) {
    if (!this.fonts.has(e))
      return null;
    t === "normal" && (t = 400), t === "bold" && (t = 700), typeof t == "string" && (t = Number.parseInt(t, 10));
    let n = [...this.fonts.get(e)], i = n[0];
    for (let a = 1; a < n.length; a++) {
      let [, o, u] = i, [, s, l] = n[a];
      H1(t, r2, [o, u], [s, l]) > 0 && (i = n[a]);
    }
    return i[0];
  }
  addFonts(e) {
    for (let t of e) {
      let { name: r2, data: n, lang: i } = t;
      if (i && !j1(i))
        throw new Error(`Invalid value for props \`lang\`: "${i}". The value must be one of the following: ${$a.join(", ")}.`);
      let a = i ?? kl, o = Ln.parse("buffer" in n ? n.buffer.slice(n.byteOffset, n.byteOffset + n.byteLength) : n, { lowMemory: true }), u = o.charToGlyphIndex;
      o.charToGlyphIndex = (l) => {
        let f = u.call(o, l);
        return f === 0 && o._trackBrokenChars && o._trackBrokenChars.push(l), f;
      }, this.defaultFont || (this.defaultFont = o);
      let s = `${r2.toLowerCase()}_${a}`;
      this.fonts.has(s) || this.fonts.set(s, []), this.fonts.get(s).push([o, t.weight, t.style]);
    }
  }
  getEngine(e = 16, t = 1.2, { fontFamily: r2 = "sans-serif", fontWeight: n = 400, fontStyle: i = "normal" }, a) {
    if (!this.fonts.size)
      throw new Error("No fonts are loaded. At least one font is required to calculate the layout.");
    r2 = (Array.isArray(r2) ? r2 : [r2]).map((y) => y.toLowerCase());
    let o = [];
    r2.forEach((y) => {
      let b = this.get({ name: y, weight: n, style: i });
      if (b) {
        o.push(b);
        return;
      }
      let C = this.get({ name: y + "_unknown", weight: n, style: i });
      if (C) {
        o.push(C);
        return;
      }
    });
    let u = Array.from(this.fonts.keys()), s = [], l = [], f = [];
    for (let y of u)
      if (!r2.includes(y))
        if (a) {
          let b = q1(y);
          b ? b === a ? s.push(this.get({ name: y, weight: n, style: i })) : l.push(this.get({ name: y, weight: n, style: i })) : f.push(this.get({ name: y, weight: n, style: i }));
        } else
          f.push(this.get({ name: y, weight: n, style: i }));
    let c = /* @__PURE__ */ new Map(), p2 = (y, b = true) => {
      let C = [...o, ...f, ...s, ...b ? l : []];
      if (typeof y > "u")
        return b ? C[C.length - 1] : void 0;
      let k = y.charCodeAt(0);
      if (c.has(k))
        return c.get(k);
      let S = C.find((E, L) => !!E.charToGlyphIndex(y) || b && L === C.length - 1);
      return S && c.set(k, S), S;
    }, d = (y, b = false) => {
      var C, k;
      return ((b ? (k = (C = y.tables) == null ? void 0 : C.os2) == null ? void 0 : k.sTypoAscender : 0) || y.ascender) / y.unitsPerEm * e;
    }, D = (y, b = false) => {
      var C, k;
      return ((b ? (k = (C = y.tables) == null ? void 0 : C.os2) == null ? void 0 : k.sTypoDescender : 0) || y.descender) / y.unitsPerEm * e;
    }, v = (y) => p2(y, false), g = { has: (y) => {
      if (y === `
`)
        return true;
      let b = v(y);
      return b ? (b._trackBrokenChars = [], b.stringToGlyphs(y), b._trackBrokenChars.length ? (b._trackBrokenChars = void 0, false) : true) : false;
    }, baseline: (y, b = typeof y > "u" ? o[0] : p2(y)) => {
      let C = d(b, true), k = D(b, true), S = g.height(y, b), { yMax: E, yMin: L } = b.tables.head, T = C - k, U = (E / (E - L) - 1) * T;
      return S * ((1.2 / t + 1) / 2) + U;
    }, height: (y, b = typeof y > "u" ? o[0] : p2(y)) => (d(b) - D(b)) * (t / 1.2), measure: (y, b) => this.measure(p2, y, b), getSVG: (y, b) => this.getSVG(p2, y, b) };
    return g;
  }
  patchFontFallbackResolver(e, t) {
    let r2 = [];
    e._trackBrokenChars = r2;
    let n = e.stringToGlyphs;
    return e.stringToGlyphs = (i, ...a) => {
      let o = n.call(e, i, ...a);
      for (let u = 0; u < o.length; u++)
        if (o[u].unicode === void 0) {
          let s = r2.shift(), l = t(s);
          if (l !== e) {
            let f = l.charToGlyph(s), c = e.unitsPerEm / l.unitsPerEm, p2 = new Ln.Path();
            p2.unitsPerEm = e.unitsPerEm, p2.commands = f.path.commands.map((D) => {
              let v = { ...D };
              for (let g in v)
                typeof v[g] == "number" && (v[g] *= c);
              return v;
            });
            let d = new Ln.Glyph({ ...f, advanceWidth: f.advanceWidth * c, xMin: f.xMin * c, xMax: f.xMax * c, yMin: f.yMin * c, yMax: f.yMax * c, path: p2 });
            o[u] = d;
          }
        }
      return o;
    }, () => {
      e.stringToGlyphs = n, e._trackBrokenChars = void 0;
    };
  }
  measure(e, t, { fontSize: r2, letterSpacing: n = 0 }) {
    let i = e(t), a = this.patchFontFallbackResolver(i, e);
    try {
      return i.getAdvanceWidth(t, r2, { letterSpacing: n / r2 });
    } finally {
      a();
    }
  }
  getSVG(e, t, { fontSize: r2, top: n, left: i, letterSpacing: a = 0 }) {
    let o = e(t), u = this.patchFontFallbackResolver(o, e);
    try {
      return r2 === 0 ? "" : o.getPath(t.replace(/\n/g, ""), i, n, r2, { letterSpacing: a / r2 }).toPathData(1);
    } finally {
      u();
    }
  }
};
function q1(e) {
  let t = e.split("_"), r2 = t[t.length - 1];
  return r2 === kl ? void 0 : r2;
}
function Y1({ width: e, height: t, content: r2 }) {
  return ue("svg", { width: e, height: t, viewBox: `0 0 ${e} ${t}`, xmlns: "http://www.w3.org/2000/svg" }, r2);
}
var Z1 = Iv(vg());
var J1 = ["ios", "android", "windows", "macos", "web"];
function K1(e) {
  return J1.includes(e);
}
var Q1 = ["portrait", "landscape"];
function em(e) {
  return Q1.includes(e);
}
var Eu;
(function(e) {
  e.fontSize = "fontSize", e.lineHeight = "lineHeight";
})(Eu || (Eu = {}));
var Re;
(function(e) {
  e.rem = "rem", e.em = "em", e.px = "px", e.percent = "%", e.vw = "vw", e.vh = "vh", e.none = "<no-css-unit>";
})(Re || (Re = {}));
function Fu(e) {
  return typeof e == "string";
}
function Cu(e) {
  return typeof e == "object";
}
var ma;
function V(e) {
  return { kind: "complete", style: e };
}
function Ft(e, t = {}) {
  let { fractions: r2 } = t;
  if (r2 && e.includes("/")) {
    let [a = "", o = ""] = e.split("/", 2), u = Ft(a), s = Ft(o);
    return !u || !s ? null : [u[0] / s[0], s[1]];
  }
  let n = parseFloat(e);
  if (Number.isNaN(n))
    return null;
  let i = e.match(/(([a-z]{2,}|%))$/);
  if (!i)
    return [n, Re.none];
  switch (i?.[1]) {
    case "rem":
      return [n, Re.rem];
    case "px":
      return [n, Re.px];
    case "em":
      return [n, Re.em];
    case "%":
      return [n, Re.percent];
    case "vw":
      return [n, Re.vw];
    case "vh":
      return [n, Re.vh];
    default:
      return null;
  }
}
function an(e, t, r2 = {}) {
  let n = yr(t, r2);
  return n === null ? null : V({ [e]: n });
}
function Da(e, t, r2) {
  let n = yr(t);
  return n !== null && (r2[e] = n), r2;
}
function tm(e, t) {
  let r2 = yr(t);
  return r2 === null ? null : { [e]: r2 };
}
function yr(e, t = {}) {
  if (e === void 0)
    return null;
  let r2 = Ft(String(e), t);
  return r2 ? on(...r2, t) : null;
}
function on(e, t, r2 = {}) {
  let { isNegative: n, device: i } = r2;
  switch (t) {
    case Re.rem:
      return e * 16 * (n ? -1 : 1);
    case Re.px:
      return e * (n ? -1 : 1);
    case Re.percent:
      return `${n ? "-" : ""}${e}%`;
    case Re.none:
      return e * (n ? -1 : 1);
    case Re.vw:
      return i != null && i.windowDimensions ? i.windowDimensions.width * (e / 100) : (Kt("`vw` CSS unit requires configuration with `useDeviceContext()`"), null);
    case Re.vh:
      return i != null && i.windowDimensions ? i.windowDimensions.height * (e / 100) : (Kt("`vh` CSS unit requires configuration with `useDeviceContext()`"), null);
    default:
      return null;
  }
}
function Su(e) {
  let t = Ft(e);
  if (!t)
    return null;
  let [r2, n] = t;
  switch (n) {
    case Re.rem:
      return r2 * 16;
    case Re.px:
      return r2;
    default:
      return null;
  }
}
var rm = { t: "Top", tr: "TopRight", tl: "TopLeft", b: "Bottom", br: "BottomRight", bl: "BottomLeft", l: "Left", r: "Right", x: "Horizontal", y: "Vertical" };
function Tl(e) {
  return rm[e ?? ""] || "All";
}
function _l(e) {
  let t = "All";
  return [e.replace(/^-(t|b|r|l|tr|tl|br|bl)(-|$)/, (r2, n) => (t = Tl(n), "")), t];
}
function ii(e, t = {}) {
  if (e.includes("/")) {
    let r2 = ku(e, { ...t, fractions: true });
    if (r2)
      return r2;
  }
  return e[0] === "[" && (e = e.slice(1, -1)), ku(e, t);
}
function br(e, t, r2 = {}) {
  let n = ii(t, r2);
  return n === null ? null : V({ [e]: n });
}
function ku(e, t = {}) {
  if (e === "px")
    return 1;
  let r2 = Ft(e, t);
  if (!r2)
    return null;
  let [n, i] = r2;
  return t.fractions && (i = Re.percent, n *= 100), i === Re.none && (n = n / 4, i = Re.rem), on(n, i, t);
}
function nm(...e) {
  console.warn(...e);
}
function im(...e) {
}
var Kt = typeof process > "u" || ((ma = process == null ? void 0 : process.env) === null || ma === void 0 ? void 0 : ma.JEST_WORKER_ID) === void 0 ? nm : im;
var am = [["aspect-square", V({ aspectRatio: 1 })], ["aspect-video", V({ aspectRatio: 16 / 9 })], ["items-center", V({ alignItems: "center" })], ["items-start", V({ alignItems: "flex-start" })], ["items-end", V({ alignItems: "flex-end" })], ["items-baseline", V({ alignItems: "baseline" })], ["items-stretch", V({ alignItems: "stretch" })], ["justify-start", V({ justifyContent: "flex-start" })], ["justify-end", V({ justifyContent: "flex-end" })], ["justify-center", V({ justifyContent: "center" })], ["justify-between", V({ justifyContent: "space-between" })], ["justify-around", V({ justifyContent: "space-around" })], ["justify-evenly", V({ justifyContent: "space-evenly" })], ["content-start", V({ alignContent: "flex-start" })], ["content-end", V({ alignContent: "flex-end" })], ["content-between", V({ alignContent: "space-between" })], ["content-around", V({ alignContent: "space-around" })], ["content-stretch", V({ alignContent: "stretch" })], ["content-center", V({ alignContent: "center" })], ["self-auto", V({ alignSelf: "auto" })], ["self-start", V({ alignSelf: "flex-start" })], ["self-end", V({ alignSelf: "flex-end" })], ["self-center", V({ alignSelf: "center" })], ["self-stretch", V({ alignSelf: "stretch" })], ["self-baseline", V({ alignSelf: "baseline" })], ["direction-inherit", V({ direction: "inherit" })], ["direction-ltr", V({ direction: "ltr" })], ["direction-rtl", V({ direction: "rtl" })], ["hidden", V({ display: "none" })], ["flex", V({ display: "flex" })], ["flex-row", V({ flexDirection: "row" })], ["flex-row-reverse", V({ flexDirection: "row-reverse" })], ["flex-col", V({ flexDirection: "column" })], ["flex-col-reverse", V({ flexDirection: "column-reverse" })], ["flex-wrap", V({ flexWrap: "wrap" })], ["flex-wrap-reverse", V({ flexWrap: "wrap-reverse" })], ["flex-nowrap", V({ flexWrap: "nowrap" })], ["flex-auto", V({ flexGrow: 1, flexShrink: 1, flexBasis: "auto" })], ["flex-initial", V({ flexGrow: 0, flexShrink: 1, flexBasis: "auto" })], ["flex-none", V({ flexGrow: 0, flexShrink: 0, flexBasis: "auto" })], ["overflow-hidden", V({ overflow: "hidden" })], ["overflow-visible", V({ overflow: "visible" })], ["overflow-scroll", V({ overflow: "scroll" })], ["absolute", V({ position: "absolute" })], ["relative", V({ position: "relative" })], ["italic", V({ fontStyle: "italic" })], ["not-italic", V({ fontStyle: "normal" })], ["oldstyle-nums", Jr("oldstyle-nums")], ["small-caps", Jr("small-caps")], ["lining-nums", Jr("lining-nums")], ["tabular-nums", Jr("tabular-nums")], ["proportional-nums", Jr("proportional-nums")], ["font-thin", V({ fontWeight: "100" })], ["font-100", V({ fontWeight: "100" })], ["font-extralight", V({ fontWeight: "200" })], ["font-200", V({ fontWeight: "200" })], ["font-light", V({ fontWeight: "300" })], ["font-300", V({ fontWeight: "300" })], ["font-normal", V({ fontWeight: "normal" })], ["font-400", V({ fontWeight: "400" })], ["font-medium", V({ fontWeight: "500" })], ["font-500", V({ fontWeight: "500" })], ["font-semibold", V({ fontWeight: "600" })], ["font-600", V({ fontWeight: "600" })], ["font-bold", V({ fontWeight: "bold" })], ["font-700", V({ fontWeight: "700" })], ["font-extrabold", V({ fontWeight: "800" })], ["font-800", V({ fontWeight: "800" })], ["font-black", V({ fontWeight: "900" })], ["font-900", V({ fontWeight: "900" })], ["include-font-padding", V({ includeFontPadding: true })], ["remove-font-padding", V({ includeFontPadding: false })], ["max-w-none", V({ maxWidth: "99999%" })], ["text-left", V({ textAlign: "left" })], ["text-center", V({ textAlign: "center" })], ["text-right", V({ textAlign: "right" })], ["text-justify", V({ textAlign: "justify" })], ["text-auto", V({ textAlign: "auto" })], ["underline", V({ textDecorationLine: "underline" })], ["line-through", V({ textDecorationLine: "line-through" })], ["no-underline", V({ textDecorationLine: "none" })], ["uppercase", V({ textTransform: "uppercase" })], ["lowercase", V({ textTransform: "lowercase" })], ["capitalize", V({ textTransform: "capitalize" })], ["normal-case", V({ textTransform: "none" })], ["w-auto", V({ width: "auto" })], ["h-auto", V({ height: "auto" })], ["shadow-sm", V({ shadowOffset: { width: 1, height: 1 }, shadowColor: "#000", shadowRadius: 1, shadowOpacity: 0.025, elevation: 1 })], ["shadow", V({ shadowOffset: { width: 1, height: 1 }, shadowColor: "#000", shadowRadius: 1, shadowOpacity: 0.075, elevation: 2 })], ["shadow-md", V({ shadowOffset: { width: 1, height: 1 }, shadowColor: "#000", shadowRadius: 3, shadowOpacity: 0.125, elevation: 3 })], ["shadow-lg", V({ shadowOffset: { width: 1, height: 1 }, shadowColor: "#000", shadowOpacity: 0.15, shadowRadius: 8, elevation: 8 })], ["shadow-xl", V({ shadowOffset: { width: 1, height: 1 }, shadowColor: "#000", shadowOpacity: 0.19, shadowRadius: 20, elevation: 12 })], ["shadow-2xl", V({ shadowOffset: { width: 1, height: 1 }, shadowColor: "#000", shadowOpacity: 0.25, shadowRadius: 30, elevation: 16 })], ["shadow-none", V({ shadowOffset: { width: 0, height: 0 }, shadowColor: "#000", shadowRadius: 0, shadowOpacity: 0, elevation: 0 })]];
var Tu = am;
function Jr(e) {
  return { kind: "dependent", complete(t) {
    (!t.fontVariant || !Array.isArray(t.fontVariant)) && (t.fontVariant = []), t.fontVariant.push(e);
  } };
}
var om = class {
  constructor(e) {
    this.ir = new Map(Tu), this.styles = /* @__PURE__ */ new Map(), this.prefixes = /* @__PURE__ */ new Map(), this.ir = new Map([...Tu, ...e ?? []]);
  }
  getStyle(e) {
    return this.styles.get(e);
  }
  setStyle(e, t) {
    this.styles.set(e, t);
  }
  getIr(e) {
    return this.ir.get(e);
  }
  setIr(e, t) {
    this.ir.set(e, t);
  }
  getPrefixMatch(e) {
    return this.prefixes.get(e);
  }
  setPrefixMatch(e, t) {
    this.prefixes.set(e, t);
  }
};
function sm(e, t, r2 = {}) {
  let n = t?.[e];
  if (!n)
    return br("fontSize", e, r2);
  if (typeof n == "string")
    return an("fontSize", n);
  let i = {}, [a, o] = n, u = tm("fontSize", a);
  if (u && (i = u), typeof o == "string")
    return V(Da("lineHeight", _u(o, i), i));
  let { lineHeight: s, letterSpacing: l } = o;
  return s && Da("lineHeight", _u(s, i), i), l && Da("letterSpacing", l, i), V(i);
}
function _u(e, t) {
  let r2 = Ft(e);
  if (r2) {
    let [n, i] = r2;
    if ((i === Re.none || i === Re.em) && typeof t.fontSize == "number")
      return t.fontSize * n;
  }
  return e;
}
function um(e, t) {
  var r2;
  let n = (r2 = t?.[e]) !== null && r2 !== void 0 ? r2 : e.startsWith("[") ? e.slice(1, -1) : e, i = Ft(n);
  if (!i)
    return null;
  let [a, o] = i;
  if (o === Re.none)
    return { kind: "dependent", complete(s) {
      if (typeof s.fontSize != "number")
        return "relative line-height utilities require that font-size be set";
      s.lineHeight = s.fontSize * a;
    } };
  let u = on(a, o);
  return u !== null ? V({ lineHeight: u }) : null;
}
function lm(e, t, r2, n, i) {
  let a = "";
  if (n[0] === "[")
    a = n.slice(1, -1);
  else {
    let l = i?.[n];
    if (l)
      a = l;
    else {
      let f = ii(n);
      return f && typeof f == "number" ? Au(f, Re.px, t, e) : null;
    }
  }
  if (a === "auto")
    return Al(t, e, "auto");
  let o = Ft(a);
  if (!o)
    return null;
  let [u, s] = o;
  return r2 && (u = -u), Au(u, s, t, e);
}
function Au(e, t, r2, n) {
  let i = on(e, t);
  return i === null ? null : Al(r2, n, i);
}
function Al(e, t, r2) {
  switch (e) {
    case "All":
      return { kind: "complete", style: { [`${t}Top`]: r2, [`${t}Right`]: r2, [`${t}Bottom`]: r2, [`${t}Left`]: r2 } };
    case "Bottom":
    case "Top":
    case "Left":
    case "Right":
      return { kind: "complete", style: { [`${t}${e}`]: r2 } };
    case "Vertical":
      return { kind: "complete", style: { [`${t}Top`]: r2, [`${t}Bottom`]: r2 } };
    case "Horizontal":
      return { kind: "complete", style: { [`${t}Left`]: r2, [`${t}Right`]: r2 } };
    default:
      return null;
  }
}
function fm(e) {
  if (!e)
    return {};
  let t = Object.entries(e).reduce((i, [a, o]) => {
    let u = [0, 1 / 0, 0], s = typeof o == "string" ? { min: o } : o, l = s.min ? Su(s.min) : 0;
    l === null ? Kt(`invalid screen config value: ${a}->min: ${s.min}`) : u[0] = l;
    let f = s.max ? Su(s.max) : 1 / 0;
    return f === null ? Kt(`invalid screen config value: ${a}->max: ${s.max}`) : u[1] = f, i[a] = u, i;
  }, {}), r2 = Object.values(t);
  r2.sort((i, a) => {
    let [o, u] = i, [s, l] = a;
    return u === 1 / 0 || l === 1 / 0 ? o - s : u - l;
  });
  let n = 0;
  return r2.forEach((i) => i[2] = n++), t;
}
function cm(e, t) {
  let r2 = t?.[e];
  if (!r2)
    return null;
  if (typeof r2 == "string")
    return V({ fontFamily: r2 });
  let n = r2[0];
  return n ? V({ fontFamily: n }) : null;
}
function tn(e, t, r2) {
  if (!r2)
    return null;
  let n;
  t.includes("/") && ([t = "", n] = t.split("/", 2));
  let i = "";
  if (t.startsWith("[#") || t.startsWith("[rgb") ? i = t.slice(1, -1) : i = Ol(t, r2), !i)
    return null;
  if (n) {
    let a = Number(n);
    if (!Number.isNaN(a))
      return i = Ou(i, a / 100), V({ [Hn[e].color]: i });
  }
  return { kind: "dependent", complete(a) {
    let o = Hn[e].opacity, u = a[o];
    typeof u == "number" && (i = Ou(i, u)), a[Hn[e].color] = i;
  } };
}
function Mn(e, t) {
  let r2 = parseInt(t, 10);
  if (Number.isNaN(r2))
    return null;
  let n = r2 / 100;
  return { kind: "complete", style: { [Hn[e].opacity]: n } };
}
function Ou(e, t) {
  return e.startsWith("#") ? e = hm(e) : e.startsWith("rgb(") && (e = e.replace(/^rgb\(/, "rgba(").replace(/\)$/, ", 1)")), e.replace(/, ?\d*\.?(\d+)\)$/, `, ${t})`);
}
function pm(e) {
  for (let t in e)
    t.startsWith("__opacity_") && delete e[t];
}
var Hn = { bg: { opacity: "__opacity_bg", color: "backgroundColor" }, text: { opacity: "__opacity_text", color: "color" }, border: { opacity: "__opacity_border", color: "borderColor" }, borderTop: { opacity: "__opacity_border", color: "borderTopColor" }, borderBottom: { opacity: "__opacity_border", color: "borderBottomColor" }, borderLeft: { opacity: "__opacity_border", color: "borderLeftColor" }, borderRight: { opacity: "__opacity_border", color: "borderRightColor" }, shadow: { opacity: "__opacity_shadow", color: "shadowColor" }, tint: { opacity: "__opacity_tint", color: "tintColor" } };
function hm(e) {
  let t = e;
  e = e.replace(dm, (o, u, s, l) => u + u + s + s + l + l);
  let r2 = vm.exec(e);
  if (!r2)
    return Kt(`invalid config hex color value: ${t}`), "rgba(0, 0, 0, 1)";
  let n = parseInt(r2[1], 16), i = parseInt(r2[2], 16), a = parseInt(r2[3], 16);
  return `rgba(${n}, ${i}, ${a}, 1)`;
}
function Ol(e, t) {
  let r2 = t[e];
  if (Fu(r2))
    return r2;
  if (Cu(r2) && Fu(r2.DEFAULT))
    return r2.DEFAULT;
  let [n = "", ...i] = e.split("-");
  for (; n !== e; ) {
    let a = t[n];
    if (Cu(a))
      return Ol(i.join("-"), a);
    if (i.length === 0)
      return "";
    n = `${n}-${i.shift()}`;
  }
  return "";
}
var dm = /^#?([a-f\d])([a-f\d])([a-f\d])$/i;
var vm = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i;
function gm(e, t) {
  let [r2, n] = _l(e);
  if (r2.match(/^(-?(\d)+)?$/))
    return mm(r2, n, t?.borderWidth);
  if (r2 = r2.replace(/^-/, ""), ["dashed", "solid", "dotted"].includes(r2))
    return V({ borderStyle: r2 });
  let i = "border";
  switch (n) {
    case "Bottom":
      i = "borderBottom";
      break;
    case "Top":
      i = "borderTop";
      break;
    case "Left":
      i = "borderLeft";
      break;
    case "Right":
      i = "borderRight";
      break;
  }
  let a = tn(i, r2, t?.borderColor);
  if (a)
    return a;
  let o = `border${n === "All" ? "" : n}Width`;
  r2 = r2.replace(/^-/, "");
  let u = r2.slice(1, -1), s = br(o, u);
  return typeof s?.style[o] != "number" ? null : s;
}
function mm(e, t, r2) {
  if (!r2)
    return null;
  e = e.replace(/^-/, "");
  let n = r2[e === "" ? "DEFAULT" : e];
  if (n === void 0)
    return null;
  let i = `border${t === "All" ? "" : t}Width`;
  return an(i, n);
}
function Dm(e, t) {
  if (!t)
    return null;
  let [r2, n] = _l(e);
  r2 = r2.replace(/^-/, ""), r2 === "" && (r2 = "DEFAULT");
  let i = `border${n === "All" ? "" : n}Radius`, a = t[r2];
  if (a)
    return Lu(an(i, a));
  let o = br(i, r2);
  return typeof o?.style[i] != "number" ? null : Lu(o);
}
function Lu(e) {
  if (e?.kind !== "complete")
    return e;
  let t = e.style.borderTopRadius;
  t !== void 0 && (e.style.borderTopLeftRadius = t, e.style.borderTopRightRadius = t, delete e.style.borderTopRadius);
  let r2 = e.style.borderBottomRadius;
  r2 !== void 0 && (e.style.borderBottomLeftRadius = r2, e.style.borderBottomRightRadius = r2, delete e.style.borderBottomRadius);
  let n = e.style.borderLeftRadius;
  n !== void 0 && (e.style.borderBottomLeftRadius = n, e.style.borderTopLeftRadius = n, delete e.style.borderLeftRadius);
  let i = e.style.borderRightRadius;
  return i !== void 0 && (e.style.borderBottomRightRadius = i, e.style.borderTopRightRadius = i, delete e.style.borderRightRadius), e;
}
function Kr(e, t, r2, n) {
  let i = null;
  e === "inset" && (t = t.replace(/^(x|y)-/, (u, s) => (i = s === "x" ? "x" : "y", "")));
  let a = n?.[t];
  if (a) {
    let u = yr(a, { isNegative: r2 });
    if (u !== null)
      return Iu(e, i, u);
  }
  let o = ii(t, { isNegative: r2 });
  return o !== null ? Iu(e, i, o) : null;
}
function Iu(e, t, r2) {
  if (e !== "inset")
    return V({ [e]: r2 });
  switch (t) {
    case null:
      return V({ top: r2, left: r2, right: r2, bottom: r2 });
    case "y":
      return V({ top: r2, bottom: r2 });
    case "x":
      return V({ left: r2, right: r2 });
  }
}
function Gn(e, t, r2) {
  var n;
  t = t.replace(/^-/, "");
  let i = t === "" ? "DEFAULT" : t, a = Number((n = r2?.[i]) !== null && n !== void 0 ? n : t);
  return Number.isNaN(a) ? null : V({ [`flex${e}`]: a });
}
function ym(e, t) {
  var r2, n;
  if (e = t?.[e] || e, ["min-content", "revert", "unset"].includes(e))
    return null;
  if (e.match(/^\d+(\.\d+)?$/))
    return V({ flexGrow: Number(e), flexBasis: "0%" });
  let i = e.match(/^(\d+)\s+(\d+)$/);
  if (i)
    return V({ flexGrow: Number(i[1]), flexShrink: Number(i[2]) });
  if (i = e.match(/^(\d+)\s+([^ ]+)$/), i) {
    let a = yr((r2 = i[2]) !== null && r2 !== void 0 ? r2 : "");
    return a ? V({ flexGrow: Number(i[1]), flexBasis: a }) : null;
  }
  if (i = e.match(/^(\d+)\s+(\d+)\s+(.+)$/), i) {
    let a = yr((n = i[3]) !== null && n !== void 0 ? n : "");
    return a ? V({ flexGrow: Number(i[1]), flexShrink: Number(i[2]), flexBasis: a }) : null;
  }
  return null;
}
function Pu(e, t, r2 = {}, n) {
  let i = n?.[t];
  return i !== void 0 ? an(e, i, r2) : br(e, t, r2);
}
function Wn(e, t, r2 = {}, n) {
  let i = yr(n?.[t], r2);
  return i ? V({ [e]: i }) : (t === "screen" && (t = e.includes("Width") ? "100vw" : "100vh"), br(e, t, r2));
}
function bm(e, t, r2) {
  let n = r2?.[e];
  if (n) {
    let i = Ft(n, { isNegative: t });
    if (!i)
      return null;
    let [a, o] = i;
    if (o === Re.em)
      return xm(a);
    if (o === Re.percent)
      return Kt("percentage-based letter-spacing configuration currently unsupported, switch to `em`s, or open an issue if you'd like to see support added."), null;
    let u = on(a, o, { isNegative: t });
    return u !== null ? V({ letterSpacing: u }) : null;
  }
  return br("letterSpacing", e, { isNegative: t });
}
function xm(e) {
  return { kind: "dependent", complete(t) {
    let r2 = t.fontSize;
    if (typeof r2 != "number" || Number.isNaN(r2))
      return "tracking-X relative letter spacing classes require font-size to be set";
    t.letterSpacing = Math.round((e * r2 + Number.EPSILON) * 100) / 100;
  } };
}
function wm(e, t) {
  let r2 = t?.[e];
  if (r2) {
    let i = Ft(String(r2));
    if (i)
      return V({ opacity: i[0] });
  }
  let n = Ft(e);
  return n ? V({ opacity: n[0] / 100 }) : null;
}
function Em(e) {
  let t = parseInt(e, 10);
  return Number.isNaN(t) ? null : { kind: "complete", style: { shadowOpacity: t / 100 } };
}
function Fm(e) {
  if (e.includes("/")) {
    let [r2 = "", n = ""] = e.split("/", 2), i = ya(r2), a = ya(n);
    return i === null || a === null ? null : { kind: "complete", style: { shadowOffset: { width: i, height: a } } };
  }
  let t = ya(e);
  return t === null ? null : { kind: "complete", style: { shadowOffset: { width: t, height: t } } };
}
function ya(e) {
  let t = ii(e);
  return typeof t == "number" ? t : null;
}
var Ru = class {
  constructor(e, t = {}, r2, n, i) {
    var a, o, u, s, l, f;
    this.config = t, this.cache = r2, this.position = 0, this.isNull = false, this.isNegative = false, this.context = {}, this.context.device = n;
    let c = e.trim().split(":"), p2 = [];
    c.length === 1 ? this.string = e : (this.string = (a = c.pop()) !== null && a !== void 0 ? a : "", p2 = c), this.char = this.string[0];
    let d = fm((o = this.config.theme) === null || o === void 0 ? void 0 : o.screens);
    for (let D of p2)
      if (d[D]) {
        let v = (u = d[D]) === null || u === void 0 ? void 0 : u[2];
        v !== void 0 && (this.order = ((s = this.order) !== null && s !== void 0 ? s : 0) + v);
        let g = (l = n.windowDimensions) === null || l === void 0 ? void 0 : l.width;
        if (g) {
          let [y, b] = (f = d[D]) !== null && f !== void 0 ? f : [0, 0];
          (g <= y || g > b) && (this.isNull = true);
        } else
          this.isNull = true;
      } else
        K1(D) ? this.isNull = D !== i : em(D) ? n.windowDimensions ? (n.windowDimensions.width > n.windowDimensions.height ? "landscape" : "portrait") !== D ? this.isNull = true : this.incrementOrder() : this.isNull = true : D === "retina" ? n.pixelDensity === 2 ? this.incrementOrder() : this.isNull = true : D === "dark" ? n.colorScheme !== "dark" ? this.isNull = true : this.incrementOrder() : this.handlePossibleArbitraryBreakpointPrefix(D) || (this.isNull = true);
  }
  parse() {
    if (this.isNull)
      return { kind: "null" };
    let e = this.cache.getIr(this.rest);
    if (e)
      return e;
    this.parseIsNegative();
    let t = this.parseUtility();
    return t ? this.order !== void 0 ? { kind: "ordered", order: this.order, styleIr: t } : t : { kind: "null" };
  }
  parseUtility() {
    var e, t, r2, n, i;
    let a = this.config.theme, o = null;
    switch (this.char) {
      case "m":
      case "p": {
        let u = this.peekSlice(1, 3).match(/^(t|b|r|l|x|y)?-/);
        if (u) {
          let s = this.char === "m" ? "margin" : "padding";
          this.advance(((t = (e = u[0]) === null || e === void 0 ? void 0 : e.length) !== null && t !== void 0 ? t : 0) + 1);
          let l = Tl(u[1]), f = lm(s, l, this.isNegative, this.rest, (r2 = this.config.theme) === null || r2 === void 0 ? void 0 : r2[s]);
          if (f)
            return f;
        }
      }
    }
    if (this.consumePeeked("h-") && (o = Pu("height", this.rest, this.context, a?.height), o) || this.consumePeeked("w-") && (o = Pu("width", this.rest, this.context, a?.width), o) || this.consumePeeked("min-w-") && (o = Wn("minWidth", this.rest, this.context, a?.minWidth), o) || this.consumePeeked("min-h-") && (o = Wn("minHeight", this.rest, this.context, a?.minHeight), o) || this.consumePeeked("max-w-") && (o = Wn("maxWidth", this.rest, this.context, a?.maxWidth), o) || this.consumePeeked("max-h-") && (o = Wn("maxHeight", this.rest, this.context, a?.maxHeight), o) || this.consumePeeked("leading-") && (o = um(this.rest, a?.lineHeight), o) || this.consumePeeked("text-") && (o = sm(this.rest, a?.fontSize, this.context), o || (o = tn("text", this.rest, a?.textColor), o) || this.consumePeeked("opacity-") && (o = Mn("text", this.rest), o)) || this.consumePeeked("font-") && (o = cm(this.rest, a?.fontFamily), o) || this.consumePeeked("aspect-") && (this.consumePeeked("ratio-") && Kt("`aspect-ratio-{ratio}` is deprecated, use `aspect-{ratio}` instead"), o = an("aspectRatio", this.rest, { fractions: true }), o) || this.consumePeeked("tint-") && (o = tn("tint", this.rest, a?.colors), o) || this.consumePeeked("bg-") && (o = tn("bg", this.rest, a?.backgroundColor), o || this.consumePeeked("opacity-") && (o = Mn("bg", this.rest), o)) || this.consumePeeked("border") && (o = gm(this.rest, a), o || this.consumePeeked("-opacity-") && (o = Mn("border", this.rest), o)) || this.consumePeeked("rounded") && (o = Dm(this.rest, a?.borderRadius), o) || this.consumePeeked("bottom-") && (o = Kr("bottom", this.rest, this.isNegative, a?.inset), o) || this.consumePeeked("top-") && (o = Kr("top", this.rest, this.isNegative, a?.inset), o) || this.consumePeeked("left-") && (o = Kr("left", this.rest, this.isNegative, a?.inset), o) || this.consumePeeked("right-") && (o = Kr("right", this.rest, this.isNegative, a?.inset), o) || this.consumePeeked("inset-") && (o = Kr("inset", this.rest, this.isNegative, a?.inset), o) || this.consumePeeked("flex-") && (this.consumePeeked("grow") ? o = Gn("Grow", this.rest, a?.flexGrow) : this.consumePeeked("shrink") ? o = Gn("Shrink", this.rest, a?.flexShrink) : o = ym(this.rest, a?.flex), o) || this.consumePeeked("grow") && (o = Gn("Grow", this.rest, a?.flexGrow), o) || this.consumePeeked("shrink") && (o = Gn("Shrink", this.rest, a?.flexShrink), o) || this.consumePeeked("shadow-color-opacity-") && (o = Mn("shadow", this.rest), o) || this.consumePeeked("shadow-opacity-") && (o = Em(this.rest), o) || this.consumePeeked("shadow-offset-") && (o = Fm(this.rest), o) || this.consumePeeked("shadow-radius-") && (o = br("shadowRadius", this.rest), o) || this.consumePeeked("shadow-") && (o = tn("shadow", this.rest, a?.colors), o))
      return o;
    if (this.consumePeeked("elevation-")) {
      let u = parseInt(this.rest, 10);
      if (!Number.isNaN(u))
        return V({ elevation: u });
    }
    if (this.consumePeeked("opacity-") && (o = wm(this.rest, a?.opacity), o) || this.consumePeeked("tracking-") && (o = bm(this.rest, this.isNegative, a?.letterSpacing), o))
      return o;
    if (this.consumePeeked("z-")) {
      let u = Number((i = (n = a?.zIndex) === null || n === void 0 ? void 0 : n[this.rest]) !== null && i !== void 0 ? i : this.rest);
      if (!Number.isNaN(u))
        return V({ zIndex: u });
    }
    return Kt(`\`${this.rest}\` unknown or invalid utility`), null;
  }
  handlePossibleArbitraryBreakpointPrefix(e) {
    var t;
    if (e[0] !== "m")
      return false;
    let r2 = e.match(/^(min|max)-(w|h)-\[([^\]]+)\]$/);
    if (!r2)
      return false;
    if (!(!((t = this.context.device) === null || t === void 0) && t.windowDimensions))
      return this.isNull = true, true;
    let n = this.context.device.windowDimensions, [, i = "", a = "", o = ""] = r2, u = a === "w" ? n.width : n.height, s = Ft(o, this.context);
    if (s === null)
      return this.isNull = true, true;
    let [l, f] = s;
    return f !== "px" && (this.isNull = true), (i === "min" ? u >= l : u <= l) ? this.incrementOrder() : this.isNull = true, true;
  }
  advance(e = 1) {
    this.position += e, this.char = this.string[this.position];
  }
  get rest() {
    return this.peekSlice(0, this.string.length);
  }
  peekSlice(e, t) {
    return this.string.slice(this.position + e, this.position + t);
  }
  consumePeeked(e) {
    return this.peekSlice(0, e.length) === e ? (this.advance(e.length), true) : false;
  }
  parseIsNegative() {
    this.char === "-" && (this.advance(), this.isNegative = true, this.context.isNegative = true);
  }
  incrementOrder() {
    var e;
    this.order = ((e = this.order) !== null && e !== void 0 ? e : 0) + 1;
  }
};
function Cm(e) {
  let t = [], r2 = null;
  return e.forEach((n) => {
    if (typeof n == "string")
      t = [...t, ...ba(n)];
    else if (Array.isArray(n))
      t = [...t, ...n.flatMap(ba)];
    else if (typeof n == "object" && n !== null)
      for (let [i, a] of Object.entries(n))
        typeof a == "boolean" ? t = [...t, ...a ? ba(i) : []] : r2 ? r2[i] = a : r2 = { [i]: a };
  }), [t.filter(Boolean).filter(Sm), r2];
}
function ba(e) {
  return e.trim().split(/\s+/);
}
function Sm(e, t, r2) {
  return r2.indexOf(e) === t;
}
function km(e) {
  var t;
  return (t = e?.reduce((r2, n) => ({ ...r2, ...Tm(n.handler) }), {})) !== null && t !== void 0 ? t : {};
}
function Tm(e) {
  let t = {};
  return e({ addUtilities: (r2) => {
    t = r2;
  }, ..._m }), t;
}
function jt(e) {
  throw new Error(`tailwindcss plugin function argument object prop "${e}" not implemented`);
}
var _m = { addComponents: jt, addBase: jt, addVariant: jt, e: jt, prefix: jt, theme: jt, variants: jt, config: jt, corePlugins: jt, matchUtilities: jt, postcss: null };
function Am(e, t) {
  let r2 = (0, Z1.default)(Om(e)), n = {}, i = km(r2.plugins), a = {}, o = Object.entries(i).map(([D, v]) => typeof v == "string" ? (a[D] = v, [D, { kind: "null" }]) : [D, V(v)]).filter(([, D]) => D.kind !== "null");
  function u() {
    return [n.windowDimensions ? `w${n.windowDimensions.width}` : false, n.windowDimensions ? `h${n.windowDimensions.height}` : false, n.fontScale ? `fs${n.fontScale}` : false, n.colorScheme === "dark" ? "dark" : false, n.pixelDensity === 2 ? "retina" : false].filter(Boolean).join("--") || "default";
  }
  let s = u(), l = {};
  function f() {
    let D = l[s];
    if (D)
      return D;
    let v = new om(o);
    return l[s] = v, v;
  }
  function c(...D) {
    let v = f(), g = {}, y = [], b = [], [C, k] = Cm(D), S = C.join(" "), E = v.getStyle(S);
    if (E)
      return { ...E, ...k || {} };
    for (let L of C) {
      let T = v.getIr(L);
      if (!T && L in a) {
        let U = c(a[L]);
        v.setIr(L, V(U)), g = { ...g, ...U };
        continue;
      }
      switch (T = new Ru(L, r2, v, n, t).parse(), T.kind) {
        case "complete":
          g = { ...g, ...T.style }, v.setIr(L, T);
          break;
        case "dependent":
          y.push(T);
          break;
        case "ordered":
          b.push(T);
          break;
        case "null":
          v.setIr(L, T);
          break;
      }
    }
    if (b.length > 0) {
      b.sort((L, T) => L.order - T.order);
      for (let L of b)
        switch (L.styleIr.kind) {
          case "complete":
            g = { ...g, ...L.styleIr.style };
            break;
          case "dependent":
            y.push(L.styleIr);
            break;
        }
    }
    if (y.length > 0) {
      for (let L of y) {
        let T = L.complete(g);
        T && Kt(T);
      }
      pm(g);
    }
    return S !== "" && v.setStyle(S, g), k && (g = { ...g, ...k }), g;
  }
  function p2(D) {
    let v = c(D.split(/\s+/g).map((g) => g.replace(/^(bg|text|border)-/, "")).map((g) => `bg-${g}`).join(" "));
    return typeof v.backgroundColor == "string" ? v.backgroundColor : void 0;
  }
  let d = (D, ...v) => {
    let g = "";
    return D.forEach((y, b) => {
      var C;
      g += y + ((C = v[b]) !== null && C !== void 0 ? C : "");
    }), c(g);
  };
  return d.style = c, d.color = p2, d.prefixMatch = (...D) => {
    let v = D.sort().join(":"), g = f(), y = g.getPrefixMatch(v);
    if (y !== void 0)
      return y;
    let b = new Ru(`${v}:flex`, r2, g, n, t).parse().kind !== "null";
    return g.setPrefixMatch(v, b), b;
  }, d.setWindowDimensions = (D) => {
    n.windowDimensions = D, s = u();
  }, d.setFontScale = (D) => {
    n.fontScale = D, s = u();
  }, d.setPixelDensity = (D) => {
    n.pixelDensity = D, s = u();
  }, d.setColorScheme = (D) => {
    n.colorScheme = D, s = u();
  }, d;
}
function Om(e) {
  return { ...e, content: ["_no_warnings_please"] };
}
var Lm = { handler: ({ addUtilities: e }) => {
  e({ "shadow-sm": { boxShadow: "0 1px 2px 0 rgb(0 0 0 / 0.05)" }, shadow: { boxShadow: "0 1px 3px 0 rgb(0 0 0 / 0.1), 0 1px 2px -1px rgb(0 0 0 / 0.1)" }, "shadow-md": { boxShadow: "0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1)" }, "shadow-lg": { boxShadow: "0 10px 15px -3px rgb(0 0 0 / 0.1), 0 4px 6px -4px rgb(0 0 0 / 0.1)" }, "shadow-xl": { boxShadow: "0 20px 25px -5px rgb(0 0 0 / 0.1), 0 8px 10px -6px rgb(0 0 0 / 0.1)" }, "shadow-2xl": { boxShadow: "0 25px 50px -12px rgb(0 0 0 / 0.25)" }, "shadow-inner": { boxShadow: "inset 0 2px 4px 0 rgb(0 0 0 / 0.05)" }, "shadow-none": { boxShadow: "0 0 #0000" } });
} };
function Im(e) {
  return Am({ ...e, plugins: [...e?.plugins ?? [], Lm] }, "web");
}
var $n;
function Pm({ width: e, height: t, config: r2 }) {
  return $n || ($n = Im(r2)), $n.setWindowDimensions({ width: +e, height: +t }), $n;
}
var xa = /* @__PURE__ */ new WeakMap();
async function Ll(e, t) {
  let r2 = await Kn();
  if (!r2 || !r2.Node)
    throw new Error("Satori is not initialized: expect `yoga` to be loaded, got " + r2);
  t.fonts = t.fonts || [];
  let n;
  xa.has(t.fonts) ? n = xa.get(t.fonts) : xa.set(t.fonts, n = new X1(t.fonts));
  let i = "width" in t ? t.width : void 0, a = "height" in t ? t.height : void 0, o = r2.Node.create();
  i && o.setWidth(i), a && o.setHeight(a), o.setFlexDirection(r2.FLEX_DIRECTION_ROW), o.setFlexWrap(r2.WRAP_WRAP), o.setAlignContent(r2.ALIGN_AUTO), o.setAlignItems(r2.ALIGN_FLEX_START), o.setJustifyContent(r2.JUSTIFY_FLEX_START), o.setOverflow(r2.OVERFLOW_HIDDEN);
  let u = { ...t.graphemeImages }, s = /* @__PURE__ */ new Set();
  cr.clear(), await Vg(e);
  let l = Ta(e, { id: "id", parentStyle: {}, inheritedStyle: { fontSize: 16, fontWeight: "normal", fontFamily: "serif", fontStyle: "normal", lineHeight: 1.2, color: "black", opacity: 1, whiteSpace: "normal", _viewportWidth: i, _viewportHeight: a }, parent: o, font: n, embedFont: t.embedFont, debug: t.debug, graphemeImages: u, canLoadAdditionalAssets: !!t.loadAdditionalAsset, onNodeDetected: t.onNodeDetected, getTwStyles: (D, v) => {
    let g = { ...Pm({ width: i, height: a, config: t.tailwindConfig })([D]) };
    return typeof g.lineHeight == "number" && (g.lineHeight = g.lineHeight / (+g.fontSize || v.fontSize || 16)), g.shadowColor && g.boxShadow && (g.boxShadow = g.boxShadow.replace(/rgba?\([^)]+\)/, g.shadowColor)), g;
  } }), f = (await l.next()).value;
  if (t.loadAdditionalAsset && f.length) {
    let D = Rm(f), v = [], g = {};
    await Promise.all(Object.entries(D).flatMap(([y, b]) => b.map((C) => {
      let k = `${y}_${C}`;
      return s.has(k) ? null : (s.add(k), t.loadAdditionalAsset(y, C).then((S) => {
        typeof S == "string" ? g[C] = S : S && (Array.isArray(S) ? v.push(...S) : v.push(S));
      }));
    }))), n.addFonts(v), Object.assign(u, g);
  }
  await l.next(), o.calculateLayout(i, a, r2.DIRECTION_LTR);
  let c = (await l.next([0, 0])).value, p2 = o.getComputedWidth(), d = o.getComputedHeight();
  return o.freeRecursive(), Y1({ width: p2, height: d, content: c });
}
function Rm(e) {
  let t = {}, r2 = {};
  for (let { word: n, locale: i } of e) {
    let a = z1(n, i).join("|");
    r2[a] = r2[a] || "", r2[a] += n;
  }
  return Object.keys(r2).forEach((n) => {
    t[n] = t[n] || [], n === "emoji" ? t[n].push(...Uu(Pt(r2[n], "grapheme"))) : (t[n][0] = t[n][0] || "", t[n][0] += Uu(Pt(r2[n], "grapheme", n === "unknown" ? void 0 : n)).join(""));
  }), t;
}
function Uu(e) {
  return Array.from(new Set(e));
}
var ne = {};
var Um = ne.ALIGN_AUTO = 0;
var Bm = ne.ALIGN_FLEX_START = 1;
var Nm = ne.ALIGN_CENTER = 2;
var Mm = ne.ALIGN_FLEX_END = 3;
var Gm = ne.ALIGN_STRETCH = 4;
var Wm = ne.ALIGN_BASELINE = 5;
var $m = ne.ALIGN_SPACE_BETWEEN = 6;
var jm = ne.ALIGN_SPACE_AROUND = 7;
var zm = ne.DIMENSION_WIDTH = 0;
var Vm = ne.DIMENSION_HEIGHT = 1;
var Hm = ne.DIRECTION_INHERIT = 0;
var Xm = ne.DIRECTION_LTR = 1;
var qm = ne.DIRECTION_RTL = 2;
var Ym = ne.DISPLAY_FLEX = 0;
var Zm = ne.DISPLAY_NONE = 1;
var Jm = ne.EDGE_LEFT = 0;
var Km = ne.EDGE_TOP = 1;
var Qm = ne.EDGE_RIGHT = 2;
var eD = ne.EDGE_BOTTOM = 3;
var tD = ne.EDGE_START = 4;
var rD = ne.EDGE_END = 5;
var nD = ne.EDGE_HORIZONTAL = 6;
var iD = ne.EDGE_VERTICAL = 7;
var aD = ne.EDGE_ALL = 8;
var oD = ne.EXPERIMENTAL_FEATURE_WEB_FLEX_BASIS = 0;
var sD = ne.EXPERIMENTAL_FEATURE_ABSOLUTE_PERCENTAGE_AGAINST_PADDING_EDGE = 1;
var uD = ne.EXPERIMENTAL_FEATURE_FIX_ABSOLUTE_TRAILING_COLUMN_MARGIN = 2;
var lD = ne.FLEX_DIRECTION_COLUMN = 0;
var fD = ne.FLEX_DIRECTION_COLUMN_REVERSE = 1;
var cD = ne.FLEX_DIRECTION_ROW = 2;
var pD = ne.FLEX_DIRECTION_ROW_REVERSE = 3;
var hD = ne.GUTTER_COLUMN = 0;
var dD = ne.GUTTER_ROW = 1;
var vD = ne.GUTTER_ALL = 2;
var gD = ne.JUSTIFY_FLEX_START = 0;
var mD = ne.JUSTIFY_CENTER = 1;
var DD = ne.JUSTIFY_FLEX_END = 2;
var yD = ne.JUSTIFY_SPACE_BETWEEN = 3;
var bD = ne.JUSTIFY_SPACE_AROUND = 4;
var xD = ne.JUSTIFY_SPACE_EVENLY = 5;
var wD = ne.LOG_LEVEL_ERROR = 0;
var ED = ne.LOG_LEVEL_WARN = 1;
var FD = ne.LOG_LEVEL_INFO = 2;
var CD = ne.LOG_LEVEL_DEBUG = 3;
var SD = ne.LOG_LEVEL_VERBOSE = 4;
var kD = ne.LOG_LEVEL_FATAL = 5;
var TD = ne.MEASURE_MODE_UNDEFINED = 0;
var _D = ne.MEASURE_MODE_EXACTLY = 1;
var AD = ne.MEASURE_MODE_AT_MOST = 2;
var OD = ne.NODE_TYPE_DEFAULT = 0;
var LD = ne.NODE_TYPE_TEXT = 1;
var ID = ne.OVERFLOW_VISIBLE = 0;
var PD = ne.OVERFLOW_HIDDEN = 1;
var RD = ne.OVERFLOW_SCROLL = 2;
var UD = ne.POSITION_TYPE_STATIC = 0;
var BD = ne.POSITION_TYPE_RELATIVE = 1;
var ND = ne.POSITION_TYPE_ABSOLUTE = 2;
var MD = ne.PRINT_OPTIONS_LAYOUT = 1;
var GD = ne.PRINT_OPTIONS_STYLE = 2;
var WD = ne.PRINT_OPTIONS_CHILDREN = 4;
var $D = ne.UNIT_UNDEFINED = 0;
var jD = ne.UNIT_POINT = 1;
var zD = ne.UNIT_PERCENT = 2;
var VD = ne.UNIT_AUTO = 3;
var HD = ne.WRAP_NO_WRAP = 0;
var XD = ne.WRAP_WRAP = 1;
var qD = ne.WRAP_WRAP_REVERSE = 2;
var Il = (e) => {
  function t(i, a, o) {
    let u = i[a];
    i[a] = function(...s) {
      return o.call(this, u, ...s);
    };
  }
  for (let i of ["setPosition", "setMargin", "setFlexBasis", "setWidth", "setHeight", "setMinWidth", "setMinHeight", "setMaxWidth", "setMaxHeight", "setPadding"]) {
    let a = { [ne.UNIT_POINT]: e.Node.prototype[i], [ne.UNIT_PERCENT]: e.Node.prototype[`${i}Percent`], [ne.UNIT_AUTO]: e.Node.prototype[`${i}Auto`] };
    t(e.Node.prototype, i, function(o, ...u) {
      let s, l, f = u.pop();
      if (f === "auto")
        s = ne.UNIT_AUTO, l = void 0;
      else if (typeof f == "object")
        s = f.unit, l = f.valueOf();
      else if (s = typeof f == "string" && f.endsWith("%") ? ne.UNIT_PERCENT : ne.UNIT_POINT, l = parseFloat(f), !Number.isNaN(f) && Number.isNaN(l))
        throw Error(`Invalid value ${f} for ${i}`);
      if (!a[s])
        throw Error(`Failed to execute "${i}": Unsupported unit '${f}'`);
      return l !== void 0 ? a[s].call(this, ...u, l) : a[s].call(this, ...u);
    });
  }
  function r2(i) {
    return e.MeasureCallback.implement({ measure: (...a) => {
      let { width: o, height: u } = i(...a);
      return { width: o ?? NaN, height: u ?? NaN };
    } });
  }
  function n(i) {
    return e.DirtiedCallback.implement({ dirtied: i });
  }
  return t(e.Node.prototype, "setMeasureFunc", function(i, a) {
    return a ? i.call(this, r2(a)) : this.unsetMeasureFunc();
  }), t(e.Node.prototype, "setDirtiedFunc", function(i, a) {
    i.call(this, n(a));
  }), t(e.Config.prototype, "free", function() {
    e.Config.destroy(this);
  }), t(e.Node, "create", (i, a) => a ? e.Node.createWithConfig(a) : e.Node.createDefault()), t(e.Node.prototype, "free", function() {
    e.Node.destroy(this);
  }), t(e.Node.prototype, "freeRecursive", function() {
    for (let i = 0, a = this.getChildCount(); i < a; ++i)
      this.getChild(0).freeRecursive();
    this.free();
  }), t(e.Node.prototype, "calculateLayout", function(i, a = NaN, o = NaN, u = ne.DIRECTION_LTR) {
    return i.call(this, a, o, u);
  }), { Config: e.Config, Node: e.Node, ...ne };
};
var YD = (() => {
  var e = typeof document < "u" && document.currentScript ? document.currentScript.src : void 0;
  return function(t = {}) {
    s || (s = t !== void 0 ? t : {}), s.ready = new Promise(function(w, x) {
      l = w, f = x;
    });
    var r2, n, i = Object.assign({}, s), a = "";
    typeof document < "u" && document.currentScript && (a = document.currentScript.src), e && (a = e), a = a.indexOf("blob:") !== 0 ? a.substr(0, a.replace(/[?#].*/, "").lastIndexOf("/") + 1) : "";
    var o = console.log.bind(console), u = console.warn.bind(console);
    Object.assign(s, i), i = null, typeof WebAssembly != "object" && ee("no native wasm support detected");
    var s, l, f, c, p2 = false;
    function d(w, x, I) {
      I = x + I;
      for (var G = ""; !(x >= I); ) {
        var P = w[x++];
        if (!P)
          break;
        if (128 & P) {
          var j = 63 & w[x++];
          if ((224 & P) == 192)
            G += String.fromCharCode((31 & P) << 6 | j);
          else {
            var K = 63 & w[x++];
            65536 > (P = (240 & P) == 224 ? (15 & P) << 12 | j << 6 | K : (7 & P) << 18 | j << 12 | K << 6 | 63 & w[x++]) ? G += String.fromCharCode(P) : (P -= 65536, G += String.fromCharCode(55296 | P >> 10, 56320 | 1023 & P));
          }
        } else
          G += String.fromCharCode(P);
      }
      return G;
    }
    function D() {
      var w = c.buffer;
      s.HEAP8 = v = new Int8Array(w), s.HEAP16 = y = new Int16Array(w), s.HEAP32 = C = new Int32Array(w), s.HEAPU8 = g = new Uint8Array(w), s.HEAPU16 = b = new Uint16Array(w), s.HEAPU32 = k = new Uint32Array(w), s.HEAPF32 = S = new Float32Array(w), s.HEAPF64 = E = new Float64Array(w);
    }
    var v, g, y, b, C, k, S, E, L, T = [], U = [], M = [], H = 0, q = null;
    function ee(w) {
      throw u(w = "Aborted(" + w + ")"), p2 = true, f(w = new WebAssembly.RuntimeError(w + ". Build with -sASSERTIONS for more info.")), w;
    }
    function A() {
      return r2.startsWith("data:application/octet-stream;base64,");
    }
    function R() {
      try {
        throw "both async and sync fetching of the wasm failed";
      } catch (w) {
        ee(w);
      }
    }
    function O(w) {
      for (; 0 < w.length; )
        w.shift()(s);
    }
    function Y(w) {
      if (w === void 0)
        return "_unknown";
      var x = (w = w.replace(/[^a-zA-Z0-9_]/g, "$")).charCodeAt(0);
      return 48 <= x && 57 >= x ? "_" + w : w;
    }
    function Z(w, x) {
      return w = Y(w), function() {
        return x.apply(this, arguments);
      };
    }
    r2 = "yoga.wasm", A() || (r2 = a + r2);
    var te = [{}, { value: void 0 }, { value: null }, { value: true }, { value: false }], ie = [];
    function B(w) {
      var x = Error, I = Z(w, function(G) {
        this.name = w, this.message = G, (G = Error(G).stack) !== void 0 && (this.stack = this.toString() + `
` + G.replace(/^Error(:[^\n]*)?\n/, ""));
      });
      return I.prototype = Object.create(x.prototype), I.prototype.constructor = I, I.prototype.toString = function() {
        return this.message === void 0 ? this.name : this.name + ": " + this.message;
      }, I;
    }
    var z = void 0;
    function _(w) {
      throw new z(w);
    }
    var N = (w) => (w || _("Cannot use deleted val. handle = " + w), te[w].value), ae = (w) => {
      switch (w) {
        case void 0:
          return 1;
        case null:
          return 2;
        case true:
          return 3;
        case false:
          return 4;
        default:
          var x = ie.length ? ie.pop() : te.length;
          return te[x] = { fa: 1, value: w }, x;
      }
    }, W = void 0, fe = void 0;
    function ce(w) {
      for (var x = ""; g[w]; )
        x += fe[g[w++]];
      return x;
    }
    var ge = [];
    function pe() {
      for (; ge.length; ) {
        var w = ge.pop();
        w.L.Z = false, w.delete();
      }
    }
    var xe = void 0, _e = {};
    function he(w, x) {
      for (x === void 0 && _("ptr should not be undefined"); w.P; )
        x = w.aa(x), w = w.P;
      return x;
    }
    var ye = {};
    function Ge(w) {
      var x = ce(w = qa(w));
      return Ht(w), x;
    }
    function tt(w, x) {
      var I = ye[w];
      return I === void 0 && _(x + " has unknown type " + Ge(w)), I;
    }
    function We() {
    }
    var Be = false;
    function He(w) {
      --w.count.value, w.count.value === 0 && (w.S ? w.T.V(w.S) : w.O.M.V(w.N));
    }
    var rt = {}, nt = void 0;
    function it(w) {
      throw new nt(w);
    }
    function at(w, x) {
      return x.O && x.N || it("makeClassHandle requires ptr and ptrType"), !!x.T != !!x.S && it("Both smartPtrType and smartPtr must be specified"), x.count = { value: 1 }, Xe(Object.create(w, { L: { value: x } }));
    }
    function Xe(w) {
      return typeof FinalizationRegistry > "u" ? (Xe = (x) => x, w) : (Be = new FinalizationRegistry((x) => {
        He(x.L);
      }), Xe = (x) => {
        var I = x.L;
        return I.S && Be.register(x, { L: I }, x), x;
      }, We = (x) => {
        Be.unregister(x);
      }, Xe(w));
    }
    var Ct = {};
    function Dt(w) {
      for (; w.length; ) {
        var x = w.pop();
        w.pop()(x);
      }
    }
    function ft(w) {
      return this.fromWireType(C[w >> 2]);
    }
    var ct = {}, zt = {};
    function lt(w, x, I) {
      function G(X) {
        (X = I(X)).length !== w.length && it("Mismatched type converter count");
        for (var Q = 0; Q < w.length; ++Q)
          qe(w[Q], X[Q]);
      }
      w.forEach(function(X) {
        zt[X] = x;
      });
      var P = Array(x.length), j = [], K = 0;
      x.forEach((X, Q) => {
        ye.hasOwnProperty(X) ? P[Q] = ye[X] : (j.push(X), ct.hasOwnProperty(X) || (ct[X] = []), ct[X].push(() => {
          P[Q] = ye[X], ++K === j.length && G(P);
        }));
      }), j.length === 0 && G(P);
    }
    function Ut(w) {
      switch (w) {
        case 1:
          return 0;
        case 2:
          return 1;
        case 4:
          return 2;
        case 8:
          return 3;
        default:
          throw TypeError("Unknown type size: " + w);
      }
    }
    function qe(w, x, I = {}) {
      if (!("argPackAdvance" in x))
        throw TypeError("registerType registeredInstance requires argPackAdvance");
      var G = x.name;
      if (w || _('type "' + G + '" must have a positive integer typeid pointer'), ye.hasOwnProperty(w)) {
        if (I.ta)
          return;
        _("Cannot register type '" + G + "' twice");
      }
      ye[w] = x, delete zt[w], ct.hasOwnProperty(w) && (x = ct[w], delete ct[w], x.forEach((P) => P()));
    }
    function xr(w) {
      _(w.L.O.M.name + " instance already deleted");
    }
    function ve() {
    }
    function Le(w, x, I) {
      if (w[x].R === void 0) {
        var G = w[x];
        w[x] = function() {
          return w[x].R.hasOwnProperty(arguments.length) || _("Function '" + I + "' called with an invalid number of arguments (" + arguments.length + ") - expects one of (" + w[x].R + ")!"), w[x].R[arguments.length].apply(this, arguments);
        }, w[x].R = [], w[x].R[G.Y] = G;
      }
    }
    function Ue(w, x, I, G, P, j, K, X) {
      this.name = w, this.constructor = x, this.W = I, this.V = G, this.P = P, this.oa = j, this.aa = K, this.ma = X, this.ia = [];
    }
    function we(w, x, I) {
      for (; x !== I; )
        x.aa || _("Expected null or instance of " + I.name + ", got an instance of " + x.name), w = x.aa(w), x = x.P;
      return w;
    }
    function Ne(w, x) {
      return x === null ? (this.da && _("null is not a valid " + this.name), 0) : (x.L || _('Cannot pass "' + Pe(x) + '" as a ' + this.name), x.L.N || _("Cannot pass deleted object as a pointer of type " + this.name), we(x.L.N, x.L.O.M, this.M));
    }
    function Ae(w, x) {
      if (x === null) {
        if (this.da && _("null is not a valid " + this.name), this.ca) {
          var I = this.ea();
          return w !== null && w.push(this.V, I), I;
        }
        return 0;
      }
      if (x.L || _('Cannot pass "' + Pe(x) + '" as a ' + this.name), x.L.N || _("Cannot pass deleted object as a pointer of type " + this.name), !this.ba && x.L.O.ba && _("Cannot convert argument of type " + (x.L.T ? x.L.T.name : x.L.O.name) + " to parameter type " + this.name), I = we(x.L.N, x.L.O.M, this.M), this.ca)
        switch (x.L.S === void 0 && _("Passing raw pointer to smart pointer is illegal"), this.Aa) {
          case 0:
            x.L.T === this ? I = x.L.S : _("Cannot convert argument of type " + (x.L.T ? x.L.T.name : x.L.O.name) + " to parameter type " + this.name);
            break;
          case 1:
            I = x.L.S;
            break;
          case 2:
            if (x.L.T === this)
              I = x.L.S;
            else {
              var G = x.clone();
              I = this.wa(I, ae(function() {
                G.delete();
              })), w !== null && w.push(this.V, I);
            }
            break;
          default:
            _("Unsupporting sharing policy");
        }
      return I;
    }
    function $e(w, x) {
      return x === null ? (this.da && _("null is not a valid " + this.name), 0) : (x.L || _('Cannot pass "' + Pe(x) + '" as a ' + this.name), x.L.N || _("Cannot pass deleted object as a pointer of type " + this.name), x.L.O.ba && _("Cannot convert argument of type " + x.L.O.name + " to parameter type " + this.name), we(x.L.N, x.L.O.M, this.M));
    }
    function Fe(w, x, I, G) {
      this.name = w, this.M = x, this.da = I, this.ba = G, this.ca = false, this.V = this.wa = this.ea = this.ja = this.Aa = this.va = void 0, x.P !== void 0 ? this.toWireType = Ae : (this.toWireType = G ? Ne : $e, this.U = null);
    }
    var Ce = [];
    function pt(w) {
      var x = Ce[w];
      return x || (w >= Ce.length && (Ce.length = w + 1), Ce[w] = x = L.get(w)), x;
    }
    function me(w, x) {
      var I, G, P = (w = ce(w)).includes("j") ? (I = w, G = [], function() {
        if (G.length = 0, Object.assign(G, arguments), I.includes("j")) {
          var j = s["dynCall_" + I];
          j = G && G.length ? j.apply(null, [x].concat(G)) : j.call(null, x);
        } else
          j = pt(x).apply(null, G);
        return j;
      }) : pt(x);
      return typeof P != "function" && _("unknown function pointer with signature " + w + ": " + x), P;
    }
    var Bt = void 0;
    function Ke(w, x) {
      var I = [], G = {};
      throw x.forEach(function P(j) {
        G[j] || ye[j] || (zt[j] ? zt[j].forEach(P) : (I.push(j), G[j] = true));
      }), new Bt(w + ": " + I.map(Ge).join([", "]));
    }
    function yt(w, x, I, G, P) {
      var j = x.length;
      2 > j && _("argTypes array size mismatch! Must at least get return value and 'this' types!");
      var K = x[1] !== null && I !== null, X = false;
      for (I = 1; I < x.length; ++I)
        if (x[I] !== null && x[I].U === void 0) {
          X = true;
          break;
        }
      var Q = x[0].name !== "void", J = j - 2, re = Array(J), De = [], be = [];
      return function() {
        if (arguments.length !== J && _("function " + w + " called with " + arguments.length + " arguments, expected " + J + " args!"), be.length = 0, De.length = K ? 2 : 1, De[0] = P, K) {
          var Oe = x[1].toWireType(be, this);
          De[1] = Oe;
        }
        for (var Se = 0; Se < J; ++Se)
          re[Se] = x[Se + 2].toWireType(be, arguments[Se]), De.push(re[Se]);
        if (Se = G.apply(null, De), X)
          Dt(be);
        else
          for (var ze = K ? 1 : 2; ze < x.length; ze++) {
            var Er = ze === 1 ? Oe : re[ze - 2];
            x[ze].U !== null && x[ze].U(Er);
          }
        return Q ? x[0].fromWireType(Se) : void 0;
      };
    }
    function rr(w, x) {
      for (var I = [], G = 0; G < w; G++)
        I.push(k[x + 4 * G >> 2]);
      return I;
    }
    function bt(w) {
      4 < w && --te[w].fa == 0 && (te[w] = void 0, ie.push(w));
    }
    function Pe(w) {
      if (w === null)
        return "null";
      var x = typeof w;
      return x === "object" || x === "array" || x === "function" ? w.toString() : "" + w;
    }
    function Ye(w, x) {
      for (var I = "", G = 0; !(G >= x / 2); ++G) {
        var P = y[w + 2 * G >> 1];
        if (P == 0)
          break;
        I += String.fromCharCode(P);
      }
      return I;
    }
    function ht(w, x, I) {
      if (I === void 0 && (I = 2147483647), 2 > I)
        return 0;
      I -= 2;
      var G = x;
      I = I < 2 * w.length ? I / 2 : w.length;
      for (var P = 0; P < I; ++P)
        y[x >> 1] = w.charCodeAt(P), x += 2;
      return y[x >> 1] = 0, x - G;
    }
    function wr(w) {
      return 2 * w.length;
    }
    function hr(w, x) {
      for (var I = 0, G = ""; !(I >= x / 4); ) {
        var P = C[w + 4 * I >> 2];
        if (P == 0)
          break;
        ++I, 65536 <= P ? (P -= 65536, G += String.fromCharCode(55296 | P >> 10, 56320 | 1023 & P)) : G += String.fromCharCode(P);
      }
      return G;
    }
    function Qe(w, x, I) {
      if (I === void 0 && (I = 2147483647), 4 > I)
        return 0;
      var G = x;
      I = G + I - 4;
      for (var P = 0; P < w.length; ++P) {
        var j = w.charCodeAt(P);
        if (55296 <= j && 57343 >= j && (j = 65536 + ((1023 & j) << 10) | 1023 & w.charCodeAt(++P)), C[x >> 2] = j, (x += 4) + 4 > I)
          break;
      }
      return C[x >> 2] = 0, x - G;
    }
    function dt(w) {
      for (var x = 0, I = 0; I < w.length; ++I) {
        var G = w.charCodeAt(I);
        55296 <= G && 57343 >= G && ++I, x += 4;
      }
      return x;
    }
    var Vt = {};
    function xt(w) {
      var x = Vt[w];
      return x === void 0 ? ce(w) : x;
    }
    var Nt = [], Or = [], pn = [null, [], []];
    z = s.BindingError = B("BindingError"), s.count_emval_handles = function() {
      for (var w = 0, x = 5; x < te.length; ++x)
        te[x] !== void 0 && ++w;
      return w;
    }, s.get_first_emval = function() {
      for (var w = 5; w < te.length; ++w)
        if (te[w] !== void 0)
          return te[w];
      return null;
    }, W = s.PureVirtualError = B("PureVirtualError");
    for (var Xa = Array(256), hn = 0; 256 > hn; ++hn)
      Xa[hn] = String.fromCharCode(hn);
    fe = Xa, s.getInheritedInstanceCount = function() {
      return Object.keys(_e).length;
    }, s.getLiveInheritedInstances = function() {
      var w, x = [];
      for (w in _e)
        _e.hasOwnProperty(w) && x.push(_e[w]);
      return x;
    }, s.flushPendingDeletes = pe, s.setDelayFunction = function(w) {
      xe = w, ge.length && xe && xe(pe);
    }, nt = s.InternalError = B("InternalError"), ve.prototype.isAliasOf = function(w) {
      if (!(this instanceof ve && w instanceof ve))
        return false;
      var x = this.L.O.M, I = this.L.N, G = w.L.O.M;
      for (w = w.L.N; x.P; )
        I = x.aa(I), x = x.P;
      for (; G.P; )
        w = G.aa(w), G = G.P;
      return x === G && I === w;
    }, ve.prototype.clone = function() {
      if (this.L.N || xr(this), this.L.$)
        return this.L.count.value += 1, this;
      var w = Xe, x = Object, I = x.create, G = Object.getPrototypeOf(this), P = this.L;
      return w = w(I.call(x, G, { L: { value: { count: P.count, Z: P.Z, $: P.$, N: P.N, O: P.O, S: P.S, T: P.T } } })), w.L.count.value += 1, w.L.Z = false, w;
    }, ve.prototype.delete = function() {
      this.L.N || xr(this), this.L.Z && !this.L.$ && _("Object already scheduled for deletion"), We(this), He(this.L), this.L.$ || (this.L.S = void 0, this.L.N = void 0);
    }, ve.prototype.isDeleted = function() {
      return !this.L.N;
    }, ve.prototype.deleteLater = function() {
      return this.L.N || xr(this), this.L.Z && !this.L.$ && _("Object already scheduled for deletion"), ge.push(this), ge.length === 1 && xe && xe(pe), this.L.Z = true, this;
    }, Fe.prototype.pa = function(w) {
      return this.ja && (w = this.ja(w)), w;
    }, Fe.prototype.ga = function(w) {
      this.V && this.V(w);
    }, Fe.prototype.argPackAdvance = 8, Fe.prototype.readValueFromPointer = ft, Fe.prototype.deleteObject = function(w) {
      w !== null && w.delete();
    }, Fe.prototype.fromWireType = function(w) {
      function x() {
        return this.ca ? at(this.M.W, { O: this.va, N: G, T: this, S: w }) : at(this.M.W, { O: this, N: w });
      }
      var I, G = this.pa(w);
      if (!G)
        return this.ga(w), null;
      var P = _e[he(this.M, G)];
      if (P !== void 0)
        return P.L.count.value === 0 ? (P.L.N = G, P.L.S = w, P.clone()) : (P = P.clone(), this.ga(w), P);
      if (!(P = rt[P = this.M.oa(G)]))
        return x.call(this);
      P = this.ba ? P.ka : P.pointerType;
      var j = function K(X, Q, J) {
        return Q === J ? X : J.P === void 0 || (X = K(X, Q, J.P)) === null ? null : J.ma(X);
      }(G, this.M, P.M);
      return j === null ? x.call(this) : this.ca ? at(P.M.W, { O: P, N: j, T: this, S: w }) : at(P.M.W, { O: P, N: j });
    }, Bt = s.UnboundTypeError = B("UnboundTypeError");
    var Hl = { q: function(w, x, I) {
      w = ce(w), x = tt(x, "wrapper"), I = N(I);
      var G = [].slice, P = x.M, j = P.W, K = P.P.W, X = P.P.constructor;
      for (var Q in w = Z(w, function() {
        P.P.ia.forEach(function(J) {
          if (this[J] === K[J])
            throw new W("Pure virtual function " + J + " must be implemented in JavaScript");
        }.bind(this)), Object.defineProperty(this, "__parent", { value: j }), this.__construct.apply(this, G.call(arguments));
      }), j.__construct = function() {
        this === j && _("Pass correct 'this' to __construct");
        var J = X.implement.apply(void 0, [this].concat(G.call(arguments)));
        We(J);
        var re = J.L;
        J.notifyOnDestruction(), re.$ = true, Object.defineProperties(this, { L: { value: re } }), Xe(this), J = he(P, J = re.N), _e.hasOwnProperty(J) ? _("Tried to register registered instance: " + J) : _e[J] = this;
      }, j.__destruct = function() {
        this === j && _("Pass correct 'this' to __destruct"), We(this);
        var J = this.L.N;
        J = he(P, J), _e.hasOwnProperty(J) ? delete _e[J] : _("Tried to unregister unregistered instance: " + J);
      }, w.prototype = Object.create(j), I)
        w.prototype[Q] = I[Q];
      return ae(w);
    }, l: function(w) {
      var x = Ct[w];
      delete Ct[w];
      var I = x.ea, G = x.V, P = x.ha;
      lt([w], P.map((j) => j.sa).concat(P.map((j) => j.ya)), (j) => {
        var K = {};
        return P.forEach((X, Q) => {
          var J = j[Q], re = X.qa, De = X.ra, be = j[Q + P.length], Oe = X.xa, Se = X.za;
          K[X.na] = { read: (ze) => J.fromWireType(re(De, ze)), write: (ze, Er) => {
            var dr = [];
            Oe(Se, ze, be.toWireType(dr, Er)), Dt(dr);
          } };
        }), [{ name: x.name, fromWireType: function(X) {
          var Q, J = {};
          for (Q in K)
            J[Q] = K[Q].read(X);
          return G(X), J;
        }, toWireType: function(X, Q) {
          for (var J in K)
            if (!(J in Q))
              throw TypeError('Missing field:  "' + J + '"');
          var re = I();
          for (J in K)
            K[J].write(re, Q[J]);
          return X !== null && X.push(G, re), re;
        }, argPackAdvance: 8, readValueFromPointer: ft, U: G }];
      });
    }, v: function() {
    }, B: function(w, x, I, G, P) {
      var j = Ut(I);
      qe(w, { name: x = ce(x), fromWireType: function(K) {
        return !!K;
      }, toWireType: function(K, X) {
        return X ? G : P;
      }, argPackAdvance: 8, readValueFromPointer: function(K) {
        if (I === 1)
          var X = v;
        else if (I === 2)
          X = y;
        else if (I === 4)
          X = C;
        else
          throw TypeError("Unknown boolean type size: " + x);
        return this.fromWireType(X[K >> j]);
      }, U: null });
    }, h: function(w, x, I, G, P, j, K, X, Q, J, re, De, be) {
      re = ce(re), j = me(P, j), X && (X = me(K, X)), J && (J = me(Q, J)), be = me(De, be);
      var Oe, Se = Y(re);
      Oe = function() {
        Ke("Cannot construct " + re + " due to unbound types", [G]);
      }, s.hasOwnProperty(Se) ? (_("Cannot register public name '" + Se + "' twice"), Le(s, Se, Se), s.hasOwnProperty(void 0) && _("Cannot register multiple overloads of a function with the same number of arguments (undefined)!"), s[Se].R[void 0] = Oe) : s[Se] = Oe, lt([w, x, I], G ? [G] : [], function(ze) {
        if (ze = ze[0], G)
          var Er, dr = ze.M, Lr = dr.W;
        else
          Lr = ve.prototype;
        ze = Z(Se, function() {
          if (Object.getPrototypeOf(this) !== ci)
            throw new z("Use 'new' to construct " + re);
          if (Fr.X === void 0)
            throw new z(re + " has no accessible constructor");
          var Ja = Fr.X[arguments.length];
          if (Ja === void 0)
            throw new z("Tried to invoke ctor of " + re + " with invalid number of parameters (" + arguments.length + ") - expected (" + Object.keys(Fr.X).toString() + ") parameters instead!");
          return Ja.apply(this, arguments);
        });
        var ci = Object.create(Lr, { constructor: { value: ze } });
        ze.prototype = ci;
        var Fr = new Ue(re, ze, ci, be, dr, j, X, J);
        dr = new Fe(re, Fr, true, false), Lr = new Fe(re + "*", Fr, false, false);
        var Za = new Fe(re + " const*", Fr, false, true);
        return rt[w] = { pointerType: Lr, ka: Za }, Er = ze, s.hasOwnProperty(Se) || it("Replacing nonexistant public symbol"), s[Se] = Er, s[Se].Y = void 0, [dr, Lr, Za];
      });
    }, d: function(w, x, I, G, P, j, K) {
      var X = rr(I, G);
      x = ce(x), j = me(P, j), lt([], [w], function(Q) {
        function J() {
          Ke("Cannot call " + re + " due to unbound types", X);
        }
        var re = (Q = Q[0]).name + "." + x;
        x.startsWith("@@") && (x = Symbol[x.substring(2)]);
        var De = Q.M.constructor;
        return De[x] === void 0 ? (J.Y = I - 1, De[x] = J) : (Le(De, x, re), De[x].R[I - 1] = J), lt([], X, function(be) {
          return be = yt(re, [be[0], null].concat(be.slice(1)), null, j, K), De[x].R === void 0 ? (be.Y = I - 1, De[x] = be) : De[x].R[I - 1] = be, [];
        }), [];
      });
    }, p: function(w, x, I, G, P, j) {
      0 < x || ee();
      var K = rr(x, I);
      P = me(G, P), lt([], [w], function(X) {
        var Q = "constructor " + (X = X[0]).name;
        if (X.M.X === void 0 && (X.M.X = []), X.M.X[x - 1] !== void 0)
          throw new z("Cannot register multiple constructors with identical number of parameters (" + (x - 1) + ") for class '" + X.name + "'! Overload resolution is currently only performed using the parameter count, not actual type info!");
        return X.M.X[x - 1] = () => {
          Ke("Cannot construct " + X.name + " due to unbound types", K);
        }, lt([], K, function(J) {
          return J.splice(1, 0, null), X.M.X[x - 1] = yt(Q, J, null, P, j), [];
        }), [];
      });
    }, a: function(w, x, I, G, P, j, K, X) {
      var Q = rr(I, G);
      x = ce(x), j = me(P, j), lt([], [w], function(J) {
        function re() {
          Ke("Cannot call " + De + " due to unbound types", Q);
        }
        var De = (J = J[0]).name + "." + x;
        x.startsWith("@@") && (x = Symbol[x.substring(2)]), X && J.M.ia.push(x);
        var be = J.M.W, Oe = be[x];
        return Oe === void 0 || Oe.R === void 0 && Oe.className !== J.name && Oe.Y === I - 2 ? (re.Y = I - 2, re.className = J.name, be[x] = re) : (Le(be, x, De), be[x].R[I - 2] = re), lt([], Q, function(Se) {
          return Se = yt(De, Se, J, j, K), be[x].R === void 0 ? (Se.Y = I - 2, be[x] = Se) : be[x].R[I - 2] = Se, [];
        }), [];
      });
    }, A: function(w, x) {
      qe(w, { name: x = ce(x), fromWireType: function(I) {
        var G = N(I);
        return bt(I), G;
      }, toWireType: function(I, G) {
        return ae(G);
      }, argPackAdvance: 8, readValueFromPointer: ft, U: null });
    }, n: function(w, x, I) {
      I = Ut(I), qe(w, { name: x = ce(x), fromWireType: function(G) {
        return G;
      }, toWireType: function(G, P) {
        return P;
      }, argPackAdvance: 8, readValueFromPointer: function(G, P) {
        switch (P) {
          case 2:
            return function(j) {
              return this.fromWireType(S[j >> 2]);
            };
          case 3:
            return function(j) {
              return this.fromWireType(E[j >> 3]);
            };
          default:
            throw TypeError("Unknown float type: " + G);
        }
      }(x, I), U: null });
    }, e: function(w, x, I, G, P) {
      x = ce(x), P === -1 && (P = 4294967295), P = Ut(I);
      var j = (X) => X;
      if (G === 0) {
        var K = 32 - 8 * I;
        j = (X) => X << K >>> K;
      }
      I = x.includes("unsigned") ? function(X, Q) {
        return Q >>> 0;
      } : function(X, Q) {
        return Q;
      }, qe(w, { name: x, fromWireType: j, toWireType: I, argPackAdvance: 8, readValueFromPointer: function(X, Q, J) {
        switch (Q) {
          case 0:
            return J ? function(re) {
              return v[re];
            } : function(re) {
              return g[re];
            };
          case 1:
            return J ? function(re) {
              return y[re >> 1];
            } : function(re) {
              return b[re >> 1];
            };
          case 2:
            return J ? function(re) {
              return C[re >> 2];
            } : function(re) {
              return k[re >> 2];
            };
          default:
            throw TypeError("Unknown integer type: " + X);
        }
      }(x, P, G !== 0), U: null });
    }, b: function(w, x, I) {
      function G(j) {
        j >>= 2;
        var K = k;
        return new P(K.buffer, K[j + 1], K[j]);
      }
      var P = [Int8Array, Uint8Array, Int16Array, Uint16Array, Int32Array, Uint32Array, Float32Array, Float64Array][x];
      qe(w, { name: I = ce(I), fromWireType: G, argPackAdvance: 8, readValueFromPointer: G }, { ta: true });
    }, o: function(w, x) {
      var I = (x = ce(x)) === "std::string";
      qe(w, { name: x, fromWireType: function(G) {
        var P = k[G >> 2], j = G + 4;
        if (I)
          for (var K = j, X = 0; X <= P; ++X) {
            var Q = j + X;
            if (X == P || g[Q] == 0) {
              if (K = K ? d(g, K, Q - K) : "", J === void 0)
                var J = K;
              else
                J += "\0" + K;
              K = Q + 1;
            }
          }
        else {
          for (X = 0, J = Array(P); X < P; ++X)
            J[X] = String.fromCharCode(g[j + X]);
          J = J.join("");
        }
        return Ht(G), J;
      }, toWireType: function(G, P) {
        P instanceof ArrayBuffer && (P = new Uint8Array(P));
        var j, K = typeof P == "string";
        if (K || P instanceof Uint8Array || P instanceof Uint8ClampedArray || P instanceof Int8Array || _("Cannot pass non-string to std::string"), I && K) {
          var X = 0;
          for (j = 0; j < P.length; ++j) {
            var Q = P.charCodeAt(j);
            127 >= Q ? X++ : 2047 >= Q ? X += 2 : 55296 <= Q && 57343 >= Q ? (X += 4, ++j) : X += 3;
          }
          j = X;
        } else
          j = P.length;
        if (Q = (X = fi(4 + j + 1)) + 4, k[X >> 2] = j, I && K) {
          if (K = Q, Q = j + 1, j = g, 0 < Q) {
            Q = K + Q - 1;
            for (var J = 0; J < P.length; ++J) {
              var re = P.charCodeAt(J);
              if (55296 <= re && 57343 >= re && (re = 65536 + ((1023 & re) << 10) | 1023 & P.charCodeAt(++J)), 127 >= re) {
                if (K >= Q)
                  break;
                j[K++] = re;
              } else {
                if (2047 >= re) {
                  if (K + 1 >= Q)
                    break;
                  j[K++] = 192 | re >> 6;
                } else {
                  if (65535 >= re) {
                    if (K + 2 >= Q)
                      break;
                    j[K++] = 224 | re >> 12;
                  } else {
                    if (K + 3 >= Q)
                      break;
                    j[K++] = 240 | re >> 18, j[K++] = 128 | re >> 12 & 63;
                  }
                  j[K++] = 128 | re >> 6 & 63;
                }
                j[K++] = 128 | 63 & re;
              }
            }
            j[K] = 0;
          }
        } else if (K)
          for (K = 0; K < j; ++K)
            255 < (J = P.charCodeAt(K)) && (Ht(Q), _("String has UTF-16 code units that do not fit in 8 bits")), g[Q + K] = J;
        else
          for (K = 0; K < j; ++K)
            g[Q + K] = P[K];
        return G !== null && G.push(Ht, X), X;
      }, argPackAdvance: 8, readValueFromPointer: ft, U: function(G) {
        Ht(G);
      } });
    }, k: function(w, x, I) {
      if (I = ce(I), x === 2)
        var G = Ye, P = ht, j = wr, K = () => b, X = 1;
      else
        x === 4 && (G = hr, P = Qe, j = dt, K = () => k, X = 2);
      qe(w, { name: I, fromWireType: function(Q) {
        for (var J, re = k[Q >> 2], De = K(), be = Q + 4, Oe = 0; Oe <= re; ++Oe) {
          var Se = Q + 4 + Oe * x;
          (Oe == re || De[Se >> X] == 0) && (be = G(be, Se - be), J === void 0 ? J = be : J += "\0" + be, be = Se + x);
        }
        return Ht(Q), J;
      }, toWireType: function(Q, J) {
        typeof J != "string" && _("Cannot pass non-string to C++ string type " + I);
        var re = j(J), De = fi(4 + re + x);
        return k[De >> 2] = re >> X, P(J, De + 4, re + x), Q !== null && Q.push(Ht, De), De;
      }, argPackAdvance: 8, readValueFromPointer: ft, U: function(Q) {
        Ht(Q);
      } });
    }, m: function(w, x, I, G, P, j) {
      Ct[w] = { name: ce(x), ea: me(I, G), V: me(P, j), ha: [] };
    }, c: function(w, x, I, G, P, j, K, X, Q, J) {
      Ct[w].ha.push({ na: ce(x), sa: I, qa: me(G, P), ra: j, ya: K, xa: me(X, Q), za: J });
    }, C: function(w, x) {
      qe(w, { ua: true, name: x = ce(x), argPackAdvance: 0, fromWireType: function() {
      }, toWireType: function() {
      } });
    }, t: function(w, x, I, G, P) {
      w = Nt[w], x = N(x), I = xt(I);
      var j = [];
      return k[G >> 2] = ae(j), w(x, I, j, P);
    }, j: function(w, x, I, G) {
      w = Nt[w], w(x = N(x), I = xt(I), null, G);
    }, f: bt, g: function(w, x) {
      var I, G, P = function(Q, J) {
        for (var re = Array(Q), De = 0; De < Q; ++De)
          re[De] = tt(k[J + 4 * De >> 2], "parameter " + De);
        return re;
      }(w, x), j = P[0], K = Or[x = j.name + "_$" + P.slice(1).map(function(Q) {
        return Q.name;
      }).join("_") + "$"];
      if (K !== void 0)
        return K;
      var X = Array(w - 1);
      return I = (Q, J, re, De) => {
        for (var be = 0, Oe = 0; Oe < w - 1; ++Oe)
          X[Oe] = P[Oe + 1].readValueFromPointer(De + be), be += P[Oe + 1].argPackAdvance;
        for (Oe = 0, Q = Q[J].apply(Q, X); Oe < w - 1; ++Oe)
          P[Oe + 1].la && P[Oe + 1].la(X[Oe]);
        if (!j.ua)
          return j.toWireType(re, Q);
      }, G = Nt.length, Nt.push(I), K = G, Or[x] = K;
    }, r: function(w) {
      4 < w && (te[w].fa += 1);
    }, s: function(w) {
      Dt(N(w)), bt(w);
    }, i: function() {
      ee("");
    }, x: function(w, x, I) {
      g.copyWithin(w, x, x + I);
    }, w: function(w) {
      var x = g.length;
      if (2147483648 < (w >>>= 0))
        return false;
      for (var I = 1; 4 >= I; I *= 2) {
        var G = x * (1 + 0.2 / I);
        G = Math.min(G, w + 100663296);
        var P = Math, j = P.min;
        G = Math.max(w, G), G += (65536 - G % 65536) % 65536;
        e: {
          var K = c.buffer;
          try {
            c.grow(j.call(P, 2147483648, G) - K.byteLength + 65535 >>> 16), D();
            var X = 1;
            break e;
          } catch {
          }
          X = void 0;
        }
        if (X)
          return true;
      }
      return false;
    }, z: function() {
      return 52;
    }, u: function() {
      return 70;
    }, y: function(w, x, I, G) {
      for (var P = 0, j = 0; j < I; j++) {
        var K = k[x >> 2], X = k[x + 4 >> 2];
        x += 8;
        for (var Q = 0; Q < X; Q++) {
          var J = g[K + Q], re = pn[w];
          J === 0 || J === 10 ? ((w === 1 ? o : u)(d(re, 0)), re.length = 0) : re.push(J);
        }
        P += X;
      }
      return k[G >> 2] = P, 0;
    } };
    (function() {
      function w(P) {
        s.asm = P.exports, c = s.asm.D, D(), L = s.asm.I, U.unshift(s.asm.E), --H == 0 && q && (P = q, q = null, P());
      }
      function x(P) {
        w(P.instance);
      }
      function I(P) {
        return (typeof fetch == "function" ? fetch(r2, { credentials: "same-origin" }).then(function(j) {
          if (!j.ok)
            throw "failed to load wasm binary file at '" + r2 + "'";
          return j.arrayBuffer();
        }).catch(function() {
          return R();
        }) : Promise.resolve().then(function() {
          return R();
        })).then(function(j) {
          return WebAssembly.instantiate(j, G);
        }).then(function(j) {
          return j;
        }).then(P, function(j) {
          u("failed to asynchronously prepare wasm: " + j), ee(j);
        });
      }
      var G = { a: Hl };
      if (H++, s.instantiateWasm)
        try {
          return s.instantiateWasm(G, w);
        } catch (P) {
          u("Module.instantiateWasm callback failed with error: " + P), f(P);
        }
      (typeof WebAssembly.instantiateStreaming != "function" || A() || typeof fetch != "function" ? I(x) : fetch(r2, { credentials: "same-origin" }).then(function(P) {
        return WebAssembly.instantiateStreaming(P, G).then(x, function(j) {
          return u("wasm streaming compile failed: " + j), u("falling back to ArrayBuffer instantiation"), I(x);
        });
      })).catch(f);
    })();
    var qa = s.___getTypeName = function() {
      return (qa = s.___getTypeName = s.asm.F).apply(null, arguments);
    };
    function fi() {
      return (fi = s.asm.H).apply(null, arguments);
    }
    function Ht() {
      return (Ht = s.asm.J).apply(null, arguments);
    }
    function Ya() {
      0 < H || (O(T), 0 < H || n || (n = true, s.calledRun = true, p2 || (O(U), l(s), O(M))));
    }
    return s.__embind_initialize_bindings = function() {
      return (s.__embind_initialize_bindings = s.asm.G).apply(null, arguments);
    }, s.dynCall_jiji = function() {
      return (s.dynCall_jiji = s.asm.K).apply(null, arguments);
    }, q = function w() {
      n || Ya(), n || (q = w);
    }, Ya(), t.ready;
  };
})();
async function Pl(e) {
  let t = await YD({ instantiateWasm(r2, n) {
    WebAssembly.instantiate(e, r2).then((i) => {
      i instanceof WebAssembly.Instance ? n(i) : n(i.instance);
    });
  } });
  return Il(t);
}
var de;
var er = new Array(128).fill(void 0);
er.push(void 0, null, true, false);
var ln = er.length;
function Qt(e) {
  ln === er.length && er.push(er.length + 1);
  let t = ln;
  return ln = er[t], er[t] = e, t;
}
function Rt(e) {
  return er[e];
}
function ZD(e) {
  e < 132 || (er[e] = ln, ln = e);
}
function tr(e) {
  let t = Rt(e);
  return ZD(e), t;
}
var fn = 0;
var sn = null;
function ai() {
  return (sn === null || sn.byteLength === 0) && (sn = new Uint8Array(de.memory.buffer)), sn;
}
var oi = new TextEncoder("utf-8");
var JD = typeof oi.encodeInto == "function" ? function(e, t) {
  return oi.encodeInto(e, t);
} : function(e, t) {
  let r2 = oi.encode(e);
  return t.set(r2), { read: e.length, written: r2.length };
};
function ja(e, t, r2) {
  if (r2 === void 0) {
    let u = oi.encode(e), s = t(u.length);
    return ai().subarray(s, s + u.length).set(u), fn = u.length, s;
  }
  let n = e.length, i = t(n), a = ai(), o = 0;
  for (; o < n; o++) {
    let u = e.charCodeAt(o);
    if (u > 127)
      break;
    a[i + o] = u;
  }
  if (o !== n) {
    o !== 0 && (e = e.slice(o)), i = r2(i, n, n = o + e.length * 3);
    let u = ai().subarray(i + o, i + n), s = JD(e, u);
    o += s.written;
  }
  return fn = o, i;
}
function Rl(e) {
  return e == null;
}
var un = null;
function Je() {
  return (un === null || un.byteLength === 0) && (un = new Int32Array(de.memory.buffer)), un;
}
var Ul = new TextDecoder("utf-8", { ignoreBOM: true, fatal: true });
Ul.decode();
function si(e, t) {
  return Ul.decode(ai().subarray(e, e + t));
}
function KD(e, t) {
  if (!(e instanceof t))
    throw new Error(`expected instance of ${t.name}`);
  return e.ptr;
}
var ui = class {
  static __wrap(e) {
    let t = Object.create(ui.prototype);
    return t.ptr = e, t;
  }
  __destroy_into_raw() {
    let e = this.ptr;
    return this.ptr = 0, e;
  }
  free() {
    let e = this.__destroy_into_raw();
    de.__wbg_bbox_free(e);
  }
  get x() {
    return de.__wbg_get_bbox_x(this.ptr);
  }
  set x(e) {
    de.__wbg_set_bbox_x(this.ptr, e);
  }
  get y() {
    return de.__wbg_get_bbox_y(this.ptr);
  }
  set y(e) {
    de.__wbg_set_bbox_y(this.ptr, e);
  }
  get width() {
    return de.__wbg_get_bbox_width(this.ptr);
  }
  set width(e) {
    de.__wbg_set_bbox_width(this.ptr, e);
  }
  get height() {
    return de.__wbg_get_bbox_height(this.ptr);
  }
  set height(e) {
    de.__wbg_set_bbox_height(this.ptr, e);
  }
};
var Bl = class {
  static __wrap(e) {
    let t = Object.create(Bl.prototype);
    return t.ptr = e, t;
  }
  __destroy_into_raw() {
    let e = this.ptr;
    return this.ptr = 0, e;
  }
  free() {
    let e = this.__destroy_into_raw();
    de.__wbg_renderedimage_free(e);
  }
  get width() {
    return de.renderedimage_width(this.ptr) >>> 0;
  }
  get height() {
    return de.renderedimage_height(this.ptr) >>> 0;
  }
  asPng() {
    try {
      let n = de.__wbindgen_add_to_stack_pointer(-16);
      de.renderedimage_asPng(n, this.ptr);
      var e = Je()[n / 4 + 0], t = Je()[n / 4 + 1], r2 = Je()[n / 4 + 2];
      if (r2)
        throw tr(t);
      return tr(e);
    } finally {
      de.__wbindgen_add_to_stack_pointer(16);
    }
  }
  get pixels() {
    let e = de.renderedimage_pixels(this.ptr);
    return tr(e);
  }
};
var za = class {
  static __wrap(e) {
    let t = Object.create(za.prototype);
    return t.ptr = e, t;
  }
  __destroy_into_raw() {
    let e = this.ptr;
    return this.ptr = 0, e;
  }
  free() {
    let e = this.__destroy_into_raw();
    de.__wbg_resvg_free(e);
  }
  constructor(e, t) {
    try {
      let u = de.__wbindgen_add_to_stack_pointer(-16);
      var r2 = Rl(t) ? 0 : ja(t, de.__wbindgen_malloc, de.__wbindgen_realloc), n = fn;
      de.resvg_new(u, Qt(e), r2, n);
      var i = Je()[u / 4 + 0], a = Je()[u / 4 + 1], o = Je()[u / 4 + 2];
      if (o)
        throw tr(a);
      return za.__wrap(i);
    } finally {
      de.__wbindgen_add_to_stack_pointer(16);
    }
  }
  get width() {
    return de.resvg_width(this.ptr);
  }
  get height() {
    return de.resvg_height(this.ptr);
  }
  render() {
    try {
      let n = de.__wbindgen_add_to_stack_pointer(-16);
      de.resvg_render(n, this.ptr);
      var e = Je()[n / 4 + 0], t = Je()[n / 4 + 1], r2 = Je()[n / 4 + 2];
      if (r2)
        throw tr(t);
      return Bl.__wrap(e);
    } finally {
      de.__wbindgen_add_to_stack_pointer(16);
    }
  }
  toString() {
    try {
      let r2 = de.__wbindgen_add_to_stack_pointer(-16);
      de.resvg_toString(r2, this.ptr);
      var e = Je()[r2 / 4 + 0], t = Je()[r2 / 4 + 1];
      return si(e, t);
    } finally {
      de.__wbindgen_add_to_stack_pointer(16), de.__wbindgen_free(e, t);
    }
  }
  innerBBox() {
    let e = de.resvg_innerBBox(this.ptr);
    return e === 0 ? void 0 : ui.__wrap(e);
  }
  getBBox() {
    let e = de.resvg_getBBox(this.ptr);
    return e === 0 ? void 0 : ui.__wrap(e);
  }
  cropByBBox(e) {
    KD(e, ui), de.resvg_cropByBBox(this.ptr, e.ptr);
  }
  imagesToResolve() {
    try {
      let n = de.__wbindgen_add_to_stack_pointer(-16);
      de.resvg_imagesToResolve(n, this.ptr);
      var e = Je()[n / 4 + 0], t = Je()[n / 4 + 1], r2 = Je()[n / 4 + 2];
      if (r2)
        throw tr(t);
      return tr(e);
    } finally {
      de.__wbindgen_add_to_stack_pointer(16);
    }
  }
  resolveImage(e, t) {
    try {
      let i = de.__wbindgen_add_to_stack_pointer(-16), a = ja(e, de.__wbindgen_malloc, de.__wbindgen_realloc), o = fn;
      de.resvg_resolveImage(i, this.ptr, a, o, Qt(t));
      var r2 = Je()[i / 4 + 0], n = Je()[i / 4 + 1];
      if (n)
        throw tr(r2);
    } finally {
      de.__wbindgen_add_to_stack_pointer(16);
    }
  }
};
async function QD(e, t) {
  if (typeof Response == "function" && e instanceof Response) {
    if (typeof WebAssembly.instantiateStreaming == "function")
      try {
        return await WebAssembly.instantiateStreaming(e, t);
      } catch (n) {
        if (e.headers.get("Content-Type") != "application/wasm")
          console.warn("`WebAssembly.instantiateStreaming` failed because your server does not serve wasm with `application/wasm` MIME type. Falling back to `WebAssembly.instantiate` which is slower. Original error:\n", n);
        else
          throw n;
      }
    let r2 = await e.arrayBuffer();
    return await WebAssembly.instantiate(r2, t);
  } else {
    let r2 = await WebAssembly.instantiate(e, t);
    return r2 instanceof WebAssembly.Instance ? { instance: r2, module: e } : r2;
  }
}
function ey() {
  let e = {};
  return e.wbg = {}, e.wbg.__wbg_new_15d3966e9981a196 = function(t, r2) {
    let n = new Error(si(t, r2));
    return Qt(n);
  }, e.wbg.__wbindgen_memory = function() {
    let t = de.memory;
    return Qt(t);
  }, e.wbg.__wbg_buffer_cf65c07de34b9a08 = function(t) {
    let r2 = Rt(t).buffer;
    return Qt(r2);
  }, e.wbg.__wbg_newwithbyteoffsetandlength_9fb2f11355ecadf5 = function(t, r2, n) {
    let i = new Uint8Array(Rt(t), r2 >>> 0, n >>> 0);
    return Qt(i);
  }, e.wbg.__wbindgen_object_drop_ref = function(t) {
    tr(t);
  }, e.wbg.__wbg_new_537b7341ce90bb31 = function(t) {
    let r2 = new Uint8Array(Rt(t));
    return Qt(r2);
  }, e.wbg.__wbg_instanceof_Uint8Array_01cebe79ca606cca = function(t) {
    let r2;
    try {
      r2 = Rt(t) instanceof Uint8Array;
    } catch {
      r2 = false;
    }
    return r2;
  }, e.wbg.__wbindgen_string_get = function(t, r2) {
    let n = Rt(r2), i = typeof n == "string" ? n : void 0;
    var a = Rl(i) ? 0 : ja(i, de.__wbindgen_malloc, de.__wbindgen_realloc), o = fn;
    Je()[t / 4 + 1] = o, Je()[t / 4 + 0] = a;
  }, e.wbg.__wbg_new_b525de17f44a8943 = function() {
    let t = new Array();
    return Qt(t);
  }, e.wbg.__wbindgen_string_new = function(t, r2) {
    let n = si(t, r2);
    return Qt(n);
  }, e.wbg.__wbg_push_49c286f04dd3bf59 = function(t, r2) {
    return Rt(t).push(Rt(r2));
  }, e.wbg.__wbg_length_27a2afe8ab42b09f = function(t) {
    return Rt(t).length;
  }, e.wbg.__wbg_set_17499e8aa4003ebd = function(t, r2, n) {
    Rt(t).set(Rt(r2), n >>> 0);
  }, e.wbg.__wbindgen_throw = function(t, r2) {
    throw new Error(si(t, r2));
  }, e;
}
function ty(e, t) {
  return de = e.exports, Nl.__wbindgen_wasm_module = t, un = null, sn = null, de;
}
async function Nl(e) {
  typeof e > "u" && (e = new URL("index_bg.wasm", void 0));
  let t = ey();
  (typeof e == "string" || typeof Request == "function" && e instanceof Request || typeof URL == "function" && e instanceof URL) && (e = fetch(e));
  let { instance: r2, module: n } = await QD(await e, t);
  return ty(r2, n);
}
var ry = Nl;
var Va = false;
var Ml = async (e) => {
  if (Va)
    throw new Error("Already initialized. The `initWasm()` function can be used only once.");
  await ry(await e), Va = true;
};
var Gl = class extends za {
  constructor(e, t) {
    if (!Va)
      throw new Error("Wasm has not been initialized. Call `initWasm()` function.");
    super(e, JSON.stringify(t));
  }
};
var Wl = sy;
var ny = /[\s\u2000-\u206F\u2E00-\u2E7F\\'!"#$%&()*+,\-.\/:;<=>?@\[\]^_`{|}~]+/;
var iy = /^[a-z\u00E0-\u00FCA-Z\u00C0-\u00DC][\d|a-z\u00E0-\u00FCA-Z\u00C0-\u00DC]*$/;
var ay = /([A-Z\u00C0-\u00DC]{4,})/g;
var oy = /^[A-Z\u00C0-\u00DC]+$/;
function sy(e) {
  for (var t = e.split(ny), r2 = t.length, n = new Array(r2), i = 0; i < r2; i++) {
    var a = t[i];
    if (a !== "") {
      var o = iy.test(a) && !oy.test(a);
      o && (a = a.replace(ay, function(s, l, f) {
        return uy(s, a.length - f - s.length == 0);
      }));
      var u = a[0];
      u = i > 0 ? u.toUpperCase() : u.toLowerCase(), n[i] = u + (o ? a.slice(1) : a.slice(1).toLowerCase());
    }
  }
  return n.join("");
}
function uy(e, t) {
  var r2 = e.split(""), n = r2.shift().toUpperCase(), i = t ? r2.pop().toLowerCase() : r2.pop();
  return n + r2.join("").toLowerCase() + i;
}
var cn = (e) => e.replace(/\\/g, "\\\\").replace(/\n/g, "\\n").replace(/\r/g, "\\r").replace(/\t/g, "\\t").replace(/\f/g, "\\f").replace(/"/g, '\\"');
var $l = (e) => {
  let t = "", r2 = e.getAttribute("style");
  if (r2) {
    let a = r2.replace(/\n/g, "").replace(/\s\s+/g, " ").split(/;(?![^(]*\))/).reduce((o, u) => {
      let [s, l] = u.split(/:(.+)/);
      return s && l && (o += `"${Wl(s.trim())}": "${cn(l.trim())}",`), o;
    }, "");
    a.endsWith(",") && (a = a.slice(0, -1)), a && (t += `"style":{${a}},`);
  }
  let n = e.getAttribute("src");
  if (n) {
    let i = e.getAttribute("width"), a = e.getAttribute("height");
    i && a ? t += `"src":"${cn(n)}", "width":"${i}", "height":"${a}",` : (console.warn("Image missing width or height attribute as required by Satori"), t += `"src":"${cn(n)}",`);
  }
  return t;
};
var li = (e) => e.endsWith(",") ? e.slice(0, -1) : e;
async function jl(e) {
  let t = "";
  await new HTMLRewriter().on("*", { element(n) {
    let i = $l(n);
    t += `{"type":"${n.tagName}", "props":{${i}"children": [`;
    try {
      n.onEndTag(() => {
        t = li(t), t += "]}},";
      });
    } catch {
      t = li(t), t += "]}},";
    }
  }, text(n) {
    if (n.text) {
      let i = cn(n.text);
      i && (t += `"${i}",`);
    }
  } }).transform(new Response(`<div style="display: flex; flex-direction: column;">${e}</div>`)).text(), t = li(t);
  try {
    return JSON.parse(t);
  } catch (n) {
    return console.error(n), null;
  }
}
async function zl({ family: e, weight: t, text: r2 }) {
  let n = { family: `${encodeURIComponent(e)}${t ? `:wght@${t}` : ""}` };
  r2 ? n.text = r2 : n.subset = "latin";
  let i = `https://fonts.googleapis.com/css2?${Object.keys(n).map((f) => `${f}=${n[f]}`).join("&")}`, a = caches.default, o = i, u = await a.match(o);
  u || (u = await fetch(`${i}`, { headers: { "User-Agent": "Mozilla/5.0 (Macintosh; U; Intel Mac OS X 10_6_8; de-at) AppleWebKit/533.21.1 (KHTML, like Gecko) Version/5.0.5 Safari/533.21.1" } }), u = new Response(u.body, u), u.headers.append("Cache-Control", "s-maxage=3600"), await a.put(o, u.clone()));
  let l = (await u.text()).match(/src: url\((.+)\) format\('(opentype|truetype)'\)/)?.[1];
  if (!l)
    throw new Error("Could not find font URL");
  return fetch(l).then((f) => f.arrayBuffer());
}
var cy = async () => {
  try {
    await Ml(fy);
  } catch (e) {
    if (e instanceof Error && e.message.includes("Already initialized"))
      return;
    throw e;
  }
};
var py = async () => {
  try {
    let e = await Pl(ly);
    await ol(e);
  } catch (e) {
    throw e;
  }
};
var Vl = async ({ element: e, options: t }) => {
  await Promise.allSettled([cy(), py()]);
  let r2 = typeof e == "string" ? await jl(e) : e, n = t?.width || 1200, i = t?.height || 630, a = await Ll(r2, { width: n, height: i, fonts: t?.fonts?.length ? t.fonts : [{ name: "Bitter", data: await zl({ family: "Bitter", weight: 600 }), weight: 500, style: "normal" }] });
  return (t?.format || "png") === "svg" ? a : new Gl(a, { fitTo: { mode: "width", value: n } }).render().asPng();
};
var Ha = class extends Response {
  constructor(t, r2 = {}) {
    if (super(), r2.format === "svg")
      return (async () => {
        let n = await Vl({ element: t, options: r2 });
        return new Response(n, { headers: { "Content-Type": "image/svg+xml", "Cache-Control": r2.debug ? "no-cache, no-store" : "public, immutable, no-transform, max-age=31536000", ...r2.headers }, status: r2.status || 200, statusText: r2.statusText });
      })();
    {
      let n = new ReadableStream({ async start(i) {
        let a = await Vl({ element: t, options: r2 });
        i.enqueue(a), i.close();
      } });
      return new Response(n, { headers: { "Content-Type": "image/png", "Cache-Control": r2.debug ? "no-cache, no-store" : "public, immutable, no-transform, max-age=31536000", ...r2.headers }, status: r2.status || 200, statusText: r2.statusText });
    }
  }
};

// node_modules/hono-og/lib/utils/toReactNode.js
init_checked_fetch();
init_modules_watch_stub();
function toReactNode(jsx_) {
  const jsx2 = jsx_;
  if (!jsx2)
    return null;
  if (Array.isArray(jsx2))
    return jsx2.map((child) => toReactNode(child));
  if (typeof jsx2 === "string")
    return jsx2;
  if (typeof jsx2 === "number")
    return jsx2;
  if (typeof jsx2.tag === "function") {
    const node = jsx2.tag({ ...jsx2.props, children: jsx2.children });
    if (!node.tag)
      return toReactNode(jsx2.children);
    return toReactNode(node);
  }
  const { tag, props } = jsx2;
  const children = jsx2.children?.map((child) => toReactNode(child));
  return {
    type: tag,
    key: null,
    props: {
      ...props,
      children: children.length === 1 ? children[0] : children
    }
  };
}

// node_modules/hono-og/lib/utils/loadGoogleFont.js
init_checked_fetch();
init_modules_watch_stub();

// node_modules/hono-og/lib/utils/lru.js
init_checked_fetch();
init_modules_watch_stub();
var LruMap2 = class extends Map {
  constructor(size2) {
    super();
    Object.defineProperty(this, "maxSize", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    this.maxSize = size2;
  }
  set(key, value) {
    super.set(key, value);
    if (this.maxSize && this.size > this.maxSize)
      this.delete(this.keys().next().value);
    return this;
  }
};

// node_modules/hono-og/lib/utils/loadGoogleFont.js
var buffers = new LruMap2(128);
async function loadGoogleFont({ family, weight, text }) {
  const params = {
    family: `${encodeURIComponent(family)}${weight ? `:wght@${weight}` : ""}`
  };
  if (text)
    params.text = text;
  else
    params.subset = "latin";
  const url = `https://fonts.googleapis.com/css2?${Object.keys(params).map((key) => `${key}=${params[key]}`).join("&")}`;
  if (buffers.get(url))
    return buffers.get(url);
  let response = await fetch(url, {
    headers: {
      // construct user agent to get TTF font
      "User-Agent": "Mozilla/5.0 (Macintosh; U; Intel Mac OS X 10_6_8; de-at) AppleWebKit/533.21.1 (KHTML, like Gecko) Version/5.0.5 Safari/533.21.1"
    }
  });
  response = new Response(response.body, response);
  response.headers.append("Cache-Control", "s-maxage=3600");
  const body = await response.text();
  const fontUrl = body.match(/src: url\((.+)\) format\('(opentype|truetype)'\)/)?.[1];
  if (!fontUrl)
    throw new Error("Could not find font URL");
  const buffer = await fetch(fontUrl).then((res) => res.arrayBuffer());
  buffers.set(url, buffer);
  return buffer;
}

// node_modules/hono-og/lib/exports/worker.js
var ImageResponse = class extends Ha {
  constructor(element, options) {
    super(toReactNode(element), options);
  }
};

// node_modules/frog/_lib/components/Button.js
init_checked_fetch();
init_modules_watch_stub();

// node_modules/frog/_lib/jsx/jsx-runtime/index.js
init_checked_fetch();
init_modules_watch_stub();

// node_modules/frog/_lib/jsx/jsx-dev-runtime/index.js
init_checked_fetch();
init_modules_watch_stub();

// node_modules/hono/dist/jsx/index.js
init_checked_fetch();
init_modules_watch_stub();

// node_modules/hono/dist/jsx/base.js
init_checked_fetch();
init_modules_watch_stub();

// node_modules/hono/dist/helper/html/index.js
init_checked_fetch();
init_modules_watch_stub();

// node_modules/hono/dist/utils/html.js
init_checked_fetch();
init_modules_watch_stub();
var HtmlEscapedCallbackPhase = {
  Stringify: 1,
  BeforeStream: 2,
  Stream: 3
};
var raw = (value, callbacks) => {
  const escapedString = new String(value);
  escapedString.isEscaped = true;
  escapedString.callbacks = callbacks;
  return escapedString;
};
var escapeRe = /[&<>'"]/;
var stringBufferToString = async (buffer) => {
  let str = "";
  const callbacks = [];
  for (let i = buffer.length - 1; ; i--) {
    str += buffer[i];
    i--;
    if (i < 0) {
      break;
    }
    let r2 = await buffer[i];
    if (typeof r2 === "object") {
      callbacks.push(...r2.callbacks || []);
    }
    const isEscaped = r2.isEscaped;
    r2 = await (typeof r2 === "object" ? r2.toString() : r2);
    if (typeof r2 === "object") {
      callbacks.push(...r2.callbacks || []);
    }
    if (r2.isEscaped ?? isEscaped) {
      str += r2;
    } else {
      const buf = [str];
      escapeToBuffer(r2, buf);
      str = buf[0];
    }
  }
  return raw(str, callbacks);
};
var escapeToBuffer = (str, buffer) => {
  const match = str.search(escapeRe);
  if (match === -1) {
    buffer[0] += str;
    return;
  }
  let escape;
  let index;
  let lastIndex = 0;
  for (index = match; index < str.length; index++) {
    switch (str.charCodeAt(index)) {
      case 34:
        escape = "&quot;";
        break;
      case 39:
        escape = "&#39;";
        break;
      case 38:
        escape = "&amp;";
        break;
      case 60:
        escape = "&lt;";
        break;
      case 62:
        escape = "&gt;";
        break;
      default:
        continue;
    }
    buffer[0] += str.substring(lastIndex, index) + escape;
    lastIndex = index + 1;
  }
  buffer[0] += str.substring(lastIndex, index);
};
var resolveCallback = async (str, phase, preserveCallbacks, context, buffer) => {
  const callbacks = str.callbacks;
  if (!callbacks?.length) {
    return Promise.resolve(str);
  }
  if (buffer) {
    buffer[0] += str;
  } else {
    buffer = [str];
  }
  const resStr = Promise.all(callbacks.map((c) => c({ phase, buffer, context }))).then(
    (res) => Promise.all(
      res.filter(Boolean).map((str2) => resolveCallback(str2, phase, false, context, buffer))
    ).then(() => buffer[0])
  );
  if (preserveCallbacks) {
    return raw(await resStr, callbacks);
  } else {
    return resStr;
  }
};

// node_modules/hono/dist/helper/html/index.js
var html = (strings, ...values) => {
  const buffer = [""];
  for (let i = 0, len = strings.length - 1; i < len; i++) {
    buffer[0] += strings[i];
    const children = values[i] instanceof Array ? values[i].flat(Infinity) : [values[i]];
    for (let i2 = 0, len2 = children.length; i2 < len2; i2++) {
      const child = children[i2];
      if (typeof child === "string") {
        escapeToBuffer(child, buffer);
      } else if (typeof child === "number") {
        ;
        buffer[0] += child;
      } else if (typeof child === "boolean" || child === null || child === void 0) {
        continue;
      } else if (typeof child === "object" && child.isEscaped) {
        if (child.callbacks) {
          buffer.unshift("", child);
        } else {
          const tmp = child.toString();
          if (tmp instanceof Promise) {
            buffer.unshift("", tmp);
          } else {
            buffer[0] += tmp;
          }
        }
      } else if (child instanceof Promise) {
        buffer.unshift("", child);
      } else {
        escapeToBuffer(child.toString(), buffer);
      }
    }
  }
  buffer[0] += strings[strings.length - 1];
  return buffer.length === 1 ? raw(buffer[0]) : stringBufferToString(buffer);
};

// node_modules/hono/dist/jsx/context.js
init_checked_fetch();
init_modules_watch_stub();

// node_modules/hono/dist/jsx/constants.js
init_checked_fetch();
init_modules_watch_stub();
var DOM_RENDERER = Symbol("RENDERER");
var DOM_ERROR_HANDLER = Symbol("ERROR_HANDLER");
var DOM_STASH = Symbol("STASH");

// node_modules/hono/dist/jsx/dom/context.js
init_checked_fetch();
init_modules_watch_stub();

// node_modules/hono/dist/jsx/dom/jsx-runtime.js
init_checked_fetch();
init_modules_watch_stub();

// node_modules/hono/dist/jsx/dom/jsx-dev-runtime.js
init_checked_fetch();
init_modules_watch_stub();

// node_modules/hono/dist/jsx/utils.js
init_checked_fetch();
init_modules_watch_stub();
var normalizeIntrinsicElementProps = (props) => {
  if (props && "className" in props) {
    props["class"] = props["className"];
    delete props["className"];
  }
};

// node_modules/hono/dist/jsx/dom/jsx-dev-runtime.js
var jsxDEV = (tag, props, key) => {
  if (typeof tag === "string") {
    normalizeIntrinsicElementProps(props);
  }
  let children;
  if (props && "children" in props) {
    children = props.children;
    delete props["children"];
  } else {
    children = [];
  }
  return {
    tag,
    props,
    key,
    children: Array.isArray(children) ? children : [children]
  };
};
var Fragment = (props) => jsxDEV("", props, void 0);

// node_modules/hono/dist/jsx/context.js
var globalContexts = [];

// node_modules/hono/dist/jsx/base.js
var emptyTags = [
  "area",
  "base",
  "br",
  "col",
  "embed",
  "hr",
  "img",
  "input",
  "keygen",
  "link",
  "meta",
  "param",
  "source",
  "track",
  "wbr"
];
var booleanAttributes = [
  "allowfullscreen",
  "async",
  "autofocus",
  "autoplay",
  "checked",
  "controls",
  "default",
  "defer",
  "disabled",
  "formnovalidate",
  "hidden",
  "inert",
  "ismap",
  "itemscope",
  "loop",
  "multiple",
  "muted",
  "nomodule",
  "novalidate",
  "open",
  "playsinline",
  "readonly",
  "required",
  "reversed",
  "selected"
];
var childrenToStringToBuffer = (children, buffer) => {
  for (let i = 0, len = children.length; i < len; i++) {
    const child = children[i];
    if (typeof child === "string") {
      escapeToBuffer(child, buffer);
    } else if (typeof child === "boolean" || child === null || child === void 0) {
      continue;
    } else if (child instanceof JSXNode) {
      child.toStringToBuffer(buffer);
    } else if (typeof child === "number" || child.isEscaped) {
      ;
      buffer[0] += child;
    } else if (child instanceof Promise) {
      buffer.unshift("", child);
    } else {
      childrenToStringToBuffer(child, buffer);
    }
  }
};
var JSXNode = class {
  constructor(tag, props, children) {
    this.isEscaped = true;
    this.tag = tag;
    this.props = props;
    this.children = children;
  }
  toString() {
    const buffer = [""];
    this.localContexts?.forEach(([context, value]) => {
      context.values.push(value);
    });
    try {
      this.toStringToBuffer(buffer);
    } finally {
      this.localContexts?.forEach(([context]) => {
        context.values.pop();
      });
    }
    return buffer.length === 1 ? buffer[0] : stringBufferToString(buffer);
  }
  toStringToBuffer(buffer) {
    const tag = this.tag;
    const props = this.props;
    let { children } = this;
    buffer[0] += `<${tag}`;
    const propsKeys = Object.keys(props || {});
    for (let i = 0, len = propsKeys.length; i < len; i++) {
      const key = propsKeys[i];
      const v = props[key];
      if (key === "style" && typeof v === "object") {
        const styles = Object.keys(v).map((k) => {
          const property = k.replace(/[A-Z]/g, (match) => `-${match.toLowerCase()}`);
          return `${property}:${v[k]}`;
        }).join(";");
        buffer[0] += ` style="${styles}"`;
      } else if (typeof v === "string") {
        buffer[0] += ` ${key}="`;
        escapeToBuffer(v, buffer);
        buffer[0] += '"';
      } else if (v === null || v === void 0) {
      } else if (typeof v === "number" || v.isEscaped) {
        buffer[0] += ` ${key}="${v}"`;
      } else if (typeof v === "boolean" && booleanAttributes.includes(key)) {
        if (v) {
          buffer[0] += ` ${key}=""`;
        }
      } else if (key === "dangerouslySetInnerHTML") {
        if (children.length > 0) {
          throw "Can only set one of `children` or `props.dangerouslySetInnerHTML`.";
        }
        children = [raw(v.__html)];
      } else if (v instanceof Promise) {
        buffer[0] += ` ${key}="`;
        buffer.unshift('"', v);
      } else if (typeof v === "function") {
        if (!key.startsWith("on")) {
          throw `Invalid prop '${key}' of type 'function' supplied to '${tag}'.`;
        }
      } else {
        buffer[0] += ` ${key}="`;
        escapeToBuffer(v.toString(), buffer);
        buffer[0] += '"';
      }
    }
    if (emptyTags.includes(tag)) {
      buffer[0] += "/>";
      return;
    }
    buffer[0] += ">";
    childrenToStringToBuffer(children, buffer);
    buffer[0] += `</${tag}>`;
  }
};
var JSXFunctionNode = class extends JSXNode {
  toStringToBuffer(buffer) {
    const { children } = this;
    const res = this.tag.call(null, {
      ...this.props,
      children: children.length <= 1 ? children[0] : children
    });
    if (res instanceof Promise) {
      if (globalContexts.length === 0) {
        buffer.unshift("", res);
      } else {
        const currentContexts = globalContexts.map((c) => [c, c.values.at(-1)]);
        buffer.unshift(
          "",
          res.then((childRes) => {
            if (childRes instanceof JSXNode) {
              childRes.localContexts = currentContexts;
            }
            return childRes;
          })
        );
      }
    } else if (res instanceof JSXNode) {
      res.toStringToBuffer(buffer);
    } else if (typeof res === "number" || res.isEscaped) {
      buffer[0] += res;
    } else {
      escapeToBuffer(res, buffer);
    }
  }
};
var JSXFragmentNode = class extends JSXNode {
  toStringToBuffer(buffer) {
    childrenToStringToBuffer(this.children, buffer);
  }
};
var jsx = (tag, props, ...children) => {
  let key;
  if (props) {
    key = props?.key;
    delete props["key"];
  }
  const node = jsxFn(tag, props, children);
  node.key = key;
  return node;
};
var jsxFn = (tag, props, children) => {
  if (typeof tag === "function") {
    return new JSXFunctionNode(tag, props, children);
  } else {
    normalizeIntrinsicElementProps(props);
    return new JSXNode(tag, props, children);
  }
};
var Fragment2 = ({
  children
}) => {
  return new JSXFragmentNode(
    "",
    {},
    Array.isArray(children) ? children : children ? [children] : []
  );
};

// node_modules/hono/dist/jsx/components.js
init_checked_fetch();
init_modules_watch_stub();

// node_modules/hono/dist/jsx/dom/components.js
init_checked_fetch();
init_modules_watch_stub();
var ErrorBoundary = ({ children, fallback: fallback2, fallbackRender, onError }) => {
  const res = Fragment({ children });
  res[DOM_ERROR_HANDLER] = (err) => {
    if (err instanceof Promise) {
      throw err;
    }
    onError?.(err);
    return fallbackRender?.(err) || fallback2;
  };
  return res;
};
var Suspense = ({
  children,
  fallback: fallback2
}) => {
  const res = Fragment({ children });
  res[DOM_ERROR_HANDLER] = (err, retry) => {
    if (!(err instanceof Promise)) {
      throw err;
    }
    err.finally(retry);
    return fallback2;
  };
  return res;
};

// node_modules/hono/dist/jsx/components.js
var errorBoundaryCounter = 0;
var childrenToString = async (children) => {
  try {
    return children.map((c) => c.toString());
  } catch (e) {
    if (e instanceof Promise) {
      await e;
      return childrenToString(children);
    } else {
      throw e;
    }
  }
};
var ErrorBoundary2 = async ({ children, fallback: fallback2, fallbackRender, onError }) => {
  if (!children) {
    return raw("");
  }
  if (!Array.isArray(children)) {
    children = [children];
  }
  let fallbackStr;
  const fallbackRes = (error) => {
    onError?.(error);
    return (fallbackStr || fallbackRender?.(error) || "").toString();
  };
  let resArray = [];
  try {
    resArray = children.map((c) => c.toString());
  } catch (e) {
    fallbackStr = await fallback2?.toString();
    if (e instanceof Promise) {
      resArray = [
        e.then(() => childrenToString(children)).catch((e2) => fallbackRes(e2))
      ];
    } else {
      resArray = [fallbackRes(e)];
    }
  }
  if (resArray.some((res) => res instanceof Promise)) {
    fallbackStr || (fallbackStr = await fallback2?.toString());
    const index = errorBoundaryCounter++;
    const replaceRe = RegExp(`(<template id="E:${index}"></template>.*?)(.*?)(<!--E:${index}-->)`);
    const caught = false;
    const catchCallback = ({ error, buffer }) => {
      if (caught) {
        return "";
      }
      const fallbackResString = fallbackRes(error);
      if (buffer) {
        buffer[0] = buffer[0].replace(replaceRe, fallbackResString);
      }
      return buffer ? "" : `<template data-hono-target="E:${index}">${fallbackResString}</template><script>
((d,c,n) => {
c=d.currentScript.previousSibling
d=d.getElementById('E:${index}')
if(!d)return
do{n=d.nextSibling;n.remove()}while(n.nodeType!=8||n.nodeValue!='E:${index}')
d.replaceWith(c.content)
})(document)
<\/script>`;
    };
    return raw(`<template id="E:${index}"></template><!--E:${index}-->`, [
      ({ phase, buffer, context }) => {
        if (phase === HtmlEscapedCallbackPhase.BeforeStream) {
          return;
        }
        return Promise.all(resArray).then(async (htmlArray) => {
          htmlArray = htmlArray.flat();
          const content = htmlArray.join("");
          let html2 = buffer ? "" : `<template data-hono-target="E:${index}">${content}</template><script>
((d,c) => {
c=d.currentScript.previousSibling
d=d.getElementById('E:${index}')
if(!d)return
d.parentElement.insertBefore(c.content,d.nextSibling)
})(document)
<\/script>`;
          if (htmlArray.every((html22) => !html22.callbacks?.length)) {
            if (buffer) {
              buffer[0] = buffer[0].replace(replaceRe, content);
            }
            return html2;
          }
          if (buffer) {
            buffer[0] = buffer[0].replace(
              replaceRe,
              (_all, pre, _, post) => `${pre}${content}${post}`
            );
          }
          const callbacks = htmlArray.map((html22) => html22.callbacks || []).flat();
          if (phase === HtmlEscapedCallbackPhase.Stream) {
            html2 = await resolveCallback(
              html2,
              HtmlEscapedCallbackPhase.BeforeStream,
              true,
              context
            );
          }
          let resolvedCount = 0;
          const promises = callbacks.map(
            (c) => (...args) => c(...args)?.then((content2) => {
              resolvedCount++;
              if (buffer) {
                if (resolvedCount === callbacks.length) {
                  buffer[0] = buffer[0].replace(replaceRe, (_all, _pre, content3) => content3);
                }
                buffer[0] += content2;
                return raw("", content2.callbacks);
              }
              return raw(
                content2 + (resolvedCount !== callbacks.length ? "" : `<script>
((d,c,n) => {
d=d.getElementById('E:${index}')
if(!d)return
n=d.nextSibling
while(n.nodeType!=8||n.nodeValue!='E:${index}'){n=n.nextSibling}
n.remove()
d.remove()
})(document)
<\/script>`),
                content2.callbacks
              );
            }).catch((error) => catchCallback({ error, buffer }))
          );
          return raw(html2, promises);
        }).catch((error) => catchCallback({ error, buffer }));
      }
    ]);
  } else {
    return raw(resArray.join(""));
  }
};
ErrorBoundary2[DOM_RENDERER] = ErrorBoundary;

// node_modules/hono/dist/jsx/streaming.js
init_checked_fetch();
init_modules_watch_stub();

// node_modules/hono/dist/jsx/dom/render.js
init_checked_fetch();
init_modules_watch_stub();

// node_modules/hono/dist/jsx/hooks/index.js
init_checked_fetch();
init_modules_watch_stub();

// node_modules/hono/dist/jsx/dom/render.js
var buildDataStack = [];

// node_modules/hono/dist/jsx/streaming.js
var suspenseCounter = 0;
var Suspense2 = async ({
  children,
  fallback: fallback2
}) => {
  if (!children) {
    return fallback2.toString();
  }
  if (!Array.isArray(children)) {
    children = [children];
  }
  let resArray = [];
  const stackNode = { [DOM_STASH]: [0, []] };
  const popNodeStack = (value) => {
    buildDataStack.pop();
    return value;
  };
  try {
    stackNode[DOM_STASH][0] = 0;
    buildDataStack.push([[], stackNode]);
    resArray = children.map((c) => c.toString());
  } catch (e) {
    if (e instanceof Promise) {
      resArray = [
        e.then(() => {
          stackNode[DOM_STASH][0] = 0;
          buildDataStack.push([[], stackNode]);
          return childrenToString(children).then(popNodeStack);
        })
      ];
    } else {
      throw e;
    }
  } finally {
    popNodeStack();
  }
  if (resArray.some((res) => res instanceof Promise)) {
    const index = suspenseCounter++;
    const fallbackStr = await fallback2.toString();
    return raw(`<template id="H:${index}"></template>${fallbackStr}<!--/$-->`, [
      ...fallbackStr.callbacks || [],
      ({ phase, buffer, context }) => {
        if (phase === HtmlEscapedCallbackPhase.BeforeStream) {
          return;
        }
        return Promise.all(resArray).then(async (htmlArray) => {
          htmlArray = htmlArray.flat();
          const content = htmlArray.join("");
          if (buffer) {
            buffer[0] = buffer[0].replace(
              new RegExp(`<template id="H:${index}"></template>.*?<!--/\\$-->`),
              content
            );
          }
          let html2 = buffer ? "" : `<template data-hono-target="H:${index}">${content}</template><script>
((d,c,n) => {
c=d.currentScript.previousSibling
d=d.getElementById('H:${index}')
if(!d)return
do{n=d.nextSibling;n.remove()}while(n.nodeType!=8||n.nodeValue!='/$')
d.replaceWith(c.content)
})(document)
<\/script>`;
          const callbacks = htmlArray.map((html22) => html22.callbacks || []).flat();
          if (!callbacks.length) {
            return html2;
          }
          if (phase === HtmlEscapedCallbackPhase.Stream) {
            html2 = await resolveCallback(html2, HtmlEscapedCallbackPhase.BeforeStream, true, context);
          }
          return raw(html2, callbacks);
        });
      }
    ]);
  } else {
    return raw(resArray.join(""));
  }
};
Suspense2[DOM_RENDERER] = Suspense;
var textEncoder = new TextEncoder();

// node_modules/hono/dist/jsx/types.js
init_checked_fetch();
init_modules_watch_stub();

// node_modules/frog/_lib/jsx/jsx-dev-runtime/index.js
function jsxDEV2(tag, props, key) {
  let node;
  if (!props || !("children" in props)) {
    node = jsx(tag, props, ...[]);
  } else {
    const children = props.children;
    delete props["children"];
    node = Array.isArray(children) ? jsx(tag, props, ...children) : jsx(tag, props, ...[children]);
  }
  node.key = key;
  return node;
}

// node_modules/frog/_lib/components/Button.js
var buttonPrefix = {
  link: "_l",
  mint: "_m",
  redirect: "_r",
  reset: "_c",
  transaction: "_t"
};
ButtonRoot.__type = "button";
function ButtonRoot({
  action,
  children,
  // @ts-ignore - private
  index = 1,
  value
}) {
  return [
    jsxDEV2("meta", { property: `fc:frame:button:${index}`, content: normalizeChildren(children), ...value ? { "data-value": value } : {} }),
    jsxDEV2("meta", { property: `fc:frame:button:${index}:action`, content: "post" }),
    action && jsxDEV2("meta", { property: `fc:frame:button:${index}:target`, content: action })
  ];
}
ButtonLink.__type = "button";
function ButtonLink({
  children,
  // @ts-ignore - private
  index = 1,
  href
}) {
  return [
    jsxDEV2("meta", { property: `fc:frame:button:${index}`, content: normalizeChildren(children), "data-value": buttonPrefix.link }),
    jsxDEV2("meta", { property: `fc:frame:button:${index}:action`, content: "link" }),
    jsxDEV2("meta", { property: `fc:frame:button:${index}:target`, content: href })
  ];
}
ButtonMint.__type = "button";
function ButtonMint({
  children,
  // @ts-ignore - private
  index = 1,
  target
}) {
  return [
    jsxDEV2("meta", { property: `fc:frame:button:${index}`, content: normalizeChildren(children), "data-value": buttonPrefix.mint }),
    jsxDEV2("meta", { property: `fc:frame:button:${index}:action`, content: "mint" }),
    jsxDEV2("meta", { property: `fc:frame:button:${index}:target`, content: target })
  ];
}
ButtonRedirect.__type = "button";
function ButtonRedirect({
  children,
  // @ts-ignore - private
  index = 1,
  location
}) {
  return [
    jsxDEV2("meta", { property: `fc:frame:button:${index}`, content: normalizeChildren(children), "data-type": "redirect", "data-value": `${buttonPrefix.redirect}:${location}` }),
    jsxDEV2("meta", { property: `fc:frame:button:${index}:action`, content: "post_redirect" })
    // TODO: Add `target` prop so folks can `'post_redirect'` to a different frame
    // <meta property={`fc:frame:button:${index}:target`} content={target} />,
  ];
}
ButtonReset.__type = "button";
function ButtonReset({
  children,
  // @ts-ignore - private
  index = 1
}) {
  return jsxDEV2("meta", { property: `fc:frame:button:${index}`, content: normalizeChildren(children), "data-value": buttonPrefix.reset, "data-type": "reset" });
}
ButtonTransaction.__type = "button";
function ButtonTransaction({
  action,
  children,
  // @ts-ignore - private
  index = 1,
  target
}) {
  return [
    jsxDEV2("meta", { property: `fc:frame:button:${index}`, content: normalizeChildren(children), "data-value": buttonPrefix.transaction }),
    jsxDEV2("meta", { property: `fc:frame:button:${index}:action`, content: "tx" }),
    jsxDEV2("meta", { property: `fc:frame:button:${index}:target`, content: target }),
    action && jsxDEV2("meta", { property: `fc:frame:button:${index}:post_url`, content: action })
  ];
}
var Button = Object.assign(ButtonRoot, {
  Link: ButtonLink,
  Mint: ButtonMint,
  Redirect: ButtonRedirect,
  Reset: ButtonReset,
  Transaction: ButtonTransaction
});
function normalizeChildren(children) {
  return Array.isArray(children) ? children.join("") : children;
}

// node_modules/frog/_lib/components/TextInput.js
init_checked_fetch();
init_modules_watch_stub();
TextInput.__type = "text-input";
function TextInput({ placeholder }) {
  return jsxDEV2("meta", { property: "fc:frame:input:text", content: placeholder });
}

// node_modules/frog/_lib/frog-base.js
init_checked_fetch();
init_modules_watch_stub();

// node_modules/detect-browser/es/index.js
init_checked_fetch();
init_modules_watch_stub();
var __spreadArray = function(to, from, pack) {
  if (pack || arguments.length === 2)
    for (var i = 0, l = from.length, ar2; i < l; i++) {
      if (ar2 || !(i in from)) {
        if (!ar2)
          ar2 = Array.prototype.slice.call(from, 0, i);
        ar2[i] = from[i];
      }
    }
  return to.concat(ar2 || Array.prototype.slice.call(from));
};
var BrowserInfo = (
  /** @class */
  function() {
    function BrowserInfo2(name, version3, os2) {
      this.name = name;
      this.version = version3;
      this.os = os2;
      this.type = "browser";
    }
    return BrowserInfo2;
  }()
);
var NodeInfo = (
  /** @class */
  function() {
    function NodeInfo2(version3) {
      this.version = version3;
      this.type = "node";
      this.name = "node";
      this.os = process.platform;
    }
    return NodeInfo2;
  }()
);
var SearchBotDeviceInfo = (
  /** @class */
  function() {
    function SearchBotDeviceInfo2(name, version3, os2, bot) {
      this.name = name;
      this.version = version3;
      this.os = os2;
      this.bot = bot;
      this.type = "bot-device";
    }
    return SearchBotDeviceInfo2;
  }()
);
var BotInfo = (
  /** @class */
  function() {
    function BotInfo2() {
      this.type = "bot";
      this.bot = true;
      this.name = "bot";
      this.version = null;
      this.os = null;
    }
    return BotInfo2;
  }()
);
var ReactNativeInfo = (
  /** @class */
  function() {
    function ReactNativeInfo2() {
      this.type = "react-native";
      this.name = "react-native";
      this.version = null;
      this.os = null;
    }
    return ReactNativeInfo2;
  }()
);
var SEARCHBOX_UA_REGEX = /alexa|bot|crawl(er|ing)|facebookexternalhit|feedburner|google web preview|nagios|postrank|pingdom|slurp|spider|yahoo!|yandex/;
var SEARCHBOT_OS_REGEX = /(nuhk|curl|Googlebot|Yammybot|Openbot|Slurp|MSNBot|Ask\ Jeeves\/Teoma|ia_archiver)/;
var REQUIRED_VERSION_PARTS = 3;
var userAgentRules = [
  ["aol", /AOLShield\/([0-9\._]+)/],
  ["edge", /Edge\/([0-9\._]+)/],
  ["edge-ios", /EdgiOS\/([0-9\._]+)/],
  ["yandexbrowser", /YaBrowser\/([0-9\._]+)/],
  ["kakaotalk", /KAKAOTALK\s([0-9\.]+)/],
  ["samsung", /SamsungBrowser\/([0-9\.]+)/],
  ["silk", /\bSilk\/([0-9._-]+)\b/],
  ["miui", /MiuiBrowser\/([0-9\.]+)$/],
  ["beaker", /BeakerBrowser\/([0-9\.]+)/],
  ["edge-chromium", /EdgA?\/([0-9\.]+)/],
  [
    "chromium-webview",
    /(?!Chrom.*OPR)wv\).*Chrom(?:e|ium)\/([0-9\.]+)(:?\s|$)/
  ],
  ["chrome", /(?!Chrom.*OPR)Chrom(?:e|ium)\/([0-9\.]+)(:?\s|$)/],
  ["phantomjs", /PhantomJS\/([0-9\.]+)(:?\s|$)/],
  ["crios", /CriOS\/([0-9\.]+)(:?\s|$)/],
  ["firefox", /Firefox\/([0-9\.]+)(?:\s|$)/],
  ["fxios", /FxiOS\/([0-9\.]+)/],
  ["opera-mini", /Opera Mini.*Version\/([0-9\.]+)/],
  ["opera", /Opera\/([0-9\.]+)(?:\s|$)/],
  ["opera", /OPR\/([0-9\.]+)(:?\s|$)/],
  ["pie", /^Microsoft Pocket Internet Explorer\/(\d+\.\d+)$/],
  ["pie", /^Mozilla\/\d\.\d+\s\(compatible;\s(?:MSP?IE|MSInternet Explorer) (\d+\.\d+);.*Windows CE.*\)$/],
  ["netfront", /^Mozilla\/\d\.\d+.*NetFront\/(\d.\d)/],
  ["ie", /Trident\/7\.0.*rv\:([0-9\.]+).*\).*Gecko$/],
  ["ie", /MSIE\s([0-9\.]+);.*Trident\/[4-7].0/],
  ["ie", /MSIE\s(7\.0)/],
  ["bb10", /BB10;\sTouch.*Version\/([0-9\.]+)/],
  ["android", /Android\s([0-9\.]+)/],
  ["ios", /Version\/([0-9\._]+).*Mobile.*Safari.*/],
  ["safari", /Version\/([0-9\._]+).*Safari/],
  ["facebook", /FB[AS]V\/([0-9\.]+)/],
  ["instagram", /Instagram\s([0-9\.]+)/],
  ["ios-webview", /AppleWebKit\/([0-9\.]+).*Mobile/],
  ["ios-webview", /AppleWebKit\/([0-9\.]+).*Gecko\)$/],
  ["curl", /^curl\/([0-9\.]+)$/],
  ["searchbot", SEARCHBOX_UA_REGEX]
];
var operatingSystemRules = [
  ["iOS", /iP(hone|od|ad)/],
  ["Android OS", /Android/],
  ["BlackBerry OS", /BlackBerry|BB10/],
  ["Windows Mobile", /IEMobile/],
  ["Amazon OS", /Kindle/],
  ["Windows 3.11", /Win16/],
  ["Windows 95", /(Windows 95)|(Win95)|(Windows_95)/],
  ["Windows 98", /(Windows 98)|(Win98)/],
  ["Windows 2000", /(Windows NT 5.0)|(Windows 2000)/],
  ["Windows XP", /(Windows NT 5.1)|(Windows XP)/],
  ["Windows Server 2003", /(Windows NT 5.2)/],
  ["Windows Vista", /(Windows NT 6.0)/],
  ["Windows 7", /(Windows NT 6.1)/],
  ["Windows 8", /(Windows NT 6.2)/],
  ["Windows 8.1", /(Windows NT 6.3)/],
  ["Windows 10", /(Windows NT 10.0)/],
  ["Windows ME", /Windows ME/],
  ["Windows CE", /Windows CE|WinCE|Microsoft Pocket Internet Explorer/],
  ["Open BSD", /OpenBSD/],
  ["Sun OS", /SunOS/],
  ["Chrome OS", /CrOS/],
  ["Linux", /(Linux)|(X11)/],
  ["Mac OS", /(Mac_PowerPC)|(Macintosh)/],
  ["QNX", /QNX/],
  ["BeOS", /BeOS/],
  ["OS/2", /OS\/2/]
];
function detect(userAgent) {
  if (!!userAgent) {
    return parseUserAgent(userAgent);
  }
  if (typeof document === "undefined" && typeof navigator !== "undefined" && navigator.product === "ReactNative") {
    return new ReactNativeInfo();
  }
  if (typeof navigator !== "undefined") {
    return parseUserAgent("Cloudflare-Workers");
  }
  return getNodeVersion();
}
function matchUserAgent(ua2) {
  return ua2 !== "" && userAgentRules.reduce(function(matched, _a2) {
    var browser = _a2[0], regex = _a2[1];
    if (matched) {
      return matched;
    }
    var uaMatch = regex.exec(ua2);
    return !!uaMatch && [browser, uaMatch];
  }, false);
}
function parseUserAgent(ua2) {
  var matchedRule = matchUserAgent(ua2);
  if (!matchedRule) {
    return null;
  }
  var name = matchedRule[0], match = matchedRule[1];
  if (name === "searchbot") {
    return new BotInfo();
  }
  var versionParts = match[1] && match[1].split(".").join("_").split("_").slice(0, 3);
  if (versionParts) {
    if (versionParts.length < REQUIRED_VERSION_PARTS) {
      versionParts = __spreadArray(__spreadArray([], versionParts, true), createVersionParts(REQUIRED_VERSION_PARTS - versionParts.length), true);
    }
  } else {
    versionParts = [];
  }
  var version3 = versionParts.join(".");
  var os2 = detectOS(ua2);
  var searchBotMatch = SEARCHBOT_OS_REGEX.exec(ua2);
  if (searchBotMatch && searchBotMatch[1]) {
    return new SearchBotDeviceInfo(name, version3, os2, searchBotMatch[1]);
  }
  return new BrowserInfo(name, version3, os2);
}
function detectOS(ua2) {
  for (var ii2 = 0, count = operatingSystemRules.length; ii2 < count; ii2++) {
    var _a2 = operatingSystemRules[ii2], os2 = _a2[0], regex = _a2[1];
    var match = regex.exec(ua2);
    if (match) {
      return os2;
    }
  }
  return null;
}
function getNodeVersion() {
  var isNode = typeof process !== "undefined" && process.version;
  return isNode ? new NodeInfo(process.version.slice(1)) : null;
}
function createVersionParts(count) {
  var output3 = [];
  for (var ii2 = 0; ii2 < count; ii2++) {
    output3.push("0");
  }
  return output3;
}

// node_modules/hono/dist/index.js
init_checked_fetch();
init_modules_watch_stub();

// node_modules/hono/dist/hono.js
init_checked_fetch();
init_modules_watch_stub();

// node_modules/hono/dist/hono-base.js
init_checked_fetch();
init_modules_watch_stub();

// node_modules/hono/dist/compose.js
init_checked_fetch();
init_modules_watch_stub();

// node_modules/hono/dist/context.js
init_checked_fetch();
init_modules_watch_stub();
var __accessCheck = (obj, member, msg) => {
  if (!member.has(obj))
    throw TypeError("Cannot " + msg);
};
var __privateGet = (obj, member, getter) => {
  __accessCheck(obj, member, "read from private field");
  return getter ? getter.call(obj) : member.get(obj);
};
var __privateAdd = (obj, member, value) => {
  if (member.has(obj))
    throw TypeError("Cannot add the same private member more than once");
  member instanceof WeakSet ? member.add(obj) : member.set(obj, value);
};
var __privateSet = (obj, member, value, setter) => {
  __accessCheck(obj, member, "write to private field");
  setter ? setter.call(obj, value) : member.set(obj, value);
  return value;
};
var TEXT_PLAIN = "text/plain; charset=UTF-8";
var setHeaders = (headers, map2 = {}) => {
  Object.entries(map2).forEach(([key, value]) => headers.set(key, value));
  return headers;
};
var _status;
var _executionCtx;
var _headers;
var _preparedHeaders;
var _res;
var _isFresh;
var Context = class {
  constructor(req, options) {
    this.env = {};
    this._var = {};
    this.finalized = false;
    this.error = void 0;
    __privateAdd(this, _status, 200);
    __privateAdd(this, _executionCtx, void 0);
    __privateAdd(this, _headers, void 0);
    __privateAdd(this, _preparedHeaders, void 0);
    __privateAdd(this, _res, void 0);
    __privateAdd(this, _isFresh, true);
    this.layout = void 0;
    this.renderer = (content) => this.html(content);
    this.notFoundHandler = () => new Response();
    this.render = (...args) => this.renderer(...args);
    this.setLayout = (layout) => this.layout = layout;
    this.getLayout = () => this.layout;
    this.setRenderer = (renderer) => {
      this.renderer = renderer;
    };
    this.header = (name, value, options2) => {
      if (value === void 0) {
        if (__privateGet(this, _headers)) {
          __privateGet(this, _headers).delete(name);
        } else if (__privateGet(this, _preparedHeaders)) {
          delete __privateGet(this, _preparedHeaders)[name.toLocaleLowerCase()];
        }
        if (this.finalized) {
          this.res.headers.delete(name);
        }
        return;
      }
      if (options2?.append) {
        if (!__privateGet(this, _headers)) {
          __privateSet(this, _isFresh, false);
          __privateSet(this, _headers, new Headers(__privateGet(this, _preparedHeaders)));
          __privateSet(this, _preparedHeaders, {});
        }
        __privateGet(this, _headers).append(name, value);
      } else {
        if (__privateGet(this, _headers)) {
          __privateGet(this, _headers).set(name, value);
        } else {
          __privateGet(this, _preparedHeaders) ?? __privateSet(this, _preparedHeaders, {});
          __privateGet(this, _preparedHeaders)[name.toLowerCase()] = value;
        }
      }
      if (this.finalized) {
        if (options2?.append) {
          this.res.headers.append(name, value);
        } else {
          this.res.headers.set(name, value);
        }
      }
    };
    this.status = (status) => {
      __privateSet(this, _isFresh, false);
      __privateSet(this, _status, status);
    };
    this.set = (key, value) => {
      this._var ?? (this._var = {});
      this._var[key] = value;
    };
    this.get = (key) => {
      return this._var ? this._var[key] : void 0;
    };
    this.newResponse = (data, arg, headers) => {
      if (__privateGet(this, _isFresh) && !headers && !arg && __privateGet(this, _status) === 200) {
        return new Response(data, {
          headers: __privateGet(this, _preparedHeaders)
        });
      }
      if (arg && typeof arg !== "number") {
        const headers2 = setHeaders(new Headers(arg.headers), __privateGet(this, _preparedHeaders));
        return new Response(data, {
          headers: headers2,
          status: arg.status ?? __privateGet(this, _status)
        });
      }
      const status = typeof arg === "number" ? arg : __privateGet(this, _status);
      __privateGet(this, _preparedHeaders) ?? __privateSet(this, _preparedHeaders, {});
      __privateGet(this, _headers) ?? __privateSet(this, _headers, new Headers());
      setHeaders(__privateGet(this, _headers), __privateGet(this, _preparedHeaders));
      if (__privateGet(this, _res)) {
        __privateGet(this, _res).headers.forEach((v, k) => {
          __privateGet(this, _headers)?.set(k, v);
        });
        setHeaders(__privateGet(this, _headers), __privateGet(this, _preparedHeaders));
      }
      headers ?? (headers = {});
      for (const [k, v] of Object.entries(headers)) {
        if (typeof v === "string") {
          __privateGet(this, _headers).set(k, v);
        } else {
          __privateGet(this, _headers).delete(k);
          for (const v2 of v) {
            __privateGet(this, _headers).append(k, v2);
          }
        }
      }
      return new Response(data, {
        status,
        headers: __privateGet(this, _headers)
      });
    };
    this.body = (data, arg, headers) => {
      return typeof arg === "number" ? this.newResponse(data, arg, headers) : this.newResponse(data, arg);
    };
    this.text = (text, arg, headers) => {
      if (!__privateGet(this, _preparedHeaders)) {
        if (__privateGet(this, _isFresh) && !headers && !arg) {
          return new Response(text);
        }
        __privateSet(this, _preparedHeaders, {});
      }
      __privateGet(this, _preparedHeaders)["content-type"] = TEXT_PLAIN;
      return typeof arg === "number" ? this.newResponse(text, arg, headers) : this.newResponse(text, arg);
    };
    this.json = (object, arg, headers) => {
      const body = JSON.stringify(object);
      __privateGet(this, _preparedHeaders) ?? __privateSet(this, _preparedHeaders, {});
      __privateGet(this, _preparedHeaders)["content-type"] = "application/json; charset=UTF-8";
      return typeof arg === "number" ? this.newResponse(body, arg, headers) : this.newResponse(body, arg);
    };
    this.html = (html2, arg, headers) => {
      __privateGet(this, _preparedHeaders) ?? __privateSet(this, _preparedHeaders, {});
      __privateGet(this, _preparedHeaders)["content-type"] = "text/html; charset=UTF-8";
      if (typeof html2 === "object") {
        if (!(html2 instanceof Promise)) {
          html2 = html2.toString();
        }
        if (html2 instanceof Promise) {
          return html2.then((html22) => resolveCallback(html22, HtmlEscapedCallbackPhase.Stringify, false, {})).then((html22) => {
            return typeof arg === "number" ? this.newResponse(html22, arg, headers) : this.newResponse(html22, arg);
          });
        }
      }
      return typeof arg === "number" ? this.newResponse(html2, arg, headers) : this.newResponse(html2, arg);
    };
    this.redirect = (location, status = 302) => {
      __privateGet(this, _headers) ?? __privateSet(this, _headers, new Headers());
      __privateGet(this, _headers).set("Location", location);
      return this.newResponse(null, status);
    };
    this.notFound = () => {
      return this.notFoundHandler(this);
    };
    this.req = req;
    if (options) {
      __privateSet(this, _executionCtx, options.executionCtx);
      this.env = options.env;
      if (options.notFoundHandler) {
        this.notFoundHandler = options.notFoundHandler;
      }
    }
  }
  get event() {
    if (__privateGet(this, _executionCtx) && "respondWith" in __privateGet(this, _executionCtx)) {
      return __privateGet(this, _executionCtx);
    } else {
      throw Error("This context has no FetchEvent");
    }
  }
  get executionCtx() {
    if (__privateGet(this, _executionCtx)) {
      return __privateGet(this, _executionCtx);
    } else {
      throw Error("This context has no ExecutionContext");
    }
  }
  get res() {
    __privateSet(this, _isFresh, false);
    return __privateGet(this, _res) || __privateSet(this, _res, new Response("404 Not Found", { status: 404 }));
  }
  set res(_res2) {
    __privateSet(this, _isFresh, false);
    if (__privateGet(this, _res) && _res2) {
      __privateGet(this, _res).headers.delete("content-type");
      for (const [k, v] of __privateGet(this, _res).headers.entries()) {
        if (k === "set-cookie") {
          const cookies = __privateGet(this, _res).headers.getSetCookie();
          _res2.headers.delete("set-cookie");
          for (const cookie of cookies) {
            _res2.headers.append("set-cookie", cookie);
          }
        } else {
          _res2.headers.set(k, v);
        }
      }
    }
    __privateSet(this, _res, _res2);
    this.finalized = true;
  }
  get var() {
    return { ...this._var };
  }
};
_status = /* @__PURE__ */ new WeakMap();
_executionCtx = /* @__PURE__ */ new WeakMap();
_headers = /* @__PURE__ */ new WeakMap();
_preparedHeaders = /* @__PURE__ */ new WeakMap();
_res = /* @__PURE__ */ new WeakMap();
_isFresh = /* @__PURE__ */ new WeakMap();

// node_modules/hono/dist/compose.js
var compose = (middleware, onError, onNotFound) => {
  return (context, next) => {
    let index = -1;
    return dispatch(0);
    async function dispatch(i) {
      if (i <= index) {
        throw new Error("next() called multiple times");
      }
      index = i;
      let res;
      let isError = false;
      let handler;
      if (middleware[i]) {
        handler = middleware[i][0][0];
        if (context instanceof Context) {
          context.req.routeIndex = i;
        }
      } else {
        handler = i === middleware.length && next || void 0;
      }
      if (!handler) {
        if (context instanceof Context && context.finalized === false && onNotFound) {
          res = await onNotFound(context);
        }
      } else {
        try {
          res = await handler(context, () => {
            return dispatch(i + 1);
          });
        } catch (err) {
          if (err instanceof Error && context instanceof Context && onError) {
            context.error = err;
            res = await onError(err, context);
            isError = true;
          } else {
            throw err;
          }
        }
      }
      if (res && (context.finalized === false || isError)) {
        context.res = res;
      }
      return context;
    }
  };
};

// node_modules/hono/dist/http-exception.js
init_checked_fetch();
init_modules_watch_stub();
var HTTPException = class extends Error {
  constructor(status = 500, options) {
    super(options?.message);
    this.res = options?.res;
    this.status = status;
  }
  getResponse() {
    if (this.res) {
      return this.res;
    }
    return new Response(this.message, {
      status: this.status
    });
  }
};

// node_modules/hono/dist/request.js
init_checked_fetch();
init_modules_watch_stub();

// node_modules/hono/dist/utils/body.js
init_checked_fetch();
init_modules_watch_stub();
var parseBody = async (request, options = { all: false }) => {
  const headers = request instanceof HonoRequest ? request.raw.headers : request.headers;
  const contentType = headers.get("Content-Type");
  if (isFormDataContent(contentType)) {
    return parseFormData(request, options);
  }
  return {};
};
function isFormDataContent(contentType) {
  if (contentType === null) {
    return false;
  }
  return contentType.startsWith("multipart/form-data") || contentType.startsWith("application/x-www-form-urlencoded");
}
async function parseFormData(request, options) {
  const formData = await request.formData();
  if (formData) {
    return convertFormDataToBodyData(formData, options);
  }
  return {};
}
function convertFormDataToBodyData(formData, options) {
  const form = {};
  formData.forEach((value, key) => {
    const shouldParseAllValues = options.all || key.endsWith("[]");
    if (!shouldParseAllValues) {
      form[key] = value;
    } else {
      handleParsingAllValues(form, key, value);
    }
  });
  return form;
}
var handleParsingAllValues = (form, key, value) => {
  if (form[key] && isArrayField(form[key])) {
    appendToExistingArray(form[key], value);
  } else if (form[key]) {
    convertToNewArray(form, key, value);
  } else {
    form[key] = value;
  }
};
function isArrayField(field) {
  return Array.isArray(field);
}
var appendToExistingArray = (arr, value) => {
  arr.push(value);
};
var convertToNewArray = (form, key, value) => {
  form[key] = [form[key], value];
};

// node_modules/hono/dist/utils/url.js
init_checked_fetch();
init_modules_watch_stub();
var splitPath = (path) => {
  const paths = path.split("/");
  if (paths[0] === "") {
    paths.shift();
  }
  return paths;
};
var splitRoutingPath = (routePath) => {
  const { groups, path } = extractGroupsFromPath(routePath);
  const paths = splitPath(path);
  return replaceGroupMarks(paths, groups);
};
var extractGroupsFromPath = (path) => {
  const groups = [];
  path = path.replace(/\{[^}]+\}/g, (match, index) => {
    const mark = `@${index}`;
    groups.push([mark, match]);
    return mark;
  });
  return { groups, path };
};
var replaceGroupMarks = (paths, groups) => {
  for (let i = groups.length - 1; i >= 0; i--) {
    const [mark] = groups[i];
    for (let j = paths.length - 1; j >= 0; j--) {
      if (paths[j].includes(mark)) {
        paths[j] = paths[j].replace(mark, groups[i][1]);
        break;
      }
    }
  }
  return paths;
};
var patternCache = {};
var getPattern = (label) => {
  if (label === "*") {
    return "*";
  }
  const match = label.match(/^\:([^\{\}]+)(?:\{(.+)\})?$/);
  if (match) {
    if (!patternCache[label]) {
      if (match[2]) {
        patternCache[label] = [label, match[1], new RegExp("^" + match[2] + "$")];
      } else {
        patternCache[label] = [label, match[1], true];
      }
    }
    return patternCache[label];
  }
  return null;
};
var getPath = (request) => {
  const match = request.url.match(/^https?:\/\/[^/]+(\/[^?]*)/);
  return match ? match[1] : "";
};
var getQueryStrings = (url) => {
  const queryIndex = url.indexOf("?", 8);
  return queryIndex === -1 ? "" : "?" + url.slice(queryIndex + 1);
};
var getPathNoStrict = (request) => {
  const result = getPath(request);
  return result.length > 1 && result[result.length - 1] === "/" ? result.slice(0, -1) : result;
};
var mergePath = (...paths) => {
  let p2 = "";
  let endsWithSlash = false;
  for (let path of paths) {
    if (p2[p2.length - 1] === "/") {
      p2 = p2.slice(0, -1);
      endsWithSlash = true;
    }
    if (path[0] !== "/") {
      path = `/${path}`;
    }
    if (path === "/" && endsWithSlash) {
      p2 = `${p2}/`;
    } else if (path !== "/") {
      p2 = `${p2}${path}`;
    }
    if (path === "/" && p2 === "") {
      p2 = "/";
    }
  }
  return p2;
};
var checkOptionalParameter = (path) => {
  if (!path.match(/\:.+\?$/)) {
    return null;
  }
  const segments = path.split("/");
  const results = [];
  let basePath = "";
  segments.forEach((segment) => {
    if (segment !== "" && !/\:/.test(segment)) {
      basePath += "/" + segment;
    } else if (/\:/.test(segment)) {
      if (/\?/.test(segment)) {
        if (results.length === 0 && basePath === "") {
          results.push("/");
        } else {
          results.push(basePath);
        }
        const optionalSegment = segment.replace("?", "");
        basePath += "/" + optionalSegment;
        results.push(basePath);
      } else {
        basePath += "/" + segment;
      }
    }
  });
  return results.filter((v, i, a) => a.indexOf(v) === i);
};
var _decodeURI = (value) => {
  if (!/[%+]/.test(value)) {
    return value;
  }
  if (value.indexOf("+") !== -1) {
    value = value.replace(/\+/g, " ");
  }
  return /%/.test(value) ? decodeURIComponent_(value) : value;
};
var _getQueryParam = (url, key, multiple) => {
  let encoded;
  if (!multiple && key && !/[%+]/.test(key)) {
    let keyIndex2 = url.indexOf(`?${key}`, 8);
    if (keyIndex2 === -1) {
      keyIndex2 = url.indexOf(`&${key}`, 8);
    }
    while (keyIndex2 !== -1) {
      const trailingKeyCode = url.charCodeAt(keyIndex2 + key.length + 1);
      if (trailingKeyCode === 61) {
        const valueIndex = keyIndex2 + key.length + 2;
        const endIndex = url.indexOf("&", valueIndex);
        return _decodeURI(url.slice(valueIndex, endIndex === -1 ? void 0 : endIndex));
      } else if (trailingKeyCode == 38 || isNaN(trailingKeyCode)) {
        return "";
      }
      keyIndex2 = url.indexOf(`&${key}`, keyIndex2 + 1);
    }
    encoded = /[%+]/.test(url);
    if (!encoded) {
      return void 0;
    }
  }
  const results = {};
  encoded ?? (encoded = /[%+]/.test(url));
  let keyIndex = url.indexOf("?", 8);
  while (keyIndex !== -1) {
    const nextKeyIndex = url.indexOf("&", keyIndex + 1);
    let valueIndex = url.indexOf("=", keyIndex);
    if (valueIndex > nextKeyIndex && nextKeyIndex !== -1) {
      valueIndex = -1;
    }
    let name = url.slice(
      keyIndex + 1,
      valueIndex === -1 ? nextKeyIndex === -1 ? void 0 : nextKeyIndex : valueIndex
    );
    if (encoded) {
      name = _decodeURI(name);
    }
    keyIndex = nextKeyIndex;
    if (name === "") {
      continue;
    }
    let value;
    if (valueIndex === -1) {
      value = "";
    } else {
      value = url.slice(valueIndex + 1, nextKeyIndex === -1 ? void 0 : nextKeyIndex);
      if (encoded) {
        value = _decodeURI(value);
      }
    }
    if (multiple) {
      if (!(results[name] && Array.isArray(results[name]))) {
        results[name] = [];
      }
      ;
      results[name].push(value);
    } else {
      results[name] ?? (results[name] = value);
    }
  }
  return key ? results[key] : results;
};
var getQueryParam = _getQueryParam;
var getQueryParams = (url, key) => {
  return _getQueryParam(url, key, true);
};
var decodeURIComponent_ = decodeURIComponent;

// node_modules/hono/dist/request.js
var __accessCheck2 = (obj, member, msg) => {
  if (!member.has(obj))
    throw TypeError("Cannot " + msg);
};
var __privateGet2 = (obj, member, getter) => {
  __accessCheck2(obj, member, "read from private field");
  return getter ? getter.call(obj) : member.get(obj);
};
var __privateAdd2 = (obj, member, value) => {
  if (member.has(obj))
    throw TypeError("Cannot add the same private member more than once");
  member instanceof WeakSet ? member.add(obj) : member.set(obj, value);
};
var __privateSet2 = (obj, member, value, setter) => {
  __accessCheck2(obj, member, "write to private field");
  setter ? setter.call(obj, value) : member.set(obj, value);
  return value;
};
var _validatedData;
var _matchResult;
var HonoRequest = class {
  constructor(request, path = "/", matchResult = [[]]) {
    __privateAdd2(this, _validatedData, void 0);
    __privateAdd2(this, _matchResult, void 0);
    this.routeIndex = 0;
    this.bodyCache = {};
    this.cachedBody = (key) => {
      const { bodyCache, raw: raw2 } = this;
      const cachedBody = bodyCache[key];
      if (cachedBody) {
        return cachedBody;
      }
      if (bodyCache.arrayBuffer) {
        return (async () => {
          return await new Response(bodyCache.arrayBuffer)[key]();
        })();
      }
      return bodyCache[key] = raw2[key]();
    };
    this.raw = request;
    this.path = path;
    __privateSet2(this, _matchResult, matchResult);
    __privateSet2(this, _validatedData, {});
  }
  param(key) {
    return key ? this.getDecodedParam(key) : this.getAllDecodedParams();
  }
  getDecodedParam(key) {
    const paramKey = __privateGet2(this, _matchResult)[0][this.routeIndex][1][key];
    const param = this.getParamValue(paramKey);
    return param ? /\%/.test(param) ? decodeURIComponent_(param) : param : void 0;
  }
  getAllDecodedParams() {
    const decoded = {};
    const keys = Object.keys(__privateGet2(this, _matchResult)[0][this.routeIndex][1]);
    for (const key of keys) {
      const value = this.getParamValue(__privateGet2(this, _matchResult)[0][this.routeIndex][1][key]);
      if (value && typeof value === "string") {
        decoded[key] = /\%/.test(value) ? decodeURIComponent_(value) : value;
      }
    }
    return decoded;
  }
  getParamValue(paramKey) {
    return __privateGet2(this, _matchResult)[1] ? __privateGet2(this, _matchResult)[1][paramKey] : paramKey;
  }
  query(key) {
    return getQueryParam(this.url, key);
  }
  queries(key) {
    return getQueryParams(this.url, key);
  }
  header(name) {
    if (name) {
      return this.raw.headers.get(name.toLowerCase()) ?? void 0;
    }
    const headerData = {};
    this.raw.headers.forEach((value, key) => {
      headerData[key] = value;
    });
    return headerData;
  }
  async parseBody(options) {
    if (this.bodyCache.parsedBody) {
      return this.bodyCache.parsedBody;
    }
    const parsedBody = await parseBody(this, options);
    this.bodyCache.parsedBody = parsedBody;
    return parsedBody;
  }
  json() {
    return this.cachedBody("json");
  }
  text() {
    return this.cachedBody("text");
  }
  arrayBuffer() {
    return this.cachedBody("arrayBuffer");
  }
  blob() {
    return this.cachedBody("blob");
  }
  formData() {
    return this.cachedBody("formData");
  }
  addValidatedData(target, data) {
    __privateGet2(this, _validatedData)[target] = data;
  }
  valid(target) {
    return __privateGet2(this, _validatedData)[target];
  }
  get url() {
    return this.raw.url;
  }
  get method() {
    return this.raw.method;
  }
  get matchedRoutes() {
    return __privateGet2(this, _matchResult)[0].map(([[, route]]) => route);
  }
  get routePath() {
    return __privateGet2(this, _matchResult)[0].map(([[, route]]) => route)[this.routeIndex].path;
  }
};
_validatedData = /* @__PURE__ */ new WeakMap();
_matchResult = /* @__PURE__ */ new WeakMap();

// node_modules/hono/dist/router.js
init_checked_fetch();
init_modules_watch_stub();
var METHOD_NAME_ALL = "ALL";
var METHOD_NAME_ALL_LOWERCASE = "all";
var METHODS = ["get", "post", "put", "delete", "options", "patch"];
var MESSAGE_MATCHER_IS_ALREADY_BUILT = "Can not add a route since the matcher is already built.";
var UnsupportedPathError = class extends Error {
};

// node_modules/hono/dist/hono-base.js
var __accessCheck3 = (obj, member, msg) => {
  if (!member.has(obj))
    throw TypeError("Cannot " + msg);
};
var __privateGet3 = (obj, member, getter) => {
  __accessCheck3(obj, member, "read from private field");
  return getter ? getter.call(obj) : member.get(obj);
};
var __privateAdd3 = (obj, member, value) => {
  if (member.has(obj))
    throw TypeError("Cannot add the same private member more than once");
  member instanceof WeakSet ? member.add(obj) : member.set(obj, value);
};
var __privateSet3 = (obj, member, value, setter) => {
  __accessCheck3(obj, member, "write to private field");
  setter ? setter.call(obj, value) : member.set(obj, value);
  return value;
};
var COMPOSED_HANDLER = Symbol("composedHandler");
function defineDynamicClass() {
  return class {
  };
}
var notFoundHandler = (c) => {
  return c.text("404 Not Found", 404);
};
var errorHandler = (err, c) => {
  if (err instanceof HTTPException) {
    return err.getResponse();
  }
  console.error(err);
  return c.text("Internal Server Error", 500);
};
var _path;
var _Hono = class extends defineDynamicClass() {
  constructor(options = {}) {
    super();
    this._basePath = "/";
    __privateAdd3(this, _path, "/");
    this.routes = [];
    this.notFoundHandler = notFoundHandler;
    this.errorHandler = errorHandler;
    this.onError = (handler) => {
      this.errorHandler = handler;
      return this;
    };
    this.notFound = (handler) => {
      this.notFoundHandler = handler;
      return this;
    };
    this.fetch = (request, Env, executionCtx) => {
      return this.dispatch(request, executionCtx, Env, request.method);
    };
    this.request = (input, requestInit, Env, executionCtx) => {
      if (input instanceof Request) {
        if (requestInit !== void 0) {
          input = new Request(input, requestInit);
        }
        return this.fetch(input, Env, executionCtx);
      }
      input = input.toString();
      const path = /^https?:\/\//.test(input) ? input : `http://localhost${mergePath("/", input)}`;
      const req = new Request(path, requestInit);
      return this.fetch(req, Env, executionCtx);
    };
    this.fire = () => {
      addEventListener("fetch", (event) => {
        event.respondWith(this.dispatch(event.request, event, void 0, event.request.method));
      });
    };
    const allMethods = [...METHODS, METHOD_NAME_ALL_LOWERCASE];
    allMethods.map((method) => {
      this[method] = (args1, ...args) => {
        if (typeof args1 === "string") {
          __privateSet3(this, _path, args1);
        } else {
          this.addRoute(method, __privateGet3(this, _path), args1);
        }
        args.map((handler) => {
          if (typeof handler !== "string") {
            this.addRoute(method, __privateGet3(this, _path), handler);
          }
        });
        return this;
      };
    });
    this.on = (method, path, ...handlers) => {
      if (!method) {
        return this;
      }
      for (const p2 of [path].flat()) {
        __privateSet3(this, _path, p2);
        for (const m2 of [method].flat()) {
          handlers.map((handler) => {
            this.addRoute(m2.toUpperCase(), __privateGet3(this, _path), handler);
          });
        }
      }
      return this;
    };
    this.use = (arg1, ...handlers) => {
      if (typeof arg1 === "string") {
        __privateSet3(this, _path, arg1);
      } else {
        __privateSet3(this, _path, "*");
        handlers.unshift(arg1);
      }
      handlers.map((handler) => {
        this.addRoute(METHOD_NAME_ALL, __privateGet3(this, _path), handler);
      });
      return this;
    };
    const strict = options.strict ?? true;
    delete options.strict;
    Object.assign(this, options);
    this.getPath = strict ? options.getPath ?? getPath : getPathNoStrict;
  }
  clone() {
    const clone = new _Hono({
      router: this.router,
      getPath: this.getPath
    });
    clone.routes = this.routes;
    return clone;
  }
  route(path, app5) {
    const subApp = this.basePath(path);
    if (!app5) {
      return subApp;
    }
    app5.routes.map((r2) => {
      let handler;
      if (app5.errorHandler === errorHandler) {
        handler = r2.handler;
      } else {
        handler = async (c, next) => (await compose([], app5.errorHandler)(c, () => r2.handler(c, next))).res;
        handler[COMPOSED_HANDLER] = r2.handler;
      }
      subApp.addRoute(r2.method, r2.path, handler);
    });
    return this;
  }
  basePath(path) {
    const subApp = this.clone();
    subApp._basePath = mergePath(this._basePath, path);
    return subApp;
  }
  mount(path, applicationHandler, optionHandler) {
    const mergedPath = mergePath(this._basePath, path);
    const pathPrefixLength = mergedPath === "/" ? 0 : mergedPath.length;
    const handler = async (c, next) => {
      let executionContext = void 0;
      try {
        executionContext = c.executionCtx;
      } catch {
      }
      const options = optionHandler ? optionHandler(c) : [c.env, executionContext];
      const optionsArray = Array.isArray(options) ? options : [options];
      const queryStrings = getQueryStrings(c.req.url);
      const res = await applicationHandler(
        new Request(
          new URL((c.req.path.slice(pathPrefixLength) || "/") + queryStrings, c.req.url),
          c.req.raw
        ),
        ...optionsArray
      );
      if (res) {
        return res;
      }
      await next();
    };
    this.addRoute(METHOD_NAME_ALL, mergePath(path, "*"), handler);
    return this;
  }
  addRoute(method, path, handler) {
    method = method.toUpperCase();
    path = mergePath(this._basePath, path);
    const r2 = { path, method, handler };
    this.router.add(method, path, [handler, r2]);
    this.routes.push(r2);
  }
  matchRoute(method, path) {
    return this.router.match(method, path);
  }
  handleError(err, c) {
    if (err instanceof Error) {
      return this.errorHandler(err, c);
    }
    throw err;
  }
  dispatch(request, executionCtx, env, method) {
    if (method === "HEAD") {
      return (async () => new Response(null, await this.dispatch(request, executionCtx, env, "GET")))();
    }
    const path = this.getPath(request, { env });
    const matchResult = this.matchRoute(method, path);
    const c = new Context(new HonoRequest(request, path, matchResult), {
      env,
      executionCtx,
      notFoundHandler: this.notFoundHandler
    });
    if (matchResult[0].length === 1) {
      let res;
      try {
        res = matchResult[0][0][0][0](c, async () => {
          c.res = await this.notFoundHandler(c);
        });
      } catch (err) {
        return this.handleError(err, c);
      }
      return res instanceof Promise ? res.then(
        (resolved) => resolved || (c.finalized ? c.res : this.notFoundHandler(c))
      ).catch((err) => this.handleError(err, c)) : res;
    }
    const composed = compose(matchResult[0], this.errorHandler, this.notFoundHandler);
    return (async () => {
      try {
        const context = await composed(c);
        if (!context.finalized) {
          throw new Error(
            "Context is not finalized. You may forget returning Response object or `await next()`"
          );
        }
        return context.res;
      } catch (err) {
        return this.handleError(err, c);
      }
    })();
  }
};
var Hono = _Hono;
_path = /* @__PURE__ */ new WeakMap();

// node_modules/hono/dist/router/reg-exp-router/index.js
init_checked_fetch();
init_modules_watch_stub();

// node_modules/hono/dist/router/reg-exp-router/router.js
init_checked_fetch();
init_modules_watch_stub();

// node_modules/hono/dist/router/reg-exp-router/node.js
init_checked_fetch();
init_modules_watch_stub();
var LABEL_REG_EXP_STR = "[^/]+";
var ONLY_WILDCARD_REG_EXP_STR = ".*";
var TAIL_WILDCARD_REG_EXP_STR = "(?:|/.*)";
var PATH_ERROR = Symbol();
function compareKey(a, b) {
  if (a.length === 1) {
    return b.length === 1 ? a < b ? -1 : 1 : -1;
  }
  if (b.length === 1) {
    return 1;
  }
  if (a === ONLY_WILDCARD_REG_EXP_STR || a === TAIL_WILDCARD_REG_EXP_STR) {
    return 1;
  } else if (b === ONLY_WILDCARD_REG_EXP_STR || b === TAIL_WILDCARD_REG_EXP_STR) {
    return -1;
  }
  if (a === LABEL_REG_EXP_STR) {
    return 1;
  } else if (b === LABEL_REG_EXP_STR) {
    return -1;
  }
  return a.length === b.length ? a < b ? -1 : 1 : b.length - a.length;
}
var Node = class {
  constructor() {
    this.children = {};
  }
  insert(tokens, index, paramMap, context, pathErrorCheckOnly) {
    if (tokens.length === 0) {
      if (this.index !== void 0) {
        throw PATH_ERROR;
      }
      if (pathErrorCheckOnly) {
        return;
      }
      this.index = index;
      return;
    }
    const [token, ...restTokens] = tokens;
    const pattern = token === "*" ? restTokens.length === 0 ? ["", "", ONLY_WILDCARD_REG_EXP_STR] : ["", "", LABEL_REG_EXP_STR] : token === "/*" ? ["", "", TAIL_WILDCARD_REG_EXP_STR] : token.match(/^\:([^\{\}]+)(?:\{(.+)\})?$/);
    let node;
    if (pattern) {
      const name = pattern[1];
      let regexpStr = pattern[2] || LABEL_REG_EXP_STR;
      if (name && pattern[2]) {
        regexpStr = regexpStr.replace(/^\((?!\?:)(?=[^)]+\)$)/, "(?:");
        if (/\((?!\?:)/.test(regexpStr)) {
          throw PATH_ERROR;
        }
      }
      node = this.children[regexpStr];
      if (!node) {
        if (Object.keys(this.children).some(
          (k) => k !== ONLY_WILDCARD_REG_EXP_STR && k !== TAIL_WILDCARD_REG_EXP_STR
        )) {
          throw PATH_ERROR;
        }
        if (pathErrorCheckOnly) {
          return;
        }
        node = this.children[regexpStr] = new Node();
        if (name !== "") {
          node.varIndex = context.varIndex++;
        }
      }
      if (!pathErrorCheckOnly && name !== "") {
        paramMap.push([name, node.varIndex]);
      }
    } else {
      node = this.children[token];
      if (!node) {
        if (Object.keys(this.children).some(
          (k) => k.length > 1 && k !== ONLY_WILDCARD_REG_EXP_STR && k !== TAIL_WILDCARD_REG_EXP_STR
        )) {
          throw PATH_ERROR;
        }
        if (pathErrorCheckOnly) {
          return;
        }
        node = this.children[token] = new Node();
      }
    }
    node.insert(restTokens, index, paramMap, context, pathErrorCheckOnly);
  }
  buildRegExpStr() {
    const childKeys = Object.keys(this.children).sort(compareKey);
    const strList = childKeys.map((k) => {
      const c = this.children[k];
      return (typeof c.varIndex === "number" ? `(${k})@${c.varIndex}` : k) + c.buildRegExpStr();
    });
    if (typeof this.index === "number") {
      strList.unshift(`#${this.index}`);
    }
    if (strList.length === 0) {
      return "";
    }
    if (strList.length === 1) {
      return strList[0];
    }
    return "(?:" + strList.join("|") + ")";
  }
};

// node_modules/hono/dist/router/reg-exp-router/trie.js
init_checked_fetch();
init_modules_watch_stub();
var Trie = class {
  constructor() {
    this.context = { varIndex: 0 };
    this.root = new Node();
  }
  insert(path, index, pathErrorCheckOnly) {
    const paramAssoc = [];
    const groups = [];
    for (let i = 0; ; ) {
      let replaced = false;
      path = path.replace(/\{[^}]+\}/g, (m2) => {
        const mark = `@\\${i}`;
        groups[i] = [mark, m2];
        i++;
        replaced = true;
        return mark;
      });
      if (!replaced) {
        break;
      }
    }
    const tokens = path.match(/(?::[^\/]+)|(?:\/\*$)|./g) || [];
    for (let i = groups.length - 1; i >= 0; i--) {
      const [mark] = groups[i];
      for (let j = tokens.length - 1; j >= 0; j--) {
        if (tokens[j].indexOf(mark) !== -1) {
          tokens[j] = tokens[j].replace(mark, groups[i][1]);
          break;
        }
      }
    }
    this.root.insert(tokens, index, paramAssoc, this.context, pathErrorCheckOnly);
    return paramAssoc;
  }
  buildRegExp() {
    let regexp = this.root.buildRegExpStr();
    if (regexp === "") {
      return [/^$/, [], []];
    }
    let captureIndex = 0;
    const indexReplacementMap = [];
    const paramReplacementMap = [];
    regexp = regexp.replace(/#(\d+)|@(\d+)|\.\*\$/g, (_, handlerIndex, paramIndex) => {
      if (typeof handlerIndex !== "undefined") {
        indexReplacementMap[++captureIndex] = Number(handlerIndex);
        return "$()";
      }
      if (typeof paramIndex !== "undefined") {
        paramReplacementMap[Number(paramIndex)] = ++captureIndex;
        return "";
      }
      return "";
    });
    return [new RegExp(`^${regexp}`), indexReplacementMap, paramReplacementMap];
  }
};

// node_modules/hono/dist/router/reg-exp-router/router.js
var emptyParam = [];
var nullMatcher = [/^$/, [], {}];
var wildcardRegExpCache = {};
function buildWildcardRegExp(path) {
  return wildcardRegExpCache[path] ?? (wildcardRegExpCache[path] = new RegExp(
    path === "*" ? "" : `^${path.replace(/\/\*/, "(?:|/.*)")}$`
  ));
}
function clearWildcardRegExpCache() {
  wildcardRegExpCache = {};
}
function buildMatcherFromPreprocessedRoutes(routes) {
  const trie = new Trie();
  const handlerData = [];
  if (routes.length === 0) {
    return nullMatcher;
  }
  const routesWithStaticPathFlag = routes.map(
    (route) => [!/\*|\/:/.test(route[0]), ...route]
  ).sort(
    ([isStaticA, pathA], [isStaticB, pathB]) => isStaticA ? 1 : isStaticB ? -1 : pathA.length - pathB.length
  );
  const staticMap = {};
  for (let i = 0, j = -1, len = routesWithStaticPathFlag.length; i < len; i++) {
    const [pathErrorCheckOnly, path, handlers] = routesWithStaticPathFlag[i];
    if (pathErrorCheckOnly) {
      staticMap[path] = [handlers.map(([h2]) => [h2, {}]), emptyParam];
    } else {
      j++;
    }
    let paramAssoc;
    try {
      paramAssoc = trie.insert(path, j, pathErrorCheckOnly);
    } catch (e) {
      throw e === PATH_ERROR ? new UnsupportedPathError(path) : e;
    }
    if (pathErrorCheckOnly) {
      continue;
    }
    handlerData[j] = handlers.map(([h2, paramCount]) => {
      const paramIndexMap = {};
      paramCount -= 1;
      for (; paramCount >= 0; paramCount--) {
        const [key, value] = paramAssoc[paramCount];
        paramIndexMap[key] = value;
      }
      return [h2, paramIndexMap];
    });
  }
  const [regexp, indexReplacementMap, paramReplacementMap] = trie.buildRegExp();
  for (let i = 0, len = handlerData.length; i < len; i++) {
    for (let j = 0, len2 = handlerData[i].length; j < len2; j++) {
      const map2 = handlerData[i][j]?.[1];
      if (!map2) {
        continue;
      }
      const keys = Object.keys(map2);
      for (let k = 0, len3 = keys.length; k < len3; k++) {
        map2[keys[k]] = paramReplacementMap[map2[keys[k]]];
      }
    }
  }
  const handlerMap = [];
  for (const i in indexReplacementMap) {
    handlerMap[i] = handlerData[indexReplacementMap[i]];
  }
  return [regexp, handlerMap, staticMap];
}
function findMiddleware(middleware, path) {
  if (!middleware) {
    return void 0;
  }
  for (const k of Object.keys(middleware).sort((a, b) => b.length - a.length)) {
    if (buildWildcardRegExp(k).test(path)) {
      return [...middleware[k]];
    }
  }
  return void 0;
}
var RegExpRouter = class {
  constructor() {
    this.name = "RegExpRouter";
    this.middleware = { [METHOD_NAME_ALL]: {} };
    this.routes = { [METHOD_NAME_ALL]: {} };
  }
  add(method, path, handler) {
    var _a2;
    const { middleware, routes } = this;
    if (!middleware || !routes) {
      throw new Error(MESSAGE_MATCHER_IS_ALREADY_BUILT);
    }
    if (!middleware[method]) {
      ;
      [middleware, routes].forEach((handlerMap) => {
        handlerMap[method] = {};
        Object.keys(handlerMap[METHOD_NAME_ALL]).forEach((p2) => {
          handlerMap[method][p2] = [...handlerMap[METHOD_NAME_ALL][p2]];
        });
      });
    }
    if (path === "/*") {
      path = "*";
    }
    const paramCount = (path.match(/\/:/g) || []).length;
    if (/\*$/.test(path)) {
      const re = buildWildcardRegExp(path);
      if (method === METHOD_NAME_ALL) {
        Object.keys(middleware).forEach((m2) => {
          var _a22;
          (_a22 = middleware[m2])[path] || (_a22[path] = findMiddleware(middleware[m2], path) || findMiddleware(middleware[METHOD_NAME_ALL], path) || []);
        });
      } else {
        (_a2 = middleware[method])[path] || (_a2[path] = findMiddleware(middleware[method], path) || findMiddleware(middleware[METHOD_NAME_ALL], path) || []);
      }
      Object.keys(middleware).forEach((m2) => {
        if (method === METHOD_NAME_ALL || method === m2) {
          Object.keys(middleware[m2]).forEach((p2) => {
            re.test(p2) && middleware[m2][p2].push([handler, paramCount]);
          });
        }
      });
      Object.keys(routes).forEach((m2) => {
        if (method === METHOD_NAME_ALL || method === m2) {
          Object.keys(routes[m2]).forEach(
            (p2) => re.test(p2) && routes[m2][p2].push([handler, paramCount])
          );
        }
      });
      return;
    }
    const paths = checkOptionalParameter(path) || [path];
    for (let i = 0, len = paths.length; i < len; i++) {
      const path2 = paths[i];
      Object.keys(routes).forEach((m2) => {
        var _a22;
        if (method === METHOD_NAME_ALL || method === m2) {
          (_a22 = routes[m2])[path2] || (_a22[path2] = [
            ...findMiddleware(middleware[m2], path2) || findMiddleware(middleware[METHOD_NAME_ALL], path2) || []
          ]);
          routes[m2][path2].push([handler, paramCount - len + i + 1]);
        }
      });
    }
  }
  match(method, path) {
    clearWildcardRegExpCache();
    const matchers = this.buildAllMatchers();
    this.match = (method2, path2) => {
      const matcher = matchers[method2] || matchers[METHOD_NAME_ALL];
      const staticMatch = matcher[2][path2];
      if (staticMatch) {
        return staticMatch;
      }
      const match = path2.match(matcher[0]);
      if (!match) {
        return [[], emptyParam];
      }
      const index = match.indexOf("", 1);
      return [matcher[1][index], match];
    };
    return this.match(method, path);
  }
  buildAllMatchers() {
    const matchers = {};
    [...Object.keys(this.routes), ...Object.keys(this.middleware)].forEach((method) => {
      matchers[method] || (matchers[method] = this.buildMatcher(method));
    });
    this.middleware = this.routes = void 0;
    return matchers;
  }
  buildMatcher(method) {
    const routes = [];
    let hasOwnRoute = method === METHOD_NAME_ALL;
    [this.middleware, this.routes].forEach((r2) => {
      const ownRoute = r2[method] ? Object.keys(r2[method]).map((path) => [path, r2[method][path]]) : [];
      if (ownRoute.length !== 0) {
        hasOwnRoute || (hasOwnRoute = true);
        routes.push(...ownRoute);
      } else if (method !== METHOD_NAME_ALL) {
        routes.push(
          ...Object.keys(r2[METHOD_NAME_ALL]).map((path) => [path, r2[METHOD_NAME_ALL][path]])
        );
      }
    });
    if (!hasOwnRoute) {
      return null;
    } else {
      return buildMatcherFromPreprocessedRoutes(routes);
    }
  }
};

// node_modules/hono/dist/router/smart-router/index.js
init_checked_fetch();
init_modules_watch_stub();

// node_modules/hono/dist/router/smart-router/router.js
init_checked_fetch();
init_modules_watch_stub();
var SmartRouter = class {
  constructor(init) {
    this.name = "SmartRouter";
    this.routers = [];
    this.routes = [];
    Object.assign(this, init);
  }
  add(method, path, handler) {
    if (!this.routes) {
      throw new Error(MESSAGE_MATCHER_IS_ALREADY_BUILT);
    }
    this.routes.push([method, path, handler]);
  }
  match(method, path) {
    if (!this.routes) {
      throw new Error("Fatal error");
    }
    const { routers, routes } = this;
    const len = routers.length;
    let i = 0;
    let res;
    for (; i < len; i++) {
      const router = routers[i];
      try {
        routes.forEach((args) => {
          router.add(...args);
        });
        res = router.match(method, path);
      } catch (e) {
        if (e instanceof UnsupportedPathError) {
          continue;
        }
        throw e;
      }
      this.match = router.match.bind(router);
      this.routers = [router];
      this.routes = void 0;
      break;
    }
    if (i === len) {
      throw new Error("Fatal error");
    }
    this.name = `SmartRouter + ${this.activeRouter.name}`;
    return res;
  }
  get activeRouter() {
    if (this.routes || this.routers.length !== 1) {
      throw new Error("No active router has been determined yet.");
    }
    return this.routers[0];
  }
};

// node_modules/hono/dist/router/trie-router/index.js
init_checked_fetch();
init_modules_watch_stub();

// node_modules/hono/dist/router/trie-router/router.js
init_checked_fetch();
init_modules_watch_stub();

// node_modules/hono/dist/router/trie-router/node.js
init_checked_fetch();
init_modules_watch_stub();
var Node2 = class {
  constructor(method, handler, children) {
    this.order = 0;
    this.params = {};
    this.children = children || {};
    this.methods = [];
    this.name = "";
    if (method && handler) {
      const m2 = {};
      m2[method] = { handler, possibleKeys: [], score: 0, name: this.name };
      this.methods = [m2];
    }
    this.patterns = [];
  }
  insert(method, path, handler) {
    this.name = `${method} ${path}`;
    this.order = ++this.order;
    let curNode = this;
    const parts = splitRoutingPath(path);
    const possibleKeys = [];
    const parentPatterns = [];
    for (let i = 0, len = parts.length; i < len; i++) {
      const p2 = parts[i];
      if (Object.keys(curNode.children).includes(p2)) {
        parentPatterns.push(...curNode.patterns);
        curNode = curNode.children[p2];
        const pattern2 = getPattern(p2);
        if (pattern2) {
          possibleKeys.push(pattern2[1]);
        }
        continue;
      }
      curNode.children[p2] = new Node2();
      const pattern = getPattern(p2);
      if (pattern) {
        curNode.patterns.push(pattern);
        parentPatterns.push(...curNode.patterns);
        possibleKeys.push(pattern[1]);
      }
      parentPatterns.push(...curNode.patterns);
      curNode = curNode.children[p2];
    }
    if (!curNode.methods.length) {
      curNode.methods = [];
    }
    const m2 = {};
    const handlerSet = {
      handler,
      possibleKeys: possibleKeys.filter((v, i, a) => a.indexOf(v) === i),
      name: this.name,
      score: this.order
    };
    m2[method] = handlerSet;
    curNode.methods.push(m2);
    return curNode;
  }
  gHSets(node, method, nodeParams, params) {
    const handlerSets = [];
    for (let i = 0, len = node.methods.length; i < len; i++) {
      const m2 = node.methods[i];
      const handlerSet = m2[method] || m2[METHOD_NAME_ALL];
      const processedSet = {};
      if (handlerSet !== void 0) {
        handlerSet.params = {};
        handlerSet.possibleKeys.forEach((key) => {
          const processed = processedSet[handlerSet.name];
          handlerSet.params[key] = params[key] && !processed ? params[key] : nodeParams[key] ?? params[key];
          processedSet[handlerSet.name] = true;
        });
        handlerSets.push(handlerSet);
      }
    }
    return handlerSets;
  }
  search(method, path) {
    const handlerSets = [];
    this.params = {};
    const curNode = this;
    let curNodes = [curNode];
    const parts = splitPath(path);
    for (let i = 0, len = parts.length; i < len; i++) {
      const part = parts[i];
      const isLast = i === len - 1;
      const tempNodes = [];
      for (let j = 0, len2 = curNodes.length; j < len2; j++) {
        const node = curNodes[j];
        const nextNode = node.children[part];
        if (nextNode) {
          nextNode.params = node.params;
          if (isLast === true) {
            if (nextNode.children["*"]) {
              handlerSets.push(...this.gHSets(nextNode.children["*"], method, node.params, {}));
            }
            handlerSets.push(...this.gHSets(nextNode, method, node.params, {}));
          } else {
            tempNodes.push(nextNode);
          }
        }
        for (let k = 0, len3 = node.patterns.length; k < len3; k++) {
          const pattern = node.patterns[k];
          const params = { ...node.params };
          if (pattern === "*") {
            const astNode = node.children["*"];
            if (astNode) {
              handlerSets.push(...this.gHSets(astNode, method, node.params, {}));
              tempNodes.push(astNode);
            }
            continue;
          }
          if (part === "") {
            continue;
          }
          const [key, name, matcher] = pattern;
          const child = node.children[key];
          const restPathString = parts.slice(i).join("/");
          if (matcher instanceof RegExp && matcher.test(restPathString)) {
            params[name] = restPathString;
            handlerSets.push(...this.gHSets(child, method, node.params, params));
            continue;
          }
          if (matcher === true || matcher instanceof RegExp && matcher.test(part)) {
            if (typeof key === "string") {
              params[name] = part;
              if (isLast === true) {
                handlerSets.push(...this.gHSets(child, method, params, node.params));
                if (child.children["*"]) {
                  handlerSets.push(...this.gHSets(child.children["*"], method, params, node.params));
                }
              } else {
                child.params = params;
                tempNodes.push(child);
              }
            }
          }
        }
      }
      curNodes = tempNodes;
    }
    const results = handlerSets.sort((a, b) => {
      return a.score - b.score;
    });
    return [results.map(({ handler, params }) => [handler, params])];
  }
};

// node_modules/hono/dist/router/trie-router/router.js
var TrieRouter = class {
  constructor() {
    this.name = "TrieRouter";
    this.node = new Node2();
  }
  add(method, path, handler) {
    const results = checkOptionalParameter(path);
    if (results) {
      for (const p2 of results) {
        this.node.insert(method, p2, handler);
      }
      return;
    }
    this.node.insert(method, path, handler);
  }
  match(method, path) {
    return this.node.search(method, path);
  }
};

// node_modules/hono/dist/hono.js
var Hono2 = class extends Hono {
  constructor(options = {}) {
    super(options);
    this.router = options.router ?? new SmartRouter({
      routers: [new RegExpRouter(), new TrieRouter()]
    });
  }
};

// node_modules/frog/_lib/frog-base.js
var import_lz_string = __toESM(require_lz_string(), 1);
var import_path_browserify = __toESM(require_path_browserify(), 1);

// node_modules/frog/_lib/utils/fromQuery.js
init_checked_fetch();
init_modules_watch_stub();
function fromQuery(query2) {
  const obj = {};
  for (const [key, value] of Object.entries(query2)) {
    let decoded = decodeURIComponent(value);
    if (decoded.startsWith("#A_"))
      decoded = decoded.replace("#A_", "").split(",");
    else if (decoded.startsWith("#O_"))
      decoded = JSON.parse(decoded.replace("#O_", ""));
    obj[key.replace(/^amp;/, "")] = decoded;
  }
  return obj;
}

// node_modules/frog/_lib/utils/getButtonValues.js
init_checked_fetch();
init_modules_watch_stub();
function getButtonValues(intents) {
  if (!intents)
    return [];
  const buttonValues = [];
  for (const intent of intents) {
    if (!intent)
      continue;
    const { property } = intent.props;
    if (!property.match(/^fc:frame:button:(1|2|3|4)$/))
      continue;
    buttonValues.push(intent.props["data-value"]);
  }
  return buttonValues;
}

// node_modules/frog/_lib/utils/getFrameContext.js
init_checked_fetch();
init_modules_watch_stub();

// node_modules/frog/_lib/utils/getIntentState.js
init_checked_fetch();
init_modules_watch_stub();
function getIntentState({ buttonValues, frameData }) {
  const { buttonIndex, inputText } = frameData || {};
  const state = {
    buttonValue: void 0,
    inputText,
    redirect: false,
    reset: false
  };
  if (!buttonValues)
    return state;
  if (buttonIndex) {
    const buttonIntents = buttonValues;
    const intent = buttonIntents[buttonIndex - 1];
    if (!intent)
      return state;
    if (intent.startsWith(buttonPrefix.reset))
      state.reset = true;
    else if (intent.startsWith(buttonPrefix.redirect)) {
      state.redirect = true;
      state.buttonValue = intent.slice(3);
    } else
      state.buttonValue = intent;
  }
  return state;
}

// node_modules/frog/_lib/utils/parsePath.js
init_checked_fetch();
init_modules_watch_stub();
function parsePath(path_) {
  let path = path_.split("?")[0];
  if (path.endsWith("/"))
    path = path.slice(0, -1);
  return path;
}

// node_modules/frog/_lib/utils/getFrameContext.js
function getFrameContext(parameters) {
  const { context, origin } = parameters;
  const { env, frameData, initialPath, previousButtonValues, req, verified } = context || {};
  const { buttonValue, inputText, redirect, reset } = getIntentState({
    buttonValues: previousButtonValues || [],
    frameData
  });
  const status = (() => {
    if (redirect)
      return "redirect";
    if (reset)
      return "initial";
    return context.status || "initial";
  })();
  const url = (reset ? `${origin}${initialPath}` : void 0) || parsePath(context.url);
  let previousState = (() => {
    if (context.status === "initial")
      return parameters.initialState;
    return context?.previousState || parameters.initialState;
  })();
  function deriveState(derive) {
    if (status !== "response")
      return previousState;
    if (!derive)
      return previousState;
    const clone = structuredClone(previousState);
    if (derive[Symbol.toStringTag] === "AsyncFunction")
      return derive(clone).then(() => {
        previousState = clone;
        return previousState;
      });
    derive(clone);
    previousState = clone;
    return previousState;
  }
  return {
    context: {
      buttonIndex: frameData?.buttonIndex,
      buttonValue,
      cycle: "main",
      deriveState,
      env,
      frameData,
      initialPath,
      inputText,
      previousButtonValues,
      previousState,
      req,
      res: (data) => ({ data, format: "frame" }),
      status,
      transactionId: frameData?.transactionId,
      url,
      var: context.var,
      verified
    },
    getState: () => previousState
  };
}

// node_modules/frog/_lib/utils/getRouteParameters.js
init_checked_fetch();
init_modules_watch_stub();
function getRouteParameters(...parameters) {
  const options = typeof parameters[parameters.length - 1] === "object" ? parameters[parameters.length - 1] : void 0;
  const middlewares = [];
  let handler;
  for (let i = parameters.length - (options ? 2 : 1); i > 0; i--) {
    if (!handler)
      handler = parameters[i];
    else
      middlewares.push(parameters[i]);
  }
  return [parameters[0], middlewares, handler, options ?? {}];
}

// node_modules/frog/_lib/utils/getTransactionContext.js
init_checked_fetch();
init_modules_watch_stub();
function getTransactionContext(parameters) {
  const { context } = parameters;
  const { env, frameData, initialPath, previousButtonValues, previousState, req, status, verified, url } = context || {};
  const { buttonValue, inputText } = getIntentState({
    buttonValues: previousButtonValues || [],
    frameData
  });
  return {
    context: {
      address: frameData?.address,
      buttonIndex: frameData?.buttonIndex,
      buttonValue,
      contract(parameters2) {
        const { abi, chainId, functionName, to, args, value } = parameters2;
        const abiItem = getAbiItem({
          abi,
          name: functionName,
          args
        });
        if (!abiItem)
          throw new AbiFunctionNotFoundError(functionName);
        const abiErrorItems = abi.filter((item) => item.type === "error");
        return this.send({
          abi: [abiItem, ...abiErrorItems],
          chainId,
          data: encodeFunctionData({
            abi,
            args,
            functionName
          }),
          to,
          value
        });
      },
      env,
      frameData,
      initialPath,
      inputText,
      previousButtonValues,
      previousState,
      req,
      res(parameters2) {
        const { chainId, method, params } = parameters2;
        const { abi, data, to, value } = params;
        const response = {
          chainId,
          method,
          params: {
            abi,
            data,
            to
          }
        };
        if (value)
          response.params.value = value.toString();
        return { data: response, format: "transaction" };
      },
      send(parameters2) {
        return this.res({
          chainId: parameters2.chainId,
          method: "eth_sendTransaction",
          params: parameters2
        });
      },
      status,
      var: context.var,
      verified,
      url
    }
  };
}

// node_modules/frog/_lib/utils/jws.js
init_checked_fetch();
init_modules_watch_stub();

// node_modules/jose/dist/browser/index.js
init_checked_fetch();
init_modules_watch_stub();

// node_modules/jose/dist/browser/jwe/compact/decrypt.js
init_checked_fetch();
init_modules_watch_stub();

// node_modules/jose/dist/browser/jwe/flattened/decrypt.js
init_checked_fetch();
init_modules_watch_stub();

// node_modules/jose/dist/browser/runtime/base64url.js
init_checked_fetch();
init_modules_watch_stub();

// node_modules/jose/dist/browser/lib/buffer_utils.js
init_checked_fetch();
init_modules_watch_stub();

// node_modules/jose/dist/browser/runtime/digest.js
init_checked_fetch();
init_modules_watch_stub();

// node_modules/jose/dist/browser/runtime/webcrypto.js
init_checked_fetch();
init_modules_watch_stub();
var webcrypto_default = crypto;
var isCryptoKey = (key) => key instanceof CryptoKey;

// node_modules/jose/dist/browser/lib/buffer_utils.js
var encoder3 = new TextEncoder();
var decoder = new TextDecoder();
var MAX_INT32 = 2 ** 32;
function concat2(...buffers2) {
  const size2 = buffers2.reduce((acc, { length }) => acc + length, 0);
  const buf = new Uint8Array(size2);
  let i = 0;
  for (const buffer of buffers2) {
    buf.set(buffer, i);
    i += buffer.length;
  }
  return buf;
}

// node_modules/jose/dist/browser/runtime/base64url.js
var encodeBase64 = (input) => {
  let unencoded = input;
  if (typeof unencoded === "string") {
    unencoded = encoder3.encode(unencoded);
  }
  const CHUNK_SIZE = 32768;
  const arr = [];
  for (let i = 0; i < unencoded.length; i += CHUNK_SIZE) {
    arr.push(String.fromCharCode.apply(null, unencoded.subarray(i, i + CHUNK_SIZE)));
  }
  return btoa(arr.join(""));
};
var encode = (input) => {
  return encodeBase64(input).replace(/=/g, "").replace(/\+/g, "-").replace(/\//g, "_");
};
var decodeBase64 = (encoded) => {
  const binary = atob(encoded);
  const bytes4 = new Uint8Array(binary.length);
  for (let i = 0; i < binary.length; i++) {
    bytes4[i] = binary.charCodeAt(i);
  }
  return bytes4;
};
var decode = (input) => {
  let encoded = input;
  if (encoded instanceof Uint8Array) {
    encoded = decoder.decode(encoded);
  }
  encoded = encoded.replace(/-/g, "+").replace(/_/g, "/").replace(/\s/g, "");
  try {
    return decodeBase64(encoded);
  } catch {
    throw new TypeError("The input to be decoded is not correctly encoded.");
  }
};

// node_modules/jose/dist/browser/runtime/decrypt.js
init_checked_fetch();
init_modules_watch_stub();

// node_modules/jose/dist/browser/lib/check_iv_length.js
init_checked_fetch();
init_modules_watch_stub();

// node_modules/jose/dist/browser/util/errors.js
init_checked_fetch();
init_modules_watch_stub();
var JOSEError = class extends Error {
  static get code() {
    return "ERR_JOSE_GENERIC";
  }
  constructor(message2) {
    super(message2);
    this.code = "ERR_JOSE_GENERIC";
    this.name = this.constructor.name;
    Error.captureStackTrace?.(this, this.constructor);
  }
};
var JOSEAlgNotAllowed = class extends JOSEError {
  constructor() {
    super(...arguments);
    this.code = "ERR_JOSE_ALG_NOT_ALLOWED";
  }
  static get code() {
    return "ERR_JOSE_ALG_NOT_ALLOWED";
  }
};
var JOSENotSupported = class extends JOSEError {
  constructor() {
    super(...arguments);
    this.code = "ERR_JOSE_NOT_SUPPORTED";
  }
  static get code() {
    return "ERR_JOSE_NOT_SUPPORTED";
  }
};
var JWSInvalid = class extends JOSEError {
  constructor() {
    super(...arguments);
    this.code = "ERR_JWS_INVALID";
  }
  static get code() {
    return "ERR_JWS_INVALID";
  }
};
var JWSSignatureVerificationFailed = class extends JOSEError {
  constructor() {
    super(...arguments);
    this.code = "ERR_JWS_SIGNATURE_VERIFICATION_FAILED";
    this.message = "signature verification failed";
  }
  static get code() {
    return "ERR_JWS_SIGNATURE_VERIFICATION_FAILED";
  }
};

// node_modules/jose/dist/browser/lib/iv.js
init_checked_fetch();
init_modules_watch_stub();

// node_modules/jose/dist/browser/runtime/random.js
init_checked_fetch();
init_modules_watch_stub();
var random_default = webcrypto_default.getRandomValues.bind(webcrypto_default);

// node_modules/jose/dist/browser/runtime/check_cek_length.js
init_checked_fetch();
init_modules_watch_stub();

// node_modules/jose/dist/browser/runtime/timing_safe_equal.js
init_checked_fetch();
init_modules_watch_stub();

// node_modules/jose/dist/browser/lib/crypto_key.js
init_checked_fetch();
init_modules_watch_stub();
function unusable(name, prop = "algorithm.name") {
  return new TypeError(`CryptoKey does not support this operation, its ${prop} must be ${name}`);
}
function isAlgorithm(algorithm, name) {
  return algorithm.name === name;
}
function getHashLength(hash2) {
  return parseInt(hash2.name.slice(4), 10);
}
function getNamedCurve(alg) {
  switch (alg) {
    case "ES256":
      return "P-256";
    case "ES384":
      return "P-384";
    case "ES512":
      return "P-521";
    default:
      throw new Error("unreachable");
  }
}
function checkUsage(key, usages) {
  if (usages.length && !usages.some((expected) => key.usages.includes(expected))) {
    let msg = "CryptoKey does not support this operation, its usages must include ";
    if (usages.length > 2) {
      const last = usages.pop();
      msg += `one of ${usages.join(", ")}, or ${last}.`;
    } else if (usages.length === 2) {
      msg += `one of ${usages[0]} or ${usages[1]}.`;
    } else {
      msg += `${usages[0]}.`;
    }
    throw new TypeError(msg);
  }
}
function checkSigCryptoKey(key, alg, ...usages) {
  switch (alg) {
    case "HS256":
    case "HS384":
    case "HS512": {
      if (!isAlgorithm(key.algorithm, "HMAC"))
        throw unusable("HMAC");
      const expected = parseInt(alg.slice(2), 10);
      const actual = getHashLength(key.algorithm.hash);
      if (actual !== expected)
        throw unusable(`SHA-${expected}`, "algorithm.hash");
      break;
    }
    case "RS256":
    case "RS384":
    case "RS512": {
      if (!isAlgorithm(key.algorithm, "RSASSA-PKCS1-v1_5"))
        throw unusable("RSASSA-PKCS1-v1_5");
      const expected = parseInt(alg.slice(2), 10);
      const actual = getHashLength(key.algorithm.hash);
      if (actual !== expected)
        throw unusable(`SHA-${expected}`, "algorithm.hash");
      break;
    }
    case "PS256":
    case "PS384":
    case "PS512": {
      if (!isAlgorithm(key.algorithm, "RSA-PSS"))
        throw unusable("RSA-PSS");
      const expected = parseInt(alg.slice(2), 10);
      const actual = getHashLength(key.algorithm.hash);
      if (actual !== expected)
        throw unusable(`SHA-${expected}`, "algorithm.hash");
      break;
    }
    case "EdDSA": {
      if (key.algorithm.name !== "Ed25519" && key.algorithm.name !== "Ed448") {
        throw unusable("Ed25519 or Ed448");
      }
      break;
    }
    case "ES256":
    case "ES384":
    case "ES512": {
      if (!isAlgorithm(key.algorithm, "ECDSA"))
        throw unusable("ECDSA");
      const expected = getNamedCurve(alg);
      const actual = key.algorithm.namedCurve;
      if (actual !== expected)
        throw unusable(expected, "algorithm.namedCurve");
      break;
    }
    default:
      throw new TypeError("CryptoKey does not support this operation");
  }
  checkUsage(key, usages);
}

// node_modules/jose/dist/browser/lib/invalid_key_input.js
init_checked_fetch();
init_modules_watch_stub();
function message(msg, actual, ...types2) {
  if (types2.length > 2) {
    const last = types2.pop();
    msg += `one of type ${types2.join(", ")}, or ${last}.`;
  } else if (types2.length === 2) {
    msg += `one of type ${types2[0]} or ${types2[1]}.`;
  } else {
    msg += `of type ${types2[0]}.`;
  }
  if (actual == null) {
    msg += ` Received ${actual}`;
  } else if (typeof actual === "function" && actual.name) {
    msg += ` Received function ${actual.name}`;
  } else if (typeof actual === "object" && actual != null) {
    if (actual.constructor?.name) {
      msg += ` Received an instance of ${actual.constructor.name}`;
    }
  }
  return msg;
}
var invalid_key_input_default = (actual, ...types2) => {
  return message("Key must be ", actual, ...types2);
};
function withAlg(alg, actual, ...types2) {
  return message(`Key for the ${alg} algorithm must be `, actual, ...types2);
}

// node_modules/jose/dist/browser/runtime/is_key_like.js
init_checked_fetch();
init_modules_watch_stub();
var is_key_like_default = (key) => {
  return isCryptoKey(key);
};
var types = ["CryptoKey"];

// node_modules/jose/dist/browser/lib/is_disjoint.js
init_checked_fetch();
init_modules_watch_stub();
var isDisjoint = (...headers) => {
  const sources = headers.filter(Boolean);
  if (sources.length === 0 || sources.length === 1) {
    return true;
  }
  let acc;
  for (const header of sources) {
    const parameters = Object.keys(header);
    if (!acc || acc.size === 0) {
      acc = new Set(parameters);
      continue;
    }
    for (const parameter of parameters) {
      if (acc.has(parameter)) {
        return false;
      }
      acc.add(parameter);
    }
  }
  return true;
};
var is_disjoint_default = isDisjoint;

// node_modules/jose/dist/browser/lib/is_object.js
init_checked_fetch();
init_modules_watch_stub();
function isObjectLike(value) {
  return typeof value === "object" && value !== null;
}
function isObject(input) {
  if (!isObjectLike(input) || Object.prototype.toString.call(input) !== "[object Object]") {
    return false;
  }
  if (Object.getPrototypeOf(input) === null) {
    return true;
  }
  let proto = input;
  while (Object.getPrototypeOf(proto) !== null) {
    proto = Object.getPrototypeOf(proto);
  }
  return Object.getPrototypeOf(input) === proto;
}

// node_modules/jose/dist/browser/lib/decrypt_key_management.js
init_checked_fetch();
init_modules_watch_stub();

// node_modules/jose/dist/browser/runtime/aeskw.js
init_checked_fetch();
init_modules_watch_stub();

// node_modules/jose/dist/browser/runtime/bogus.js
init_checked_fetch();
init_modules_watch_stub();

// node_modules/jose/dist/browser/runtime/ecdhes.js
init_checked_fetch();
init_modules_watch_stub();

// node_modules/jose/dist/browser/runtime/pbes2kw.js
init_checked_fetch();
init_modules_watch_stub();

// node_modules/jose/dist/browser/lib/check_p2s.js
init_checked_fetch();
init_modules_watch_stub();

// node_modules/jose/dist/browser/runtime/rsaes.js
init_checked_fetch();
init_modules_watch_stub();

// node_modules/jose/dist/browser/runtime/subtle_rsaes.js
init_checked_fetch();
init_modules_watch_stub();

// node_modules/jose/dist/browser/runtime/check_key_length.js
init_checked_fetch();
init_modules_watch_stub();
var check_key_length_default = (alg, key) => {
  if (alg.startsWith("RS") || alg.startsWith("PS")) {
    const { modulusLength } = key.algorithm;
    if (typeof modulusLength !== "number" || modulusLength < 2048) {
      throw new TypeError(`${alg} requires key modulusLength to be 2048 bits or larger`);
    }
  }
};

// node_modules/jose/dist/browser/lib/cek.js
init_checked_fetch();
init_modules_watch_stub();

// node_modules/jose/dist/browser/key/import.js
init_checked_fetch();
init_modules_watch_stub();

// node_modules/jose/dist/browser/runtime/asn1.js
init_checked_fetch();
init_modules_watch_stub();

// node_modules/jose/dist/browser/lib/format_pem.js
init_checked_fetch();
init_modules_watch_stub();

// node_modules/jose/dist/browser/runtime/jwk_to_key.js
init_checked_fetch();
init_modules_watch_stub();

// node_modules/jose/dist/browser/lib/check_key_type.js
init_checked_fetch();
init_modules_watch_stub();
var symmetricTypeCheck = (alg, key) => {
  if (key instanceof Uint8Array)
    return;
  if (!is_key_like_default(key)) {
    throw new TypeError(withAlg(alg, key, ...types, "Uint8Array"));
  }
  if (key.type !== "secret") {
    throw new TypeError(`${types.join(" or ")} instances for symmetric algorithms must be of type "secret"`);
  }
};
var asymmetricTypeCheck = (alg, key, usage) => {
  if (!is_key_like_default(key)) {
    throw new TypeError(withAlg(alg, key, ...types));
  }
  if (key.type === "secret") {
    throw new TypeError(`${types.join(" or ")} instances for asymmetric algorithms must not be of type "secret"`);
  }
  if (usage === "sign" && key.type === "public") {
    throw new TypeError(`${types.join(" or ")} instances for asymmetric algorithm signing must be of type "private"`);
  }
  if (usage === "decrypt" && key.type === "public") {
    throw new TypeError(`${types.join(" or ")} instances for asymmetric algorithm decryption must be of type "private"`);
  }
  if (key.algorithm && usage === "verify" && key.type === "private") {
    throw new TypeError(`${types.join(" or ")} instances for asymmetric algorithm verifying must be of type "public"`);
  }
  if (key.algorithm && usage === "encrypt" && key.type === "private") {
    throw new TypeError(`${types.join(" or ")} instances for asymmetric algorithm encryption must be of type "public"`);
  }
};
var checkKeyType = (alg, key, usage) => {
  const symmetric = alg.startsWith("HS") || alg === "dir" || alg.startsWith("PBES2") || /^A\d{3}(?:GCM)?KW$/.test(alg);
  if (symmetric) {
    symmetricTypeCheck(alg, key);
  } else {
    asymmetricTypeCheck(alg, key, usage);
  }
};
var check_key_type_default = checkKeyType;

// node_modules/jose/dist/browser/lib/aesgcmkw.js
init_checked_fetch();
init_modules_watch_stub();

// node_modules/jose/dist/browser/runtime/encrypt.js
init_checked_fetch();
init_modules_watch_stub();

// node_modules/jose/dist/browser/lib/validate_crit.js
init_checked_fetch();
init_modules_watch_stub();
function validateCrit(Err, recognizedDefault, recognizedOption, protectedHeader, joseHeader) {
  if (joseHeader.crit !== void 0 && protectedHeader.crit === void 0) {
    throw new Err('"crit" (Critical) Header Parameter MUST be integrity protected');
  }
  if (!protectedHeader || protectedHeader.crit === void 0) {
    return /* @__PURE__ */ new Set();
  }
  if (!Array.isArray(protectedHeader.crit) || protectedHeader.crit.length === 0 || protectedHeader.crit.some((input) => typeof input !== "string" || input.length === 0)) {
    throw new Err('"crit" (Critical) Header Parameter MUST be an array of non-empty strings when present');
  }
  let recognized;
  if (recognizedOption !== void 0) {
    recognized = new Map([...Object.entries(recognizedOption), ...recognizedDefault.entries()]);
  } else {
    recognized = recognizedDefault;
  }
  for (const parameter of protectedHeader.crit) {
    if (!recognized.has(parameter)) {
      throw new JOSENotSupported(`Extension Header Parameter "${parameter}" is not recognized`);
    }
    if (joseHeader[parameter] === void 0) {
      throw new Err(`Extension Header Parameter "${parameter}" is missing`);
    }
    if (recognized.get(parameter) && protectedHeader[parameter] === void 0) {
      throw new Err(`Extension Header Parameter "${parameter}" MUST be integrity protected`);
    }
  }
  return new Set(protectedHeader.crit);
}
var validate_crit_default = validateCrit;

// node_modules/jose/dist/browser/lib/validate_algorithms.js
init_checked_fetch();
init_modules_watch_stub();
var validateAlgorithms = (option, algorithms) => {
  if (algorithms !== void 0 && (!Array.isArray(algorithms) || algorithms.some((s) => typeof s !== "string"))) {
    throw new TypeError(`"${option}" option must be an array of strings`);
  }
  if (!algorithms) {
    return void 0;
  }
  return new Set(algorithms);
};
var validate_algorithms_default = validateAlgorithms;

// node_modules/jose/dist/browser/jwe/general/decrypt.js
init_checked_fetch();
init_modules_watch_stub();

// node_modules/jose/dist/browser/jwe/general/encrypt.js
init_checked_fetch();
init_modules_watch_stub();

// node_modules/jose/dist/browser/jwe/flattened/encrypt.js
init_checked_fetch();
init_modules_watch_stub();

// node_modules/jose/dist/browser/lib/encrypt_key_management.js
init_checked_fetch();
init_modules_watch_stub();

// node_modules/jose/dist/browser/key/export.js
init_checked_fetch();
init_modules_watch_stub();

// node_modules/jose/dist/browser/runtime/key_to_jwk.js
init_checked_fetch();
init_modules_watch_stub();

// node_modules/jose/dist/browser/jwe/flattened/encrypt.js
var unprotected = Symbol();

// node_modules/jose/dist/browser/jws/compact/verify.js
init_checked_fetch();
init_modules_watch_stub();

// node_modules/jose/dist/browser/jws/flattened/verify.js
init_checked_fetch();
init_modules_watch_stub();

// node_modules/jose/dist/browser/runtime/verify.js
init_checked_fetch();
init_modules_watch_stub();

// node_modules/jose/dist/browser/runtime/subtle_dsa.js
init_checked_fetch();
init_modules_watch_stub();
function subtleDsa(alg, algorithm) {
  const hash2 = `SHA-${alg.slice(-3)}`;
  switch (alg) {
    case "HS256":
    case "HS384":
    case "HS512":
      return { hash: hash2, name: "HMAC" };
    case "PS256":
    case "PS384":
    case "PS512":
      return { hash: hash2, name: "RSA-PSS", saltLength: alg.slice(-3) >> 3 };
    case "RS256":
    case "RS384":
    case "RS512":
      return { hash: hash2, name: "RSASSA-PKCS1-v1_5" };
    case "ES256":
    case "ES384":
    case "ES512":
      return { hash: hash2, name: "ECDSA", namedCurve: algorithm.namedCurve };
    case "EdDSA":
      return { name: algorithm.name };
    default:
      throw new JOSENotSupported(`alg ${alg} is not supported either by JOSE or your javascript runtime`);
  }
}

// node_modules/jose/dist/browser/runtime/get_sign_verify_key.js
init_checked_fetch();
init_modules_watch_stub();
function getCryptoKey(alg, key, usage) {
  if (isCryptoKey(key)) {
    checkSigCryptoKey(key, alg, usage);
    return key;
  }
  if (key instanceof Uint8Array) {
    if (!alg.startsWith("HS")) {
      throw new TypeError(invalid_key_input_default(key, ...types));
    }
    return webcrypto_default.subtle.importKey("raw", key, { hash: `SHA-${alg.slice(-3)}`, name: "HMAC" }, false, [usage]);
  }
  throw new TypeError(invalid_key_input_default(key, ...types, "Uint8Array"));
}

// node_modules/jose/dist/browser/runtime/verify.js
var verify = async (alg, key, signature, data) => {
  const cryptoKey = await getCryptoKey(alg, key, "verify");
  check_key_length_default(alg, cryptoKey);
  const algorithm = subtleDsa(alg, cryptoKey.algorithm);
  try {
    return await webcrypto_default.subtle.verify(algorithm, cryptoKey, signature, data);
  } catch {
    return false;
  }
};
var verify_default = verify;

// node_modules/jose/dist/browser/jws/flattened/verify.js
async function flattenedVerify(jws, key, options) {
  if (!isObject(jws)) {
    throw new JWSInvalid("Flattened JWS must be an object");
  }
  if (jws.protected === void 0 && jws.header === void 0) {
    throw new JWSInvalid('Flattened JWS must have either of the "protected" or "header" members');
  }
  if (jws.protected !== void 0 && typeof jws.protected !== "string") {
    throw new JWSInvalid("JWS Protected Header incorrect type");
  }
  if (jws.payload === void 0) {
    throw new JWSInvalid("JWS Payload missing");
  }
  if (typeof jws.signature !== "string") {
    throw new JWSInvalid("JWS Signature missing or incorrect type");
  }
  if (jws.header !== void 0 && !isObject(jws.header)) {
    throw new JWSInvalid("JWS Unprotected Header incorrect type");
  }
  let parsedProt = {};
  if (jws.protected) {
    try {
      const protectedHeader = decode(jws.protected);
      parsedProt = JSON.parse(decoder.decode(protectedHeader));
    } catch {
      throw new JWSInvalid("JWS Protected Header is invalid");
    }
  }
  if (!is_disjoint_default(parsedProt, jws.header)) {
    throw new JWSInvalid("JWS Protected and JWS Unprotected Header Parameter names must be disjoint");
  }
  const joseHeader = {
    ...parsedProt,
    ...jws.header
  };
  const extensions = validate_crit_default(JWSInvalid, /* @__PURE__ */ new Map([["b64", true]]), options?.crit, parsedProt, joseHeader);
  let b64 = true;
  if (extensions.has("b64")) {
    b64 = parsedProt.b64;
    if (typeof b64 !== "boolean") {
      throw new JWSInvalid('The "b64" (base64url-encode payload) Header Parameter must be a boolean');
    }
  }
  const { alg } = joseHeader;
  if (typeof alg !== "string" || !alg) {
    throw new JWSInvalid('JWS "alg" (Algorithm) Header Parameter missing or invalid');
  }
  const algorithms = options && validate_algorithms_default("algorithms", options.algorithms);
  if (algorithms && !algorithms.has(alg)) {
    throw new JOSEAlgNotAllowed('"alg" (Algorithm) Header Parameter value not allowed');
  }
  if (b64) {
    if (typeof jws.payload !== "string") {
      throw new JWSInvalid("JWS Payload must be a string");
    }
  } else if (typeof jws.payload !== "string" && !(jws.payload instanceof Uint8Array)) {
    throw new JWSInvalid("JWS Payload must be a string or an Uint8Array instance");
  }
  let resolvedKey = false;
  if (typeof key === "function") {
    key = await key(parsedProt, jws);
    resolvedKey = true;
  }
  check_key_type_default(alg, key, "verify");
  const data = concat2(encoder3.encode(jws.protected ?? ""), encoder3.encode("."), typeof jws.payload === "string" ? encoder3.encode(jws.payload) : jws.payload);
  let signature;
  try {
    signature = decode(jws.signature);
  } catch {
    throw new JWSInvalid("Failed to base64url decode the signature");
  }
  const verified = await verify_default(alg, key, signature, data);
  if (!verified) {
    throw new JWSSignatureVerificationFailed();
  }
  let payload;
  if (b64) {
    try {
      payload = decode(jws.payload);
    } catch {
      throw new JWSInvalid("Failed to base64url decode the payload");
    }
  } else if (typeof jws.payload === "string") {
    payload = encoder3.encode(jws.payload);
  } else {
    payload = jws.payload;
  }
  const result = { payload };
  if (jws.protected !== void 0) {
    result.protectedHeader = parsedProt;
  }
  if (jws.header !== void 0) {
    result.unprotectedHeader = jws.header;
  }
  if (resolvedKey) {
    return { ...result, key };
  }
  return result;
}

// node_modules/jose/dist/browser/jws/compact/verify.js
async function compactVerify(jws, key, options) {
  if (jws instanceof Uint8Array) {
    jws = decoder.decode(jws);
  }
  if (typeof jws !== "string") {
    throw new JWSInvalid("Compact JWS must be a string or Uint8Array");
  }
  const { 0: protectedHeader, 1: payload, 2: signature, length } = jws.split(".");
  if (length !== 3) {
    throw new JWSInvalid("Invalid Compact JWS");
  }
  const verified = await flattenedVerify({ payload, protected: protectedHeader, signature }, key, options);
  const result = { payload: verified.payload, protectedHeader: verified.protectedHeader };
  if (typeof key === "function") {
    return { ...result, key: verified.key };
  }
  return result;
}

// node_modules/jose/dist/browser/jws/general/verify.js
init_checked_fetch();
init_modules_watch_stub();

// node_modules/jose/dist/browser/jwt/verify.js
init_checked_fetch();
init_modules_watch_stub();

// node_modules/jose/dist/browser/lib/jwt_claims_set.js
init_checked_fetch();
init_modules_watch_stub();

// node_modules/jose/dist/browser/lib/epoch.js
init_checked_fetch();
init_modules_watch_stub();

// node_modules/jose/dist/browser/lib/secs.js
init_checked_fetch();
init_modules_watch_stub();
var minute = 60;
var hour = minute * 60;
var day = hour * 24;
var week = day * 7;
var year = day * 365.25;

// node_modules/jose/dist/browser/jwt/decrypt.js
init_checked_fetch();
init_modules_watch_stub();

// node_modules/jose/dist/browser/jwe/compact/encrypt.js
init_checked_fetch();
init_modules_watch_stub();

// node_modules/jose/dist/browser/jws/compact/sign.js
init_checked_fetch();
init_modules_watch_stub();

// node_modules/jose/dist/browser/jws/flattened/sign.js
init_checked_fetch();
init_modules_watch_stub();

// node_modules/jose/dist/browser/runtime/sign.js
init_checked_fetch();
init_modules_watch_stub();
var sign = async (alg, key, data) => {
  const cryptoKey = await getCryptoKey(alg, key, "sign");
  check_key_length_default(alg, cryptoKey);
  const signature = await webcrypto_default.subtle.sign(subtleDsa(alg, cryptoKey.algorithm), cryptoKey, data);
  return new Uint8Array(signature);
};
var sign_default = sign;

// node_modules/jose/dist/browser/jws/flattened/sign.js
var FlattenedSign = class {
  constructor(payload) {
    if (!(payload instanceof Uint8Array)) {
      throw new TypeError("payload must be an instance of Uint8Array");
    }
    this._payload = payload;
  }
  setProtectedHeader(protectedHeader) {
    if (this._protectedHeader) {
      throw new TypeError("setProtectedHeader can only be called once");
    }
    this._protectedHeader = protectedHeader;
    return this;
  }
  setUnprotectedHeader(unprotectedHeader) {
    if (this._unprotectedHeader) {
      throw new TypeError("setUnprotectedHeader can only be called once");
    }
    this._unprotectedHeader = unprotectedHeader;
    return this;
  }
  async sign(key, options) {
    if (!this._protectedHeader && !this._unprotectedHeader) {
      throw new JWSInvalid("either setProtectedHeader or setUnprotectedHeader must be called before #sign()");
    }
    if (!is_disjoint_default(this._protectedHeader, this._unprotectedHeader)) {
      throw new JWSInvalid("JWS Protected and JWS Unprotected Header Parameter names must be disjoint");
    }
    const joseHeader = {
      ...this._protectedHeader,
      ...this._unprotectedHeader
    };
    const extensions = validate_crit_default(JWSInvalid, /* @__PURE__ */ new Map([["b64", true]]), options?.crit, this._protectedHeader, joseHeader);
    let b64 = true;
    if (extensions.has("b64")) {
      b64 = this._protectedHeader.b64;
      if (typeof b64 !== "boolean") {
        throw new JWSInvalid('The "b64" (base64url-encode payload) Header Parameter must be a boolean');
      }
    }
    const { alg } = joseHeader;
    if (typeof alg !== "string" || !alg) {
      throw new JWSInvalid('JWS "alg" (Algorithm) Header Parameter missing or invalid');
    }
    check_key_type_default(alg, key, "sign");
    let payload = this._payload;
    if (b64) {
      payload = encoder3.encode(encode(payload));
    }
    let protectedHeader;
    if (this._protectedHeader) {
      protectedHeader = encoder3.encode(encode(JSON.stringify(this._protectedHeader)));
    } else {
      protectedHeader = encoder3.encode("");
    }
    const data = concat2(protectedHeader, encoder3.encode("."), payload);
    const signature = await sign_default(alg, key, data);
    const jws = {
      signature: encode(signature),
      payload: ""
    };
    if (b64) {
      jws.payload = decoder.decode(payload);
    }
    if (this._unprotectedHeader) {
      jws.header = this._unprotectedHeader;
    }
    if (this._protectedHeader) {
      jws.protected = decoder.decode(protectedHeader);
    }
    return jws;
  }
};

// node_modules/jose/dist/browser/jws/compact/sign.js
var CompactSign = class {
  constructor(payload) {
    this._flattened = new FlattenedSign(payload);
  }
  setProtectedHeader(protectedHeader) {
    this._flattened.setProtectedHeader(protectedHeader);
    return this;
  }
  async sign(key, options) {
    const jws = await this._flattened.sign(key, options);
    if (jws.payload === void 0) {
      throw new TypeError("use the flattened module for creating JWS with b64: false");
    }
    return `${jws.protected}.${jws.payload}.${jws.signature}`;
  }
};

// node_modules/jose/dist/browser/jws/general/sign.js
init_checked_fetch();
init_modules_watch_stub();

// node_modules/jose/dist/browser/jwt/sign.js
init_checked_fetch();
init_modules_watch_stub();

// node_modules/jose/dist/browser/jwt/produce.js
init_checked_fetch();
init_modules_watch_stub();

// node_modules/jose/dist/browser/jwt/encrypt.js
init_checked_fetch();
init_modules_watch_stub();

// node_modules/jose/dist/browser/jwk/thumbprint.js
init_checked_fetch();
init_modules_watch_stub();

// node_modules/jose/dist/browser/jwk/embedded.js
init_checked_fetch();
init_modules_watch_stub();

// node_modules/jose/dist/browser/jwks/local.js
init_checked_fetch();
init_modules_watch_stub();

// node_modules/jose/dist/browser/jwks/remote.js
init_checked_fetch();
init_modules_watch_stub();

// node_modules/jose/dist/browser/runtime/fetch_jwks.js
init_checked_fetch();
init_modules_watch_stub();

// node_modules/jose/dist/browser/jwks/remote.js
var USER_AGENT;
if (typeof navigator === "undefined" || !"Cloudflare-Workers"?.startsWith?.("Mozilla/5.0 ")) {
  const NAME = "jose";
  const VERSION = "v5.2.2";
  USER_AGENT = `${NAME}/${VERSION}`;
}

// node_modules/jose/dist/browser/jwt/unsecured.js
init_checked_fetch();
init_modules_watch_stub();

// node_modules/jose/dist/browser/util/decode_protected_header.js
init_checked_fetch();
init_modules_watch_stub();

// node_modules/jose/dist/browser/util/base64url.js
init_checked_fetch();
init_modules_watch_stub();

// node_modules/jose/dist/browser/util/decode_jwt.js
init_checked_fetch();
init_modules_watch_stub();

// node_modules/jose/dist/browser/key/generate_key_pair.js
init_checked_fetch();
init_modules_watch_stub();

// node_modules/jose/dist/browser/runtime/generate.js
init_checked_fetch();
init_modules_watch_stub();

// node_modules/jose/dist/browser/key/generate_secret.js
init_checked_fetch();
init_modules_watch_stub();

// node_modules/jose/dist/browser/util/runtime.js
init_checked_fetch();
init_modules_watch_stub();

// node_modules/jose/dist/browser/runtime/runtime.js
init_checked_fetch();
init_modules_watch_stub();

// node_modules/frog/_lib/utils/jws.js
var decoder2 = new TextDecoder();
var encoder4 = new TextEncoder();
async function verify2(signature, secret) {
  const { payload } = await compactVerify(signature, encoder4.encode(secret));
  return decoder2.decode(payload);
}
async function sign2(message2, secret) {
  return new CompactSign(encoder4.encode(message2)).setProtectedHeader({ alg: "HS256" }).sign(encoder4.encode(secret));
}

// node_modules/frog/_lib/utils/parseBrowserLocation.js
init_checked_fetch();
init_modules_watch_stub();
function parseBrowserLocation(c, location_, { basePath, path }) {
  let location = location_ || "";
  if (location?.includes(":path") && !path.includes(":path"))
    location = location.replace(":path", path.replace(/(^\/)|(\/$)/, ""));
  else if (location?.includes(":"))
    for (const [key, value] of Object.entries(c.req.param()))
      location = location.replace(`:${key}`, value);
  if (location.includes(":basePath"))
    location = location.replace(":basePath", basePath.replace(/(^\/)|(\/$)/, ""));
  location = location.replace(/^\/\//, "/");
  return location;
}

// node_modules/frog/_lib/utils/parseFonts.js
init_checked_fetch();
init_modules_watch_stub();
async function parseFonts(fonts) {
  if (!fonts)
    return void 0;
  return await Promise.all(fonts.map(async (font) => {
    if (font.source === "google")
      return {
        ...font,
        data: await loadGoogleFont({
          family: font.name,
          weight: font.weight
        })
      };
    return font;
  }));
}

// node_modules/frog/_lib/utils/parseImage.js
init_checked_fetch();
init_modules_watch_stub();
async function parseImage(node_, { assetsUrl }) {
  if (typeof node_ !== "object")
    return node_;
  if (Array.isArray(node_))
    return await Promise.all(node_.map(async (e) => await parseImage(e, { assetsUrl })));
  if (node_ instanceof Promise)
    return await node_;
  let node = node_;
  if (typeof node.tag === "function") {
    node = await node.tag({
      ...node.props,
      children: node.children
    });
    node = await parseImage(node, { assetsUrl });
  }
  if (node.children)
    node.children = await Promise.all(node.children.map(async (e) => await parseImage(e, { assetsUrl })));
  if (node.tag === "img") {
    const src = node.props.src;
    if (src.startsWith("/"))
      node.props.src = `${assetsUrl + parsePath(src)}`;
  }
  return node;
}

// node_modules/frog/_lib/utils/parseIntents.js
init_checked_fetch();
init_modules_watch_stub();
function parseIntents(intents_, options = {}, counter = { button: 1 }) {
  if (!intents_)
    return [];
  const nodes = intents_;
  const intents = (() => {
    if (Array.isArray(nodes))
      return nodes.map((e) => parseIntent(e, options, counter));
    if (typeof nodes.children[0] === "object")
      return Object.assign(nodes, {
        children: nodes.children.map((e) => parseIntent(e, options, counter))
      });
    return parseIntent(nodes, options, counter);
  })();
  return (Array.isArray(intents) ? intents : [intents]).flat();
}
function parseIntent(node_, options, counter) {
  const node = !node_ ? { children: [], props: {}, tag() {
  } } : node_;
  const props = (() => {
    if (node.tag.__type === "button") {
      const buttonProps = {
        ...node.props,
        action: node.props.action ? node.props.action.startsWith("http") ? node.props.action : parsePath(options.baseUrl + node.props.action) + (options.search ? `?${options.search}` : "") : void 0,
        children: node.children,
        index: counter.button++
      };
      const value = node.tag({})?.[0]?.props?.["data-value"];
      if (value?.startsWith(buttonPrefix.transaction) && node.props.target) {
        const search = (node.props.target ?? "").split("?")[1];
        buttonProps.target = node.props.target?.startsWith("http") ? node.props.target : parsePath(options.baseUrl + node.props.target) + (search ? `?${search}` : "");
      }
      return buttonProps;
    }
    if (node.tag.__type === "text-input")
      return { ...node.props, children: node.children };
    return {};
  })();
  const intent = typeof node.tag === "function" ? node.tag(props) : node;
  if (intent?.tag === "" && Object.keys(intent.props).length === 0)
    throw new InvalidIntentComponentError();
  if (typeof intent?.tag === "function" && typeof node.tag === "function") {
    if (intent.children.length > 1)
      throw new InvalidIntentComponentError();
    return parseIntent(node.tag(node.props), options, counter);
  }
  return intent;
}
var InvalidIntentComponentError = class extends Error {
  constructor() {
    super([
      "Intent components must return a single intent element.",
      "",
      "Example:",
      "",
      "```",
      "import { Button } from 'frog'",
      "",
      "function CustomIntent() {",
      "  return <Button>Foo</Button>",
      "}",
      "```"
    ].join("\n"));
  }
};

// node_modules/frog/_lib/utils/requestBodyToContext.js
init_checked_fetch();
init_modules_watch_stub();

// node_modules/frog/_lib/utils/deserializeJson.js
init_checked_fetch();
init_modules_watch_stub();
function deserializeJson(data = "{}") {
  if (data === "undefined")
    return {};
  return JSON.parse(decodeURIComponent(data));
}

// node_modules/frog/_lib/utils/verifyFrame.js
init_checked_fetch();
init_modules_watch_stub();

// node_modules/frog/_lib/protobufs/generated/message_pb.js
init_checked_fetch();
init_modules_watch_stub();

// node_modules/@bufbuild/protobuf/dist/esm/index.js
init_checked_fetch();
init_modules_watch_stub();

// node_modules/@bufbuild/protobuf/dist/esm/proto3.js
init_checked_fetch();
init_modules_watch_stub();

// node_modules/@bufbuild/protobuf/dist/esm/private/proto-runtime.js
init_checked_fetch();
init_modules_watch_stub();

// node_modules/@bufbuild/protobuf/dist/esm/private/enum.js
init_checked_fetch();
init_modules_watch_stub();

// node_modules/@bufbuild/protobuf/dist/esm/private/assert.js
init_checked_fetch();
init_modules_watch_stub();
function assert(condition, msg) {
  if (!condition) {
    throw new Error(msg);
  }
}
var FLOAT32_MAX = 34028234663852886e22;
var FLOAT32_MIN = -34028234663852886e22;
var UINT32_MAX = 4294967295;
var INT32_MAX = 2147483647;
var INT32_MIN = -2147483648;
function assertInt32(arg) {
  if (typeof arg !== "number")
    throw new Error("invalid int 32: " + typeof arg);
  if (!Number.isInteger(arg) || arg > INT32_MAX || arg < INT32_MIN)
    throw new Error("invalid int 32: " + arg);
}
function assertUInt32(arg) {
  if (typeof arg !== "number")
    throw new Error("invalid uint 32: " + typeof arg);
  if (!Number.isInteger(arg) || arg > UINT32_MAX || arg < 0)
    throw new Error("invalid uint 32: " + arg);
}
function assertFloat32(arg) {
  if (typeof arg !== "number")
    throw new Error("invalid float 32: " + typeof arg);
  if (!Number.isFinite(arg))
    return;
  if (arg > FLOAT32_MAX || arg < FLOAT32_MIN)
    throw new Error("invalid float 32: " + arg);
}

// node_modules/@bufbuild/protobuf/dist/esm/private/enum.js
var enumTypeSymbol = Symbol("@bufbuild/protobuf/enum-type");
function getEnumType(enumObject) {
  const t = enumObject[enumTypeSymbol];
  assert(t, "missing enum type on enum object");
  return t;
}
function setEnumType(enumObject, typeName, values, opt) {
  enumObject[enumTypeSymbol] = makeEnumType(typeName, values.map((v) => ({
    no: v.no,
    name: v.name,
    localName: enumObject[v.no]
  })), opt);
}
function makeEnumType(typeName, values, _opt) {
  const names = /* @__PURE__ */ Object.create(null);
  const numbers = /* @__PURE__ */ Object.create(null);
  const normalValues = [];
  for (const value of values) {
    const n = normalizeEnumValue(value);
    normalValues.push(n);
    names[value.name] = n;
    numbers[value.no] = n;
  }
  return {
    typeName,
    values: normalValues,
    // We do not surface options at this time
    // options: opt?.options ?? Object.create(null),
    findName(name) {
      return names[name];
    },
    findNumber(no) {
      return numbers[no];
    }
  };
}
function makeEnum(typeName, values, opt) {
  const enumObject = {};
  for (const value of values) {
    const n = normalizeEnumValue(value);
    enumObject[n.localName] = n.no;
    enumObject[n.no] = n.localName;
  }
  setEnumType(enumObject, typeName, values, opt);
  return enumObject;
}
function normalizeEnumValue(value) {
  if ("localName" in value) {
    return value;
  }
  return Object.assign(Object.assign({}, value), { localName: value.name });
}

// node_modules/@bufbuild/protobuf/dist/esm/private/message-type.js
init_checked_fetch();
init_modules_watch_stub();

// node_modules/@bufbuild/protobuf/dist/esm/message.js
init_checked_fetch();
init_modules_watch_stub();
var Message = class {
  /**
   * Compare with a message of the same type.
   */
  equals(other) {
    return this.getType().runtime.util.equals(this.getType(), this, other);
  }
  /**
   * Create a deep copy.
   */
  clone() {
    return this.getType().runtime.util.clone(this);
  }
  /**
   * Parse from binary data, merging fields.
   *
   * Repeated fields are appended. Map entries are added, overwriting
   * existing keys.
   *
   * If a message field is already present, it will be merged with the
   * new data.
   */
  fromBinary(bytes4, options) {
    const type = this.getType(), format = type.runtime.bin, opt = format.makeReadOptions(options);
    format.readMessage(this, opt.readerFactory(bytes4), bytes4.byteLength, opt);
    return this;
  }
  /**
   * Parse a message from a JSON value.
   */
  fromJson(jsonValue, options) {
    const type = this.getType(), format = type.runtime.json, opt = format.makeReadOptions(options);
    format.readMessage(type, jsonValue, opt, this);
    return this;
  }
  /**
   * Parse a message from a JSON string.
   */
  fromJsonString(jsonString, options) {
    let json;
    try {
      json = JSON.parse(jsonString);
    } catch (e) {
      throw new Error(`cannot decode ${this.getType().typeName} from JSON: ${e instanceof Error ? e.message : String(e)}`);
    }
    return this.fromJson(json, options);
  }
  /**
   * Serialize the message to binary data.
   */
  toBinary(options) {
    const type = this.getType(), bin = type.runtime.bin, opt = bin.makeWriteOptions(options), writer = opt.writerFactory();
    bin.writeMessage(this, writer, opt);
    return writer.finish();
  }
  /**
   * Serialize the message to a JSON value, a JavaScript value that can be
   * passed to JSON.stringify().
   */
  toJson(options) {
    const type = this.getType(), json = type.runtime.json, opt = json.makeWriteOptions(options);
    return json.writeMessage(this, opt);
  }
  /**
   * Serialize the message to a JSON string.
   */
  toJsonString(options) {
    var _a2;
    const value = this.toJson(options);
    return JSON.stringify(value, null, (_a2 = options === null || options === void 0 ? void 0 : options.prettySpaces) !== null && _a2 !== void 0 ? _a2 : 0);
  }
  /**
   * Override for serialization behavior. This will be invoked when calling
   * JSON.stringify on this message (i.e. JSON.stringify(msg)).
   *
   * Note that this will not serialize google.protobuf.Any with a packed
   * message because the protobuf JSON format specifies that it needs to be
   * unpacked, and this is only possible with a type registry to look up the
   * message type.  As a result, attempting to serialize a message with this
   * type will throw an Error.
   *
   * This method is protected because you should not need to invoke it
   * directly -- instead use JSON.stringify or toJsonString for
   * stringified JSON.  Alternatively, if actual JSON is desired, you should
   * use toJson.
   */
  toJSON() {
    return this.toJson({
      emitDefaultValues: true
    });
  }
  /**
   * Retrieve the MessageType of this message - a singleton that represents
   * the protobuf message declaration and provides metadata for reflection-
   * based operations.
   */
  getType() {
    return Object.getPrototypeOf(this).constructor;
  }
};

// node_modules/@bufbuild/protobuf/dist/esm/private/message-type.js
function makeMessageType(runtime, typeName, fields, opt) {
  var _a2;
  const localName = (_a2 = opt === null || opt === void 0 ? void 0 : opt.localName) !== null && _a2 !== void 0 ? _a2 : typeName.substring(typeName.lastIndexOf(".") + 1);
  const type = {
    [localName]: function(data) {
      runtime.util.initFields(this);
      runtime.util.initPartial(data, this);
    }
  }[localName];
  Object.setPrototypeOf(type.prototype, new Message());
  Object.assign(type, {
    runtime,
    typeName,
    fields: runtime.util.newFieldList(fields),
    fromBinary(bytes4, options) {
      return new type().fromBinary(bytes4, options);
    },
    fromJson(jsonValue, options) {
      return new type().fromJson(jsonValue, options);
    },
    fromJsonString(jsonString, options) {
      return new type().fromJsonString(jsonString, options);
    },
    equals(a, b) {
      return runtime.util.equals(type, a, b);
    }
  });
  return type;
}

// node_modules/@bufbuild/protobuf/dist/esm/private/extensions.js
init_checked_fetch();
init_modules_watch_stub();

// node_modules/@bufbuild/protobuf/dist/esm/private/scalars.js
init_checked_fetch();
init_modules_watch_stub();

// node_modules/@bufbuild/protobuf/dist/esm/proto-int64.js
init_checked_fetch();
init_modules_watch_stub();

// node_modules/@bufbuild/protobuf/dist/esm/google/varint.js
init_checked_fetch();
init_modules_watch_stub();
function varint64read() {
  let lowBits = 0;
  let highBits = 0;
  for (let shift = 0; shift < 28; shift += 7) {
    let b = this.buf[this.pos++];
    lowBits |= (b & 127) << shift;
    if ((b & 128) == 0) {
      this.assertBounds();
      return [lowBits, highBits];
    }
  }
  let middleByte = this.buf[this.pos++];
  lowBits |= (middleByte & 15) << 28;
  highBits = (middleByte & 112) >> 4;
  if ((middleByte & 128) == 0) {
    this.assertBounds();
    return [lowBits, highBits];
  }
  for (let shift = 3; shift <= 31; shift += 7) {
    let b = this.buf[this.pos++];
    highBits |= (b & 127) << shift;
    if ((b & 128) == 0) {
      this.assertBounds();
      return [lowBits, highBits];
    }
  }
  throw new Error("invalid varint");
}
function varint64write(lo2, hi, bytes4) {
  for (let i = 0; i < 28; i = i + 7) {
    const shift = lo2 >>> i;
    const hasNext = !(shift >>> 7 == 0 && hi == 0);
    const byte = (hasNext ? shift | 128 : shift) & 255;
    bytes4.push(byte);
    if (!hasNext) {
      return;
    }
  }
  const splitBits = lo2 >>> 28 & 15 | (hi & 7) << 4;
  const hasMoreBits = !(hi >> 3 == 0);
  bytes4.push((hasMoreBits ? splitBits | 128 : splitBits) & 255);
  if (!hasMoreBits) {
    return;
  }
  for (let i = 3; i < 31; i = i + 7) {
    const shift = hi >>> i;
    const hasNext = !(shift >>> 7 == 0);
    const byte = (hasNext ? shift | 128 : shift) & 255;
    bytes4.push(byte);
    if (!hasNext) {
      return;
    }
  }
  bytes4.push(hi >>> 31 & 1);
}
var TWO_PWR_32_DBL = 4294967296;
function int64FromString(dec) {
  const minus = dec[0] === "-";
  if (minus) {
    dec = dec.slice(1);
  }
  const base = 1e6;
  let lowBits = 0;
  let highBits = 0;
  function add1e6digit(begin, end) {
    const digit1e6 = Number(dec.slice(begin, end));
    highBits *= base;
    lowBits = lowBits * base + digit1e6;
    if (lowBits >= TWO_PWR_32_DBL) {
      highBits = highBits + (lowBits / TWO_PWR_32_DBL | 0);
      lowBits = lowBits % TWO_PWR_32_DBL;
    }
  }
  add1e6digit(-24, -18);
  add1e6digit(-18, -12);
  add1e6digit(-12, -6);
  add1e6digit(-6);
  return minus ? negate(lowBits, highBits) : newBits(lowBits, highBits);
}
function int64ToString(lo2, hi) {
  let bits2 = newBits(lo2, hi);
  const negative = bits2.hi & 2147483648;
  if (negative) {
    bits2 = negate(bits2.lo, bits2.hi);
  }
  const result = uInt64ToString(bits2.lo, bits2.hi);
  return negative ? "-" + result : result;
}
function uInt64ToString(lo2, hi) {
  ({ lo: lo2, hi } = toUnsigned(lo2, hi));
  if (hi <= 2097151) {
    return String(TWO_PWR_32_DBL * hi + lo2);
  }
  const low = lo2 & 16777215;
  const mid = (lo2 >>> 24 | hi << 8) & 16777215;
  const high = hi >> 16 & 65535;
  let digitA = low + mid * 6777216 + high * 6710656;
  let digitB = mid + high * 8147497;
  let digitC = high * 2;
  const base = 1e7;
  if (digitA >= base) {
    digitB += Math.floor(digitA / base);
    digitA %= base;
  }
  if (digitB >= base) {
    digitC += Math.floor(digitB / base);
    digitB %= base;
  }
  return digitC.toString() + decimalFrom1e7WithLeadingZeros(digitB) + decimalFrom1e7WithLeadingZeros(digitA);
}
function toUnsigned(lo2, hi) {
  return { lo: lo2 >>> 0, hi: hi >>> 0 };
}
function newBits(lo2, hi) {
  return { lo: lo2 | 0, hi: hi | 0 };
}
function negate(lowBits, highBits) {
  highBits = ~highBits;
  if (lowBits) {
    lowBits = ~lowBits + 1;
  } else {
    highBits += 1;
  }
  return newBits(lowBits, highBits);
}
var decimalFrom1e7WithLeadingZeros = (digit1e7) => {
  const partial = String(digit1e7);
  return "0000000".slice(partial.length) + partial;
};
function varint32write(value, bytes4) {
  if (value >= 0) {
    while (value > 127) {
      bytes4.push(value & 127 | 128);
      value = value >>> 7;
    }
    bytes4.push(value);
  } else {
    for (let i = 0; i < 9; i++) {
      bytes4.push(value & 127 | 128);
      value = value >> 7;
    }
    bytes4.push(1);
  }
}
function varint32read() {
  let b = this.buf[this.pos++];
  let result = b & 127;
  if ((b & 128) == 0) {
    this.assertBounds();
    return result;
  }
  b = this.buf[this.pos++];
  result |= (b & 127) << 7;
  if ((b & 128) == 0) {
    this.assertBounds();
    return result;
  }
  b = this.buf[this.pos++];
  result |= (b & 127) << 14;
  if ((b & 128) == 0) {
    this.assertBounds();
    return result;
  }
  b = this.buf[this.pos++];
  result |= (b & 127) << 21;
  if ((b & 128) == 0) {
    this.assertBounds();
    return result;
  }
  b = this.buf[this.pos++];
  result |= (b & 15) << 28;
  for (let readBytes = 5; (b & 128) !== 0 && readBytes < 10; readBytes++)
    b = this.buf[this.pos++];
  if ((b & 128) != 0)
    throw new Error("invalid varint");
  this.assertBounds();
  return result >>> 0;
}

// node_modules/@bufbuild/protobuf/dist/esm/proto-int64.js
function makeInt64Support() {
  const dv2 = new DataView(new ArrayBuffer(8));
  const ok = typeof BigInt === "function" && typeof dv2.getBigInt64 === "function" && typeof dv2.getBigUint64 === "function" && typeof dv2.setBigInt64 === "function" && typeof dv2.setBigUint64 === "function" && (typeof process != "object" || typeof process.env != "object" || process.env.BUF_BIGINT_DISABLE !== "1");
  if (ok) {
    const MIN = BigInt("-9223372036854775808"), MAX = BigInt("9223372036854775807"), UMIN = BigInt("0"), UMAX = BigInt("18446744073709551615");
    return {
      zero: BigInt(0),
      supported: true,
      parse(value) {
        const bi2 = typeof value == "bigint" ? value : BigInt(value);
        if (bi2 > MAX || bi2 < MIN) {
          throw new Error(`int64 invalid: ${value}`);
        }
        return bi2;
      },
      uParse(value) {
        const bi2 = typeof value == "bigint" ? value : BigInt(value);
        if (bi2 > UMAX || bi2 < UMIN) {
          throw new Error(`uint64 invalid: ${value}`);
        }
        return bi2;
      },
      enc(value) {
        dv2.setBigInt64(0, this.parse(value), true);
        return {
          lo: dv2.getInt32(0, true),
          hi: dv2.getInt32(4, true)
        };
      },
      uEnc(value) {
        dv2.setBigInt64(0, this.uParse(value), true);
        return {
          lo: dv2.getInt32(0, true),
          hi: dv2.getInt32(4, true)
        };
      },
      dec(lo2, hi) {
        dv2.setInt32(0, lo2, true);
        dv2.setInt32(4, hi, true);
        return dv2.getBigInt64(0, true);
      },
      uDec(lo2, hi) {
        dv2.setInt32(0, lo2, true);
        dv2.setInt32(4, hi, true);
        return dv2.getBigUint64(0, true);
      }
    };
  }
  const assertInt64String = (value) => assert(/^-?[0-9]+$/.test(value), `int64 invalid: ${value}`);
  const assertUInt64String = (value) => assert(/^[0-9]+$/.test(value), `uint64 invalid: ${value}`);
  return {
    zero: "0",
    supported: false,
    parse(value) {
      if (typeof value != "string") {
        value = value.toString();
      }
      assertInt64String(value);
      return value;
    },
    uParse(value) {
      if (typeof value != "string") {
        value = value.toString();
      }
      assertUInt64String(value);
      return value;
    },
    enc(value) {
      if (typeof value != "string") {
        value = value.toString();
      }
      assertInt64String(value);
      return int64FromString(value);
    },
    uEnc(value) {
      if (typeof value != "string") {
        value = value.toString();
      }
      assertUInt64String(value);
      return int64FromString(value);
    },
    dec(lo2, hi) {
      return int64ToString(lo2, hi);
    },
    uDec(lo2, hi) {
      return uInt64ToString(lo2, hi);
    }
  };
}
var protoInt64 = makeInt64Support();

// node_modules/@bufbuild/protobuf/dist/esm/scalar.js
init_checked_fetch();
init_modules_watch_stub();
var ScalarType;
(function(ScalarType2) {
  ScalarType2[ScalarType2["DOUBLE"] = 1] = "DOUBLE";
  ScalarType2[ScalarType2["FLOAT"] = 2] = "FLOAT";
  ScalarType2[ScalarType2["INT64"] = 3] = "INT64";
  ScalarType2[ScalarType2["UINT64"] = 4] = "UINT64";
  ScalarType2[ScalarType2["INT32"] = 5] = "INT32";
  ScalarType2[ScalarType2["FIXED64"] = 6] = "FIXED64";
  ScalarType2[ScalarType2["FIXED32"] = 7] = "FIXED32";
  ScalarType2[ScalarType2["BOOL"] = 8] = "BOOL";
  ScalarType2[ScalarType2["STRING"] = 9] = "STRING";
  ScalarType2[ScalarType2["BYTES"] = 12] = "BYTES";
  ScalarType2[ScalarType2["UINT32"] = 13] = "UINT32";
  ScalarType2[ScalarType2["SFIXED32"] = 15] = "SFIXED32";
  ScalarType2[ScalarType2["SFIXED64"] = 16] = "SFIXED64";
  ScalarType2[ScalarType2["SINT32"] = 17] = "SINT32";
  ScalarType2[ScalarType2["SINT64"] = 18] = "SINT64";
})(ScalarType || (ScalarType = {}));
var LongType;
(function(LongType2) {
  LongType2[LongType2["BIGINT"] = 0] = "BIGINT";
  LongType2[LongType2["STRING"] = 1] = "STRING";
})(LongType || (LongType = {}));

// node_modules/@bufbuild/protobuf/dist/esm/private/scalars.js
function scalarEquals(type, a, b) {
  if (a === b) {
    return true;
  }
  if (type == ScalarType.BYTES) {
    if (!(a instanceof Uint8Array) || !(b instanceof Uint8Array)) {
      return false;
    }
    if (a.length !== b.length) {
      return false;
    }
    for (let i = 0; i < a.length; i++) {
      if (a[i] !== b[i]) {
        return false;
      }
    }
    return true;
  }
  switch (type) {
    case ScalarType.UINT64:
    case ScalarType.FIXED64:
    case ScalarType.INT64:
    case ScalarType.SFIXED64:
    case ScalarType.SINT64:
      return a == b;
  }
  return false;
}
function scalarZeroValue(type, longType) {
  switch (type) {
    case ScalarType.BOOL:
      return false;
    case ScalarType.UINT64:
    case ScalarType.FIXED64:
    case ScalarType.INT64:
    case ScalarType.SFIXED64:
    case ScalarType.SINT64:
      return longType == 0 ? protoInt64.zero : "0";
    case ScalarType.DOUBLE:
    case ScalarType.FLOAT:
      return 0;
    case ScalarType.BYTES:
      return new Uint8Array(0);
    case ScalarType.STRING:
      return "";
    default:
      return 0;
  }
}
function isScalarZeroValue(type, value) {
  switch (type) {
    case ScalarType.BOOL:
      return value === false;
    case ScalarType.STRING:
      return value === "";
    case ScalarType.BYTES:
      return value instanceof Uint8Array && !value.byteLength;
    default:
      return value == 0;
  }
}

// node_modules/@bufbuild/protobuf/dist/esm/binary-encoding.js
init_checked_fetch();
init_modules_watch_stub();
var WireType;
(function(WireType2) {
  WireType2[WireType2["Varint"] = 0] = "Varint";
  WireType2[WireType2["Bit64"] = 1] = "Bit64";
  WireType2[WireType2["LengthDelimited"] = 2] = "LengthDelimited";
  WireType2[WireType2["StartGroup"] = 3] = "StartGroup";
  WireType2[WireType2["EndGroup"] = 4] = "EndGroup";
  WireType2[WireType2["Bit32"] = 5] = "Bit32";
})(WireType || (WireType = {}));
var BinaryWriter = class {
  constructor(textEncoder2) {
    this.stack = [];
    this.textEncoder = textEncoder2 !== null && textEncoder2 !== void 0 ? textEncoder2 : new TextEncoder();
    this.chunks = [];
    this.buf = [];
  }
  /**
   * Return all bytes written and reset this writer.
   */
  finish() {
    this.chunks.push(new Uint8Array(this.buf));
    let len = 0;
    for (let i = 0; i < this.chunks.length; i++)
      len += this.chunks[i].length;
    let bytes4 = new Uint8Array(len);
    let offset = 0;
    for (let i = 0; i < this.chunks.length; i++) {
      bytes4.set(this.chunks[i], offset);
      offset += this.chunks[i].length;
    }
    this.chunks = [];
    return bytes4;
  }
  /**
   * Start a new fork for length-delimited data like a message
   * or a packed repeated field.
   *
   * Must be joined later with `join()`.
   */
  fork() {
    this.stack.push({ chunks: this.chunks, buf: this.buf });
    this.chunks = [];
    this.buf = [];
    return this;
  }
  /**
   * Join the last fork. Write its length and bytes, then
   * return to the previous state.
   */
  join() {
    let chunk = this.finish();
    let prev = this.stack.pop();
    if (!prev)
      throw new Error("invalid state, fork stack empty");
    this.chunks = prev.chunks;
    this.buf = prev.buf;
    this.uint32(chunk.byteLength);
    return this.raw(chunk);
  }
  /**
   * Writes a tag (field number and wire type).
   *
   * Equivalent to `uint32( (fieldNo << 3 | type) >>> 0 )`.
   *
   * Generated code should compute the tag ahead of time and call `uint32()`.
   */
  tag(fieldNo, type) {
    return this.uint32((fieldNo << 3 | type) >>> 0);
  }
  /**
   * Write a chunk of raw bytes.
   */
  raw(chunk) {
    if (this.buf.length) {
      this.chunks.push(new Uint8Array(this.buf));
      this.buf = [];
    }
    this.chunks.push(chunk);
    return this;
  }
  /**
   * Write a `uint32` value, an unsigned 32 bit varint.
   */
  uint32(value) {
    assertUInt32(value);
    while (value > 127) {
      this.buf.push(value & 127 | 128);
      value = value >>> 7;
    }
    this.buf.push(value);
    return this;
  }
  /**
   * Write a `int32` value, a signed 32 bit varint.
   */
  int32(value) {
    assertInt32(value);
    varint32write(value, this.buf);
    return this;
  }
  /**
   * Write a `bool` value, a variant.
   */
  bool(value) {
    this.buf.push(value ? 1 : 0);
    return this;
  }
  /**
   * Write a `bytes` value, length-delimited arbitrary data.
   */
  bytes(value) {
    this.uint32(value.byteLength);
    return this.raw(value);
  }
  /**
   * Write a `string` value, length-delimited data converted to UTF-8 text.
   */
  string(value) {
    let chunk = this.textEncoder.encode(value);
    this.uint32(chunk.byteLength);
    return this.raw(chunk);
  }
  /**
   * Write a `float` value, 32-bit floating point number.
   */
  float(value) {
    assertFloat32(value);
    let chunk = new Uint8Array(4);
    new DataView(chunk.buffer).setFloat32(0, value, true);
    return this.raw(chunk);
  }
  /**
   * Write a `double` value, a 64-bit floating point number.
   */
  double(value) {
    let chunk = new Uint8Array(8);
    new DataView(chunk.buffer).setFloat64(0, value, true);
    return this.raw(chunk);
  }
  /**
   * Write a `fixed32` value, an unsigned, fixed-length 32-bit integer.
   */
  fixed32(value) {
    assertUInt32(value);
    let chunk = new Uint8Array(4);
    new DataView(chunk.buffer).setUint32(0, value, true);
    return this.raw(chunk);
  }
  /**
   * Write a `sfixed32` value, a signed, fixed-length 32-bit integer.
   */
  sfixed32(value) {
    assertInt32(value);
    let chunk = new Uint8Array(4);
    new DataView(chunk.buffer).setInt32(0, value, true);
    return this.raw(chunk);
  }
  /**
   * Write a `sint32` value, a signed, zigzag-encoded 32-bit varint.
   */
  sint32(value) {
    assertInt32(value);
    value = (value << 1 ^ value >> 31) >>> 0;
    varint32write(value, this.buf);
    return this;
  }
  /**
   * Write a `fixed64` value, a signed, fixed-length 64-bit integer.
   */
  sfixed64(value) {
    let chunk = new Uint8Array(8), view = new DataView(chunk.buffer), tc = protoInt64.enc(value);
    view.setInt32(0, tc.lo, true);
    view.setInt32(4, tc.hi, true);
    return this.raw(chunk);
  }
  /**
   * Write a `fixed64` value, an unsigned, fixed-length 64 bit integer.
   */
  fixed64(value) {
    let chunk = new Uint8Array(8), view = new DataView(chunk.buffer), tc = protoInt64.uEnc(value);
    view.setInt32(0, tc.lo, true);
    view.setInt32(4, tc.hi, true);
    return this.raw(chunk);
  }
  /**
   * Write a `int64` value, a signed 64-bit varint.
   */
  int64(value) {
    let tc = protoInt64.enc(value);
    varint64write(tc.lo, tc.hi, this.buf);
    return this;
  }
  /**
   * Write a `sint64` value, a signed, zig-zag-encoded 64-bit varint.
   */
  sint64(value) {
    let tc = protoInt64.enc(value), sign3 = tc.hi >> 31, lo2 = tc.lo << 1 ^ sign3, hi = (tc.hi << 1 | tc.lo >>> 31) ^ sign3;
    varint64write(lo2, hi, this.buf);
    return this;
  }
  /**
   * Write a `uint64` value, an unsigned 64-bit varint.
   */
  uint64(value) {
    let tc = protoInt64.uEnc(value);
    varint64write(tc.lo, tc.hi, this.buf);
    return this;
  }
};
var BinaryReader = class {
  constructor(buf, textDecoder) {
    this.varint64 = varint64read;
    this.uint32 = varint32read;
    this.buf = buf;
    this.len = buf.length;
    this.pos = 0;
    this.view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength);
    this.textDecoder = textDecoder !== null && textDecoder !== void 0 ? textDecoder : new TextDecoder();
  }
  /**
   * Reads a tag - field number and wire type.
   */
  tag() {
    let tag = this.uint32(), fieldNo = tag >>> 3, wireType = tag & 7;
    if (fieldNo <= 0 || wireType < 0 || wireType > 5)
      throw new Error("illegal tag: field no " + fieldNo + " wire type " + wireType);
    return [fieldNo, wireType];
  }
  /**
   * Skip one element on the wire and return the skipped data.
   * Supports WireType.StartGroup since v2.0.0-alpha.23.
   */
  skip(wireType) {
    let start = this.pos;
    switch (wireType) {
      case WireType.Varint:
        while (this.buf[this.pos++] & 128) {
        }
        break;
      case WireType.Bit64:
        this.pos += 4;
      case WireType.Bit32:
        this.pos += 4;
        break;
      case WireType.LengthDelimited:
        let len = this.uint32();
        this.pos += len;
        break;
      case WireType.StartGroup:
        let t;
        while ((t = this.tag()[1]) !== WireType.EndGroup) {
          this.skip(t);
        }
        break;
      default:
        throw new Error("cant skip wire type " + wireType);
    }
    this.assertBounds();
    return this.buf.subarray(start, this.pos);
  }
  /**
   * Throws error if position in byte array is out of range.
   */
  assertBounds() {
    if (this.pos > this.len)
      throw new RangeError("premature EOF");
  }
  /**
   * Read a `int32` field, a signed 32 bit varint.
   */
  int32() {
    return this.uint32() | 0;
  }
  /**
   * Read a `sint32` field, a signed, zigzag-encoded 32-bit varint.
   */
  sint32() {
    let zze = this.uint32();
    return zze >>> 1 ^ -(zze & 1);
  }
  /**
   * Read a `int64` field, a signed 64-bit varint.
   */
  int64() {
    return protoInt64.dec(...this.varint64());
  }
  /**
   * Read a `uint64` field, an unsigned 64-bit varint.
   */
  uint64() {
    return protoInt64.uDec(...this.varint64());
  }
  /**
   * Read a `sint64` field, a signed, zig-zag-encoded 64-bit varint.
   */
  sint64() {
    let [lo2, hi] = this.varint64();
    let s = -(lo2 & 1);
    lo2 = (lo2 >>> 1 | (hi & 1) << 31) ^ s;
    hi = hi >>> 1 ^ s;
    return protoInt64.dec(lo2, hi);
  }
  /**
   * Read a `bool` field, a variant.
   */
  bool() {
    let [lo2, hi] = this.varint64();
    return lo2 !== 0 || hi !== 0;
  }
  /**
   * Read a `fixed32` field, an unsigned, fixed-length 32-bit integer.
   */
  fixed32() {
    return this.view.getUint32((this.pos += 4) - 4, true);
  }
  /**
   * Read a `sfixed32` field, a signed, fixed-length 32-bit integer.
   */
  sfixed32() {
    return this.view.getInt32((this.pos += 4) - 4, true);
  }
  /**
   * Read a `fixed64` field, an unsigned, fixed-length 64 bit integer.
   */
  fixed64() {
    return protoInt64.uDec(this.sfixed32(), this.sfixed32());
  }
  /**
   * Read a `fixed64` field, a signed, fixed-length 64-bit integer.
   */
  sfixed64() {
    return protoInt64.dec(this.sfixed32(), this.sfixed32());
  }
  /**
   * Read a `float` field, 32-bit floating point number.
   */
  float() {
    return this.view.getFloat32((this.pos += 4) - 4, true);
  }
  /**
   * Read a `double` field, a 64-bit floating point number.
   */
  double() {
    return this.view.getFloat64((this.pos += 8) - 8, true);
  }
  /**
   * Read a `bytes` field, length-delimited arbitrary data.
   */
  bytes() {
    let len = this.uint32(), start = this.pos;
    this.pos += len;
    this.assertBounds();
    return this.buf.subarray(start, start + len);
  }
  /**
   * Read a `string` field, length-delimited data converted to UTF-8 text.
   */
  string() {
    return this.textDecoder.decode(this.bytes());
  }
};

// node_modules/@bufbuild/protobuf/dist/esm/private/extensions.js
function makeExtension(runtime, typeName, extendee, field) {
  let fi;
  return {
    typeName,
    extendee,
    get field() {
      if (!fi) {
        const i = typeof field == "function" ? field() : field;
        i.name = typeName.split(".").pop();
        i.jsonName = `[${typeName}]`;
        fi = runtime.util.newFieldList([i]).list()[0];
      }
      return fi;
    },
    runtime
  };
}
function createExtensionContainer(extension) {
  const localName = extension.field.localName;
  const container = /* @__PURE__ */ Object.create(null);
  container[localName] = initExtensionField(extension);
  return [container, () => container[localName]];
}
function initExtensionField(ext) {
  const field = ext.field;
  if (field.repeated) {
    return [];
  }
  if (field.default !== void 0) {
    return field.default;
  }
  switch (field.kind) {
    case "enum":
      return field.T.values[0].no;
    case "scalar":
      return scalarZeroValue(field.T, field.L);
    case "message":
      const T = field.T, value = new T();
      return T.fieldWrapper ? T.fieldWrapper.unwrapField(value) : value;
    case "map":
      throw "map fields are not allowed to be extensions";
  }
}
function filterUnknownFields(unknownFields, field) {
  if (!field.repeated && (field.kind == "enum" || field.kind == "scalar")) {
    for (let i = unknownFields.length - 1; i >= 0; --i) {
      if (unknownFields[i].no == field.no) {
        return [unknownFields[i]];
      }
    }
    return [];
  }
  return unknownFields.filter((uf) => uf.no === field.no);
}

// node_modules/@bufbuild/protobuf/dist/esm/private/json-format.js
init_checked_fetch();
init_modules_watch_stub();

// node_modules/@bufbuild/protobuf/dist/esm/proto-base64.js
init_checked_fetch();
init_modules_watch_stub();
var encTable = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/".split("");
var decTable = [];
for (let i = 0; i < encTable.length; i++)
  decTable[encTable[i].charCodeAt(0)] = i;
decTable["-".charCodeAt(0)] = encTable.indexOf("+");
decTable["_".charCodeAt(0)] = encTable.indexOf("/");
var protoBase64 = {
  /**
   * Decodes a base64 string to a byte array.
   *
   * - ignores white-space, including line breaks and tabs
   * - allows inner padding (can decode concatenated base64 strings)
   * - does not require padding
   * - understands base64url encoding:
   *   "-" instead of "+",
   *   "_" instead of "/",
   *   no padding
   */
  dec(base64Str) {
    let es = base64Str.length * 3 / 4;
    if (base64Str[base64Str.length - 2] == "=")
      es -= 2;
    else if (base64Str[base64Str.length - 1] == "=")
      es -= 1;
    let bytes4 = new Uint8Array(es), bytePos = 0, groupPos = 0, b, p2 = 0;
    for (let i = 0; i < base64Str.length; i++) {
      b = decTable[base64Str.charCodeAt(i)];
      if (b === void 0) {
        switch (base64Str[i]) {
          case "=":
            groupPos = 0;
          case "\n":
          case "\r":
          case "	":
          case " ":
            continue;
          default:
            throw Error("invalid base64 string.");
        }
      }
      switch (groupPos) {
        case 0:
          p2 = b;
          groupPos = 1;
          break;
        case 1:
          bytes4[bytePos++] = p2 << 2 | (b & 48) >> 4;
          p2 = b;
          groupPos = 2;
          break;
        case 2:
          bytes4[bytePos++] = (p2 & 15) << 4 | (b & 60) >> 2;
          p2 = b;
          groupPos = 3;
          break;
        case 3:
          bytes4[bytePos++] = (p2 & 3) << 6 | b;
          groupPos = 0;
          break;
      }
    }
    if (groupPos == 1)
      throw Error("invalid base64 string.");
    return bytes4.subarray(0, bytePos);
  },
  /**
   * Encode a byte array to a base64 string.
   */
  enc(bytes4) {
    let base642 = "", groupPos = 0, b, p2 = 0;
    for (let i = 0; i < bytes4.length; i++) {
      b = bytes4[i];
      switch (groupPos) {
        case 0:
          base642 += encTable[b >> 2];
          p2 = (b & 3) << 4;
          groupPos = 1;
          break;
        case 1:
          base642 += encTable[p2 | b >> 4];
          p2 = (b & 15) << 2;
          groupPos = 2;
          break;
        case 2:
          base642 += encTable[p2 | b >> 6];
          base642 += encTable[b & 63];
          groupPos = 0;
          break;
      }
    }
    if (groupPos) {
      base642 += encTable[p2];
      base642 += "=";
      if (groupPos == 1)
        base642 += "=";
    }
    return base642;
  }
};

// node_modules/@bufbuild/protobuf/dist/esm/extension-accessor.js
init_checked_fetch();
init_modules_watch_stub();
function getExtension(message2, extension, options) {
  assertExtendee(extension, message2);
  const opt = extension.runtime.bin.makeReadOptions(options);
  const ufs = filterUnknownFields(message2.getType().runtime.bin.listUnknownFields(message2), extension.field);
  const [container, get] = createExtensionContainer(extension);
  for (const uf of ufs) {
    extension.runtime.bin.readField(container, opt.readerFactory(uf.data), extension.field, uf.wireType, opt);
  }
  return get();
}
function setExtension(message2, extension, value, options) {
  assertExtendee(extension, message2);
  const readOpt = extension.runtime.bin.makeReadOptions(options);
  const writeOpt = extension.runtime.bin.makeWriteOptions(options);
  if (hasExtension(message2, extension)) {
    const ufs = message2.getType().runtime.bin.listUnknownFields(message2).filter((uf) => uf.no != extension.field.no);
    message2.getType().runtime.bin.discardUnknownFields(message2);
    for (const uf of ufs) {
      message2.getType().runtime.bin.onUnknownField(message2, uf.no, uf.wireType, uf.data);
    }
  }
  const writer = writeOpt.writerFactory();
  let f = extension.field;
  if (!f.opt && !f.repeated && (f.kind == "enum" || f.kind == "scalar")) {
    f = Object.assign(Object.assign({}, extension.field), { opt: true });
  }
  extension.runtime.bin.writeField(f, value, writer, writeOpt);
  const reader = readOpt.readerFactory(writer.finish());
  while (reader.pos < reader.len) {
    const [no, wireType] = reader.tag();
    const data = reader.skip(wireType);
    message2.getType().runtime.bin.onUnknownField(message2, no, wireType, data);
  }
}
function hasExtension(message2, extension) {
  const messageType = message2.getType();
  return extension.extendee.typeName === messageType.typeName && !!messageType.runtime.bin.listUnknownFields(message2).find((uf) => uf.no == extension.field.no);
}
function assertExtendee(extension, message2) {
  assert(extension.extendee.typeName == message2.getType().typeName, `extension ${extension.typeName} can only be applied to message ${extension.extendee.typeName}`);
}

// node_modules/@bufbuild/protobuf/dist/esm/private/reflect.js
init_checked_fetch();
init_modules_watch_stub();
function isFieldSet(field, target) {
  const localName = field.localName;
  if (field.repeated) {
    return target[localName].length > 0;
  }
  if (field.oneof) {
    return target[field.oneof.localName].case === localName;
  }
  switch (field.kind) {
    case "enum":
    case "scalar":
      if (field.opt || field.req) {
        return target[localName] !== void 0;
      }
      if (field.kind == "enum") {
        return target[localName] !== field.T.values[0].no;
      }
      return !isScalarZeroValue(field.T, target[localName]);
    case "message":
      return target[localName] !== void 0;
    case "map":
      return Object.keys(target[localName]).length > 0;
  }
}
function clearField(field, target) {
  const localName = field.localName;
  const implicitPresence = !field.opt && !field.req;
  if (field.repeated) {
    target[localName] = [];
  } else if (field.oneof) {
    target[field.oneof.localName] = { case: void 0 };
  } else {
    switch (field.kind) {
      case "map":
        target[localName] = {};
        break;
      case "enum":
        target[localName] = implicitPresence ? field.T.values[0].no : void 0;
        break;
      case "scalar":
        target[localName] = implicitPresence ? scalarZeroValue(field.T, field.L) : void 0;
        break;
      case "message":
        target[localName] = void 0;
        break;
    }
  }
}

// node_modules/@bufbuild/protobuf/dist/esm/private/field-wrapper.js
init_checked_fetch();
init_modules_watch_stub();

// node_modules/@bufbuild/protobuf/dist/esm/is-message.js
init_checked_fetch();
init_modules_watch_stub();
function isMessage(arg, type) {
  if (arg === null || typeof arg != "object") {
    return false;
  }
  if (!Object.getOwnPropertyNames(Message.prototype).every((m2) => m2 in arg && typeof arg[m2] == "function")) {
    return false;
  }
  const actualType = arg.getType();
  if (actualType === null || typeof actualType != "function" || !("typeName" in actualType) || typeof actualType.typeName != "string") {
    return false;
  }
  return type === void 0 ? true : actualType.typeName == type.typeName;
}

// node_modules/@bufbuild/protobuf/dist/esm/private/field-wrapper.js
function wrapField(type, value) {
  if (isMessage(value) || !type.fieldWrapper) {
    return value;
  }
  return type.fieldWrapper.wrapField(value);
}
var wktWrapperToScalarType = {
  "google.protobuf.DoubleValue": ScalarType.DOUBLE,
  "google.protobuf.FloatValue": ScalarType.FLOAT,
  "google.protobuf.Int64Value": ScalarType.INT64,
  "google.protobuf.UInt64Value": ScalarType.UINT64,
  "google.protobuf.Int32Value": ScalarType.INT32,
  "google.protobuf.UInt32Value": ScalarType.UINT32,
  "google.protobuf.BoolValue": ScalarType.BOOL,
  "google.protobuf.StringValue": ScalarType.STRING,
  "google.protobuf.BytesValue": ScalarType.BYTES
};

// node_modules/@bufbuild/protobuf/dist/esm/private/json-format.js
var jsonReadDefaults = {
  ignoreUnknownFields: false
};
var jsonWriteDefaults = {
  emitDefaultValues: false,
  enumAsInteger: false,
  useProtoFieldName: false,
  prettySpaces: 0
};
function makeReadOptions(options) {
  return options ? Object.assign(Object.assign({}, jsonReadDefaults), options) : jsonReadDefaults;
}
function makeWriteOptions(options) {
  return options ? Object.assign(Object.assign({}, jsonWriteDefaults), options) : jsonWriteDefaults;
}
var tokenNull = Symbol();
var tokenIgnoredUnknownEnum = Symbol();
function makeJsonFormat() {
  return {
    makeReadOptions,
    makeWriteOptions,
    readMessage(type, json, options, message2) {
      if (json == null || Array.isArray(json) || typeof json != "object") {
        throw new Error(`cannot decode message ${type.typeName} from JSON: ${debugJsonValue(json)}`);
      }
      message2 = message2 !== null && message2 !== void 0 ? message2 : new type();
      const oneofSeen = /* @__PURE__ */ new Map();
      const registry = options.typeRegistry;
      for (const [jsonKey, jsonValue] of Object.entries(json)) {
        const field = type.fields.findJsonName(jsonKey);
        if (field) {
          if (field.oneof) {
            if (jsonValue === null && field.kind == "scalar") {
              continue;
            }
            const seen = oneofSeen.get(field.oneof);
            if (seen !== void 0) {
              throw new Error(`cannot decode message ${type.typeName} from JSON: multiple keys for oneof "${field.oneof.name}" present: "${seen}", "${jsonKey}"`);
            }
            oneofSeen.set(field.oneof, jsonKey);
          }
          readField(message2, jsonValue, field, options, type);
        } else {
          let found = false;
          if ((registry === null || registry === void 0 ? void 0 : registry.findExtension) && jsonKey.startsWith("[") && jsonKey.endsWith("]")) {
            const ext = registry.findExtension(jsonKey.substring(1, jsonKey.length - 1));
            if (ext && ext.extendee.typeName == type.typeName) {
              found = true;
              const [container, get] = createExtensionContainer(ext);
              readField(container, jsonValue, ext.field, options, ext);
              setExtension(message2, ext, get(), options);
            }
          }
          if (!found && !options.ignoreUnknownFields) {
            throw new Error(`cannot decode message ${type.typeName} from JSON: key "${jsonKey}" is unknown`);
          }
        }
      }
      return message2;
    },
    writeMessage(message2, options) {
      const type = message2.getType();
      const json = {};
      let field;
      try {
        for (field of type.fields.byNumber()) {
          if (!isFieldSet(field, message2)) {
            if (field.req) {
              throw `required field not set`;
            }
            if (!options.emitDefaultValues) {
              continue;
            }
            if (!canEmitFieldDefaultValue(field)) {
              continue;
            }
          }
          const value = field.oneof ? message2[field.oneof.localName].value : message2[field.localName];
          const jsonValue = writeField(field, value, options);
          if (jsonValue !== void 0) {
            json[options.useProtoFieldName ? field.name : field.jsonName] = jsonValue;
          }
        }
        const registry = options.typeRegistry;
        if (registry === null || registry === void 0 ? void 0 : registry.findExtensionFor) {
          for (const uf of type.runtime.bin.listUnknownFields(message2)) {
            const ext = registry.findExtensionFor(type.typeName, uf.no);
            if (ext && hasExtension(message2, ext)) {
              const value = getExtension(message2, ext, options);
              const jsonValue = writeField(ext.field, value, options);
              if (jsonValue !== void 0) {
                json[ext.field.jsonName] = jsonValue;
              }
            }
          }
        }
      } catch (e) {
        const m2 = field ? `cannot encode field ${type.typeName}.${field.name} to JSON` : `cannot encode message ${type.typeName} to JSON`;
        const r2 = e instanceof Error ? e.message : String(e);
        throw new Error(m2 + (r2.length > 0 ? `: ${r2}` : ""));
      }
      return json;
    },
    readScalar(type, json, longType) {
      return readScalar(type, json, longType !== null && longType !== void 0 ? longType : LongType.BIGINT, true);
    },
    writeScalar(type, value, emitDefaultValues) {
      if (value === void 0) {
        return void 0;
      }
      if (emitDefaultValues || isScalarZeroValue(type, value)) {
        return writeScalar(type, value);
      }
      return void 0;
    },
    debug: debugJsonValue
  };
}
function debugJsonValue(json) {
  if (json === null) {
    return "null";
  }
  switch (typeof json) {
    case "object":
      return Array.isArray(json) ? "array" : "object";
    case "string":
      return json.length > 100 ? "string" : `"${json.split('"').join('\\"')}"`;
    default:
      return String(json);
  }
}
function readField(target, jsonValue, field, options, parentType) {
  let localName = field.localName;
  if (field.repeated) {
    assert(field.kind != "map");
    if (jsonValue === null) {
      return;
    }
    if (!Array.isArray(jsonValue)) {
      throw new Error(`cannot decode field ${parentType.typeName}.${field.name} from JSON: ${debugJsonValue(jsonValue)}`);
    }
    const targetArray = target[localName];
    for (const jsonItem of jsonValue) {
      if (jsonItem === null) {
        throw new Error(`cannot decode field ${parentType.typeName}.${field.name} from JSON: ${debugJsonValue(jsonItem)}`);
      }
      switch (field.kind) {
        case "message":
          targetArray.push(field.T.fromJson(jsonItem, options));
          break;
        case "enum":
          const enumValue = readEnum(field.T, jsonItem, options.ignoreUnknownFields, true);
          if (enumValue !== tokenIgnoredUnknownEnum) {
            targetArray.push(enumValue);
          }
          break;
        case "scalar":
          try {
            targetArray.push(readScalar(field.T, jsonItem, field.L, true));
          } catch (e) {
            let m2 = `cannot decode field ${parentType.typeName}.${field.name} from JSON: ${debugJsonValue(jsonItem)}`;
            if (e instanceof Error && e.message.length > 0) {
              m2 += `: ${e.message}`;
            }
            throw new Error(m2);
          }
          break;
      }
    }
  } else if (field.kind == "map") {
    if (jsonValue === null) {
      return;
    }
    if (typeof jsonValue != "object" || Array.isArray(jsonValue)) {
      throw new Error(`cannot decode field ${parentType.typeName}.${field.name} from JSON: ${debugJsonValue(jsonValue)}`);
    }
    const targetMap = target[localName];
    for (const [jsonMapKey, jsonMapValue] of Object.entries(jsonValue)) {
      if (jsonMapValue === null) {
        throw new Error(`cannot decode field ${parentType.typeName}.${field.name} from JSON: map value null`);
      }
      let key;
      try {
        key = readMapKey(field.K, jsonMapKey);
      } catch (e) {
        let m2 = `cannot decode map key for field ${parentType.typeName}.${field.name} from JSON: ${debugJsonValue(jsonValue)}`;
        if (e instanceof Error && e.message.length > 0) {
          m2 += `: ${e.message}`;
        }
        throw new Error(m2);
      }
      switch (field.V.kind) {
        case "message":
          targetMap[key] = field.V.T.fromJson(jsonMapValue, options);
          break;
        case "enum":
          const enumValue = readEnum(field.V.T, jsonMapValue, options.ignoreUnknownFields, true);
          if (enumValue !== tokenIgnoredUnknownEnum) {
            targetMap[key] = enumValue;
          }
          break;
        case "scalar":
          try {
            targetMap[key] = readScalar(field.V.T, jsonMapValue, LongType.BIGINT, true);
          } catch (e) {
            let m2 = `cannot decode map value for field ${parentType.typeName}.${field.name} from JSON: ${debugJsonValue(jsonValue)}`;
            if (e instanceof Error && e.message.length > 0) {
              m2 += `: ${e.message}`;
            }
            throw new Error(m2);
          }
          break;
      }
    }
  } else {
    if (field.oneof) {
      target = target[field.oneof.localName] = { case: localName };
      localName = "value";
    }
    switch (field.kind) {
      case "message":
        const messageType = field.T;
        if (jsonValue === null && messageType.typeName != "google.protobuf.Value") {
          return;
        }
        let currentValue = target[localName];
        if (isMessage(currentValue)) {
          currentValue.fromJson(jsonValue, options);
        } else {
          target[localName] = currentValue = messageType.fromJson(jsonValue, options);
          if (messageType.fieldWrapper && !field.oneof) {
            target[localName] = messageType.fieldWrapper.unwrapField(currentValue);
          }
        }
        break;
      case "enum":
        const enumValue = readEnum(field.T, jsonValue, options.ignoreUnknownFields, false);
        switch (enumValue) {
          case tokenNull:
            clearField(field, target);
            break;
          case tokenIgnoredUnknownEnum:
            break;
          default:
            target[localName] = enumValue;
            break;
        }
        break;
      case "scalar":
        try {
          const scalarValue = readScalar(field.T, jsonValue, field.L, false);
          switch (scalarValue) {
            case tokenNull:
              clearField(field, target);
              break;
            default:
              target[localName] = scalarValue;
              break;
          }
        } catch (e) {
          let m2 = `cannot decode field ${parentType.typeName}.${field.name} from JSON: ${debugJsonValue(jsonValue)}`;
          if (e instanceof Error && e.message.length > 0) {
            m2 += `: ${e.message}`;
          }
          throw new Error(m2);
        }
        break;
    }
  }
}
function readMapKey(type, json) {
  if (type === ScalarType.BOOL) {
    switch (json) {
      case "true":
        json = true;
        break;
      case "false":
        json = false;
        break;
    }
  }
  return readScalar(type, json, LongType.BIGINT, true).toString();
}
function readScalar(type, json, longType, nullAsZeroValue) {
  if (json === null) {
    if (nullAsZeroValue) {
      return scalarZeroValue(type, longType);
    }
    return tokenNull;
  }
  switch (type) {
    case ScalarType.DOUBLE:
    case ScalarType.FLOAT:
      if (json === "NaN")
        return Number.NaN;
      if (json === "Infinity")
        return Number.POSITIVE_INFINITY;
      if (json === "-Infinity")
        return Number.NEGATIVE_INFINITY;
      if (json === "") {
        break;
      }
      if (typeof json == "string" && json.trim().length !== json.length) {
        break;
      }
      if (typeof json != "string" && typeof json != "number") {
        break;
      }
      const float = Number(json);
      if (Number.isNaN(float)) {
        break;
      }
      if (!Number.isFinite(float)) {
        break;
      }
      if (type == ScalarType.FLOAT)
        assertFloat32(float);
      return float;
    case ScalarType.INT32:
    case ScalarType.FIXED32:
    case ScalarType.SFIXED32:
    case ScalarType.SINT32:
    case ScalarType.UINT32:
      let int32;
      if (typeof json == "number")
        int32 = json;
      else if (typeof json == "string" && json.length > 0) {
        if (json.trim().length === json.length)
          int32 = Number(json);
      }
      if (int32 === void 0)
        break;
      if (type == ScalarType.UINT32)
        assertUInt32(int32);
      else
        assertInt32(int32);
      return int32;
    case ScalarType.INT64:
    case ScalarType.SFIXED64:
    case ScalarType.SINT64:
      if (typeof json != "number" && typeof json != "string")
        break;
      const long = protoInt64.parse(json);
      return longType ? long.toString() : long;
    case ScalarType.FIXED64:
    case ScalarType.UINT64:
      if (typeof json != "number" && typeof json != "string")
        break;
      const uLong = protoInt64.uParse(json);
      return longType ? uLong.toString() : uLong;
    case ScalarType.BOOL:
      if (typeof json !== "boolean")
        break;
      return json;
    case ScalarType.STRING:
      if (typeof json !== "string") {
        break;
      }
      try {
        encodeURIComponent(json);
      } catch (e) {
        throw new Error("invalid UTF8");
      }
      return json;
    case ScalarType.BYTES:
      if (json === "")
        return new Uint8Array(0);
      if (typeof json !== "string")
        break;
      return protoBase64.dec(json);
  }
  throw new Error();
}
function readEnum(type, json, ignoreUnknownFields, nullAsZeroValue) {
  if (json === null) {
    if (type.typeName == "google.protobuf.NullValue") {
      return 0;
    }
    return nullAsZeroValue ? type.values[0].no : tokenNull;
  }
  switch (typeof json) {
    case "number":
      if (Number.isInteger(json)) {
        return json;
      }
      break;
    case "string":
      const value = type.findName(json);
      if (value !== void 0) {
        return value.no;
      }
      if (ignoreUnknownFields) {
        return tokenIgnoredUnknownEnum;
      }
      break;
  }
  throw new Error(`cannot decode enum ${type.typeName} from JSON: ${debugJsonValue(json)}`);
}
function canEmitFieldDefaultValue(field) {
  if (field.repeated || field.kind == "map") {
    return true;
  }
  if (field.oneof) {
    return false;
  }
  if (field.kind == "message") {
    return false;
  }
  if (field.opt || field.req) {
    return false;
  }
  return true;
}
function writeField(field, value, options) {
  if (field.kind == "map") {
    assert(typeof value == "object" && value != null);
    const jsonObj = {};
    const entries = Object.entries(value);
    switch (field.V.kind) {
      case "scalar":
        for (const [entryKey, entryValue] of entries) {
          jsonObj[entryKey.toString()] = writeScalar(field.V.T, entryValue);
        }
        break;
      case "message":
        for (const [entryKey, entryValue] of entries) {
          jsonObj[entryKey.toString()] = entryValue.toJson(options);
        }
        break;
      case "enum":
        const enumType = field.V.T;
        for (const [entryKey, entryValue] of entries) {
          jsonObj[entryKey.toString()] = writeEnum(enumType, entryValue, options.enumAsInteger);
        }
        break;
    }
    return options.emitDefaultValues || entries.length > 0 ? jsonObj : void 0;
  }
  if (field.repeated) {
    assert(Array.isArray(value));
    const jsonArr = [];
    switch (field.kind) {
      case "scalar":
        for (let i = 0; i < value.length; i++) {
          jsonArr.push(writeScalar(field.T, value[i]));
        }
        break;
      case "enum":
        for (let i = 0; i < value.length; i++) {
          jsonArr.push(writeEnum(field.T, value[i], options.enumAsInteger));
        }
        break;
      case "message":
        for (let i = 0; i < value.length; i++) {
          jsonArr.push(value[i].toJson(options));
        }
        break;
    }
    return options.emitDefaultValues || jsonArr.length > 0 ? jsonArr : void 0;
  }
  switch (field.kind) {
    case "scalar":
      return writeScalar(field.T, value);
    case "enum":
      return writeEnum(field.T, value, options.enumAsInteger);
    case "message":
      return wrapField(field.T, value).toJson(options);
  }
}
function writeEnum(type, value, enumAsInteger) {
  var _a2;
  assert(typeof value == "number");
  if (type.typeName == "google.protobuf.NullValue") {
    return null;
  }
  if (enumAsInteger) {
    return value;
  }
  const val = type.findNumber(value);
  return (_a2 = val === null || val === void 0 ? void 0 : val.name) !== null && _a2 !== void 0 ? _a2 : value;
}
function writeScalar(type, value) {
  switch (type) {
    case ScalarType.INT32:
    case ScalarType.SFIXED32:
    case ScalarType.SINT32:
    case ScalarType.FIXED32:
    case ScalarType.UINT32:
      assert(typeof value == "number");
      return value;
    case ScalarType.FLOAT:
    case ScalarType.DOUBLE:
      assert(typeof value == "number");
      if (Number.isNaN(value))
        return "NaN";
      if (value === Number.POSITIVE_INFINITY)
        return "Infinity";
      if (value === Number.NEGATIVE_INFINITY)
        return "-Infinity";
      return value;
    case ScalarType.STRING:
      assert(typeof value == "string");
      return value;
    case ScalarType.BOOL:
      assert(typeof value == "boolean");
      return value;
    case ScalarType.UINT64:
    case ScalarType.FIXED64:
    case ScalarType.INT64:
    case ScalarType.SFIXED64:
    case ScalarType.SINT64:
      assert(typeof value == "bigint" || typeof value == "string" || typeof value == "number");
      return value.toString();
    case ScalarType.BYTES:
      assert(value instanceof Uint8Array);
      return protoBase64.enc(value);
  }
}

// node_modules/@bufbuild/protobuf/dist/esm/private/binary-format.js
init_checked_fetch();
init_modules_watch_stub();
var unknownFieldsSymbol = Symbol("@bufbuild/protobuf/unknown-fields");
var readDefaults = {
  readUnknownFields: true,
  readerFactory: (bytes4) => new BinaryReader(bytes4)
};
var writeDefaults = {
  writeUnknownFields: true,
  writerFactory: () => new BinaryWriter()
};
function makeReadOptions2(options) {
  return options ? Object.assign(Object.assign({}, readDefaults), options) : readDefaults;
}
function makeWriteOptions2(options) {
  return options ? Object.assign(Object.assign({}, writeDefaults), options) : writeDefaults;
}
function makeBinaryFormat() {
  return {
    makeReadOptions: makeReadOptions2,
    makeWriteOptions: makeWriteOptions2,
    listUnknownFields(message2) {
      var _a2;
      return (_a2 = message2[unknownFieldsSymbol]) !== null && _a2 !== void 0 ? _a2 : [];
    },
    discardUnknownFields(message2) {
      delete message2[unknownFieldsSymbol];
    },
    writeUnknownFields(message2, writer) {
      const m2 = message2;
      const c = m2[unknownFieldsSymbol];
      if (c) {
        for (const f of c) {
          writer.tag(f.no, f.wireType).raw(f.data);
        }
      }
    },
    onUnknownField(message2, no, wireType, data) {
      const m2 = message2;
      if (!Array.isArray(m2[unknownFieldsSymbol])) {
        m2[unknownFieldsSymbol] = [];
      }
      m2[unknownFieldsSymbol].push({ no, wireType, data });
    },
    readMessage(message2, reader, lengthOrEndTagFieldNo, options, delimitedMessageEncoding) {
      const type = message2.getType();
      const end = delimitedMessageEncoding ? reader.len : reader.pos + lengthOrEndTagFieldNo;
      let fieldNo, wireType;
      while (reader.pos < end) {
        [fieldNo, wireType] = reader.tag();
        if (wireType == WireType.EndGroup) {
          break;
        }
        const field = type.fields.find(fieldNo);
        if (!field) {
          const data = reader.skip(wireType);
          if (options.readUnknownFields) {
            this.onUnknownField(message2, fieldNo, wireType, data);
          }
          continue;
        }
        readField2(message2, reader, field, wireType, options);
      }
      if (delimitedMessageEncoding && // eslint-disable-line @typescript-eslint/strict-boolean-expressions
      (wireType != WireType.EndGroup || fieldNo !== lengthOrEndTagFieldNo)) {
        throw new Error(`invalid end group tag`);
      }
    },
    readField: readField2,
    writeMessage(message2, writer, options) {
      const type = message2.getType();
      for (const field of type.fields.byNumber()) {
        if (!isFieldSet(field, message2)) {
          if (field.req) {
            throw new Error(`cannot encode field ${type.typeName}.${field.name} to binary: required field not set`);
          }
          continue;
        }
        const value = field.oneof ? message2[field.oneof.localName].value : message2[field.localName];
        writeField2(field, value, writer, options);
      }
      if (options.writeUnknownFields) {
        this.writeUnknownFields(message2, writer);
      }
      return writer;
    },
    writeField(field, value, writer, options) {
      if (value === void 0) {
        return void 0;
      }
      writeField2(field, value, writer, options);
    }
  };
}
function readField2(target, reader, field, wireType, options) {
  let { repeated, localName } = field;
  if (field.oneof) {
    target = target[field.oneof.localName];
    if (target.case != localName) {
      delete target.value;
    }
    target.case = localName;
    localName = "value";
  }
  switch (field.kind) {
    case "scalar":
    case "enum":
      const scalarType = field.kind == "enum" ? ScalarType.INT32 : field.T;
      let read = readScalar2;
      if (field.kind == "scalar" && field.L > 0) {
        read = readScalarLTString;
      }
      if (repeated) {
        let arr = target[localName];
        const isPacked = wireType == WireType.LengthDelimited && scalarType != ScalarType.STRING && scalarType != ScalarType.BYTES;
        if (isPacked) {
          let e = reader.uint32() + reader.pos;
          while (reader.pos < e) {
            arr.push(read(reader, scalarType));
          }
        } else {
          arr.push(read(reader, scalarType));
        }
      } else {
        target[localName] = read(reader, scalarType);
      }
      break;
    case "message":
      const messageType = field.T;
      if (repeated) {
        target[localName].push(readMessageField(reader, new messageType(), options, field));
      } else {
        if (isMessage(target[localName])) {
          readMessageField(reader, target[localName], options, field);
        } else {
          target[localName] = readMessageField(reader, new messageType(), options, field);
          if (messageType.fieldWrapper && !field.oneof && !field.repeated) {
            target[localName] = messageType.fieldWrapper.unwrapField(target[localName]);
          }
        }
      }
      break;
    case "map":
      let [mapKey, mapVal] = readMapEntry(field, reader, options);
      target[localName][mapKey] = mapVal;
      break;
  }
}
function readMessageField(reader, message2, options, field) {
  const format = message2.getType().runtime.bin;
  const delimited = field === null || field === void 0 ? void 0 : field.delimited;
  format.readMessage(
    message2,
    reader,
    delimited ? field.no : reader.uint32(),
    // eslint-disable-line @typescript-eslint/strict-boolean-expressions
    options,
    delimited
  );
  return message2;
}
function readMapEntry(field, reader, options) {
  const length = reader.uint32(), end = reader.pos + length;
  let key, val;
  while (reader.pos < end) {
    const [fieldNo] = reader.tag();
    switch (fieldNo) {
      case 1:
        key = readScalar2(reader, field.K);
        break;
      case 2:
        switch (field.V.kind) {
          case "scalar":
            val = readScalar2(reader, field.V.T);
            break;
          case "enum":
            val = reader.int32();
            break;
          case "message":
            val = readMessageField(reader, new field.V.T(), options, void 0);
            break;
        }
        break;
    }
  }
  if (key === void 0) {
    key = scalarZeroValue(field.K, LongType.BIGINT);
  }
  if (typeof key != "string" && typeof key != "number") {
    key = key.toString();
  }
  if (val === void 0) {
    switch (field.V.kind) {
      case "scalar":
        val = scalarZeroValue(field.V.T, LongType.BIGINT);
        break;
      case "enum":
        val = field.V.T.values[0].no;
        break;
      case "message":
        val = new field.V.T();
        break;
    }
  }
  return [key, val];
}
function readScalarLTString(reader, type) {
  const v = readScalar2(reader, type);
  return typeof v == "bigint" ? v.toString() : v;
}
function readScalar2(reader, type) {
  switch (type) {
    case ScalarType.STRING:
      return reader.string();
    case ScalarType.BOOL:
      return reader.bool();
    case ScalarType.DOUBLE:
      return reader.double();
    case ScalarType.FLOAT:
      return reader.float();
    case ScalarType.INT32:
      return reader.int32();
    case ScalarType.INT64:
      return reader.int64();
    case ScalarType.UINT64:
      return reader.uint64();
    case ScalarType.FIXED64:
      return reader.fixed64();
    case ScalarType.BYTES:
      return reader.bytes();
    case ScalarType.FIXED32:
      return reader.fixed32();
    case ScalarType.SFIXED32:
      return reader.sfixed32();
    case ScalarType.SFIXED64:
      return reader.sfixed64();
    case ScalarType.SINT64:
      return reader.sint64();
    case ScalarType.UINT32:
      return reader.uint32();
    case ScalarType.SINT32:
      return reader.sint32();
  }
}
function writeField2(field, value, writer, options) {
  assert(value !== void 0);
  const repeated = field.repeated;
  switch (field.kind) {
    case "scalar":
    case "enum":
      let scalarType = field.kind == "enum" ? ScalarType.INT32 : field.T;
      if (repeated) {
        assert(Array.isArray(value));
        if (field.packed) {
          writePacked(writer, scalarType, field.no, value);
        } else {
          for (const item of value) {
            writeScalar2(writer, scalarType, field.no, item);
          }
        }
      } else {
        writeScalar2(writer, scalarType, field.no, value);
      }
      break;
    case "message":
      if (repeated) {
        assert(Array.isArray(value));
        for (const item of value) {
          writeMessageField(writer, options, field, item);
        }
      } else {
        writeMessageField(writer, options, field, value);
      }
      break;
    case "map":
      assert(typeof value == "object" && value != null);
      for (const [key, val] of Object.entries(value)) {
        writeMapEntry(writer, options, field, key, val);
      }
      break;
  }
}
function writeMapEntry(writer, options, field, key, value) {
  writer.tag(field.no, WireType.LengthDelimited);
  writer.fork();
  let keyValue = key;
  switch (field.K) {
    case ScalarType.INT32:
    case ScalarType.FIXED32:
    case ScalarType.UINT32:
    case ScalarType.SFIXED32:
    case ScalarType.SINT32:
      keyValue = Number.parseInt(key);
      break;
    case ScalarType.BOOL:
      assert(key == "true" || key == "false");
      keyValue = key == "true";
      break;
  }
  writeScalar2(writer, field.K, 1, keyValue);
  switch (field.V.kind) {
    case "scalar":
      writeScalar2(writer, field.V.T, 2, value);
      break;
    case "enum":
      writeScalar2(writer, ScalarType.INT32, 2, value);
      break;
    case "message":
      assert(value !== void 0);
      writer.tag(2, WireType.LengthDelimited).bytes(value.toBinary(options));
      break;
  }
  writer.join();
}
function writeMessageField(writer, options, field, value) {
  const message2 = wrapField(field.T, value);
  if (field.delimited)
    writer.tag(field.no, WireType.StartGroup).raw(message2.toBinary(options)).tag(field.no, WireType.EndGroup);
  else
    writer.tag(field.no, WireType.LengthDelimited).bytes(message2.toBinary(options));
}
function writeScalar2(writer, type, fieldNo, value) {
  assert(value !== void 0);
  let [wireType, method] = scalarTypeInfo(type);
  writer.tag(fieldNo, wireType)[method](value);
}
function writePacked(writer, type, fieldNo, value) {
  if (!value.length) {
    return;
  }
  writer.tag(fieldNo, WireType.LengthDelimited).fork();
  let [, method] = scalarTypeInfo(type);
  for (let i = 0; i < value.length; i++) {
    writer[method](value[i]);
  }
  writer.join();
}
function scalarTypeInfo(type) {
  let wireType = WireType.Varint;
  switch (type) {
    case ScalarType.BYTES:
    case ScalarType.STRING:
      wireType = WireType.LengthDelimited;
      break;
    case ScalarType.DOUBLE:
    case ScalarType.FIXED64:
    case ScalarType.SFIXED64:
      wireType = WireType.Bit64;
      break;
    case ScalarType.FIXED32:
    case ScalarType.SFIXED32:
    case ScalarType.FLOAT:
      wireType = WireType.Bit32;
      break;
  }
  const method = ScalarType[type].toLowerCase();
  return [wireType, method];
}

// node_modules/@bufbuild/protobuf/dist/esm/private/util-common.js
init_checked_fetch();
init_modules_watch_stub();
function makeUtilCommon() {
  return {
    setEnumType,
    initPartial(source, target) {
      if (source === void 0) {
        return;
      }
      const type = target.getType();
      for (const member of type.fields.byMember()) {
        const localName = member.localName, t = target, s = source;
        if (s[localName] === void 0) {
          continue;
        }
        switch (member.kind) {
          case "oneof":
            const sk = s[localName].case;
            if (sk === void 0) {
              continue;
            }
            const sourceField = member.findField(sk);
            let val = s[localName].value;
            if (sourceField && sourceField.kind == "message" && !isMessage(val, sourceField.T)) {
              val = new sourceField.T(val);
            } else if (sourceField && sourceField.kind === "scalar" && sourceField.T === ScalarType.BYTES) {
              val = toU8Arr(val);
            }
            t[localName] = { case: sk, value: val };
            break;
          case "scalar":
          case "enum":
            let copy = s[localName];
            if (member.T === ScalarType.BYTES) {
              copy = member.repeated ? copy.map(toU8Arr) : toU8Arr(copy);
            }
            t[localName] = copy;
            break;
          case "map":
            switch (member.V.kind) {
              case "scalar":
              case "enum":
                if (member.V.T === ScalarType.BYTES) {
                  for (const [k, v] of Object.entries(s[localName])) {
                    t[localName][k] = toU8Arr(v);
                  }
                } else {
                  Object.assign(t[localName], s[localName]);
                }
                break;
              case "message":
                const messageType = member.V.T;
                for (const k of Object.keys(s[localName])) {
                  let val2 = s[localName][k];
                  if (!messageType.fieldWrapper) {
                    val2 = new messageType(val2);
                  }
                  t[localName][k] = val2;
                }
                break;
            }
            break;
          case "message":
            const mt2 = member.T;
            if (member.repeated) {
              t[localName] = s[localName].map((val2) => isMessage(val2, mt2) ? val2 : new mt2(val2));
            } else {
              const val2 = s[localName];
              if (mt2.fieldWrapper) {
                if (
                  // We can't use BytesValue.typeName as that will create a circular import
                  mt2.typeName === "google.protobuf.BytesValue"
                ) {
                  t[localName] = toU8Arr(val2);
                } else {
                  t[localName] = val2;
                }
              } else {
                t[localName] = isMessage(val2, mt2) ? val2 : new mt2(val2);
              }
            }
            break;
        }
      }
    },
    // TODO use isFieldSet() here to support future field presence
    equals(type, a, b) {
      if (a === b) {
        return true;
      }
      if (!a || !b) {
        return false;
      }
      return type.fields.byMember().every((m2) => {
        const va2 = a[m2.localName];
        const vb = b[m2.localName];
        if (m2.repeated) {
          if (va2.length !== vb.length) {
            return false;
          }
          switch (m2.kind) {
            case "message":
              return va2.every((a2, i) => m2.T.equals(a2, vb[i]));
            case "scalar":
              return va2.every((a2, i) => scalarEquals(m2.T, a2, vb[i]));
            case "enum":
              return va2.every((a2, i) => scalarEquals(ScalarType.INT32, a2, vb[i]));
          }
          throw new Error(`repeated cannot contain ${m2.kind}`);
        }
        switch (m2.kind) {
          case "message":
            return m2.T.equals(va2, vb);
          case "enum":
            return scalarEquals(ScalarType.INT32, va2, vb);
          case "scalar":
            return scalarEquals(m2.T, va2, vb);
          case "oneof":
            if (va2.case !== vb.case) {
              return false;
            }
            const s = m2.findField(va2.case);
            if (s === void 0) {
              return true;
            }
            switch (s.kind) {
              case "message":
                return s.T.equals(va2.value, vb.value);
              case "enum":
                return scalarEquals(ScalarType.INT32, va2.value, vb.value);
              case "scalar":
                return scalarEquals(s.T, va2.value, vb.value);
            }
            throw new Error(`oneof cannot contain ${s.kind}`);
          case "map":
            const keys = Object.keys(va2).concat(Object.keys(vb));
            switch (m2.V.kind) {
              case "message":
                const messageType = m2.V.T;
                return keys.every((k) => messageType.equals(va2[k], vb[k]));
              case "enum":
                return keys.every((k) => scalarEquals(ScalarType.INT32, va2[k], vb[k]));
              case "scalar":
                const scalarType = m2.V.T;
                return keys.every((k) => scalarEquals(scalarType, va2[k], vb[k]));
            }
            break;
        }
      });
    },
    // TODO use isFieldSet() here to support future field presence
    clone(message2) {
      const type = message2.getType(), target = new type(), any = target;
      for (const member of type.fields.byMember()) {
        const source = message2[member.localName];
        let copy;
        if (member.repeated) {
          copy = source.map(cloneSingularField);
        } else if (member.kind == "map") {
          copy = any[member.localName];
          for (const [key, v] of Object.entries(source)) {
            copy[key] = cloneSingularField(v);
          }
        } else if (member.kind == "oneof") {
          const f = member.findField(source.case);
          copy = f ? { case: source.case, value: cloneSingularField(source.value) } : { case: void 0 };
        } else {
          copy = cloneSingularField(source);
        }
        any[member.localName] = copy;
      }
      return target;
    }
  };
}
function cloneSingularField(value) {
  if (value === void 0) {
    return value;
  }
  if (isMessage(value)) {
    return value.clone();
  }
  if (value instanceof Uint8Array) {
    const c = new Uint8Array(value.byteLength);
    c.set(value);
    return c;
  }
  return value;
}
function toU8Arr(input) {
  return input instanceof Uint8Array ? input : new Uint8Array(input);
}

// node_modules/@bufbuild/protobuf/dist/esm/private/proto-runtime.js
function makeProtoRuntime(syntax, newFieldList, initFields) {
  return {
    syntax,
    json: makeJsonFormat(),
    bin: makeBinaryFormat(),
    util: Object.assign(Object.assign({}, makeUtilCommon()), {
      newFieldList,
      initFields
    }),
    makeMessageType(typeName, fields, opt) {
      return makeMessageType(this, typeName, fields, opt);
    },
    makeEnum,
    makeEnumType,
    getEnumType,
    makeExtension(typeName, extendee, field) {
      return makeExtension(this, typeName, extendee, field);
    }
  };
}

// node_modules/@bufbuild/protobuf/dist/esm/private/field-list.js
init_checked_fetch();
init_modules_watch_stub();
var InternalFieldList = class {
  constructor(fields, normalizer) {
    this._fields = fields;
    this._normalizer = normalizer;
  }
  findJsonName(jsonName) {
    if (!this.jsonNames) {
      const t = {};
      for (const f of this.list()) {
        t[f.jsonName] = t[f.name] = f;
      }
      this.jsonNames = t;
    }
    return this.jsonNames[jsonName];
  }
  find(fieldNo) {
    if (!this.numbers) {
      const t = {};
      for (const f of this.list()) {
        t[f.no] = f;
      }
      this.numbers = t;
    }
    return this.numbers[fieldNo];
  }
  list() {
    if (!this.all) {
      this.all = this._normalizer(this._fields);
    }
    return this.all;
  }
  byNumber() {
    if (!this.numbersAsc) {
      this.numbersAsc = this.list().concat().sort((a, b) => a.no - b.no);
    }
    return this.numbersAsc;
  }
  byMember() {
    if (!this.members) {
      this.members = [];
      const a = this.members;
      let o;
      for (const f of this.list()) {
        if (f.oneof) {
          if (f.oneof !== o) {
            o = f.oneof;
            a.push(o);
          }
        } else {
          a.push(f);
        }
      }
    }
    return this.members;
  }
};

// node_modules/@bufbuild/protobuf/dist/esm/private/field-normalize.js
init_checked_fetch();
init_modules_watch_stub();

// node_modules/@bufbuild/protobuf/dist/esm/private/field.js
init_checked_fetch();
init_modules_watch_stub();

// node_modules/@bufbuild/protobuf/dist/esm/private/names.js
init_checked_fetch();
init_modules_watch_stub();
function localFieldName(protoName, inOneof) {
  const name = protoCamelCase(protoName);
  if (inOneof) {
    return name;
  }
  return safeObjectProperty(safeMessageProperty(name));
}
function localOneofName(protoName) {
  return localFieldName(protoName, false);
}
var fieldJsonName = protoCamelCase;
function protoCamelCase(snakeCase) {
  let capNext = false;
  const b = [];
  for (let i = 0; i < snakeCase.length; i++) {
    let c = snakeCase.charAt(i);
    switch (c) {
      case "_":
        capNext = true;
        break;
      case "0":
      case "1":
      case "2":
      case "3":
      case "4":
      case "5":
      case "6":
      case "7":
      case "8":
      case "9":
        b.push(c);
        capNext = false;
        break;
      default:
        if (capNext) {
          capNext = false;
          c = c.toUpperCase();
        }
        b.push(c);
        break;
    }
  }
  return b.join("");
}
var reservedObjectProperties = /* @__PURE__ */ new Set([
  // names reserved by JavaScript
  "constructor",
  "toString",
  "toJSON",
  "valueOf"
]);
var reservedMessageProperties = /* @__PURE__ */ new Set([
  // names reserved by the runtime
  "getType",
  "clone",
  "equals",
  "fromBinary",
  "fromJson",
  "fromJsonString",
  "toBinary",
  "toJson",
  "toJsonString",
  // names reserved by the runtime for the future
  "toObject"
]);
var fallback = (name) => `${name}$`;
var safeMessageProperty = (name) => {
  if (reservedMessageProperties.has(name)) {
    return fallback(name);
  }
  return name;
};
var safeObjectProperty = (name) => {
  if (reservedObjectProperties.has(name)) {
    return fallback(name);
  }
  return name;
};

// node_modules/@bufbuild/protobuf/dist/esm/private/field.js
var InternalOneofInfo = class {
  constructor(name) {
    this.kind = "oneof";
    this.repeated = false;
    this.packed = false;
    this.opt = false;
    this.req = false;
    this.default = void 0;
    this.fields = [];
    this.name = name;
    this.localName = localOneofName(name);
  }
  addField(field) {
    assert(field.oneof === this, `field ${field.name} not one of ${this.name}`);
    this.fields.push(field);
  }
  findField(localName) {
    if (!this._lookup) {
      this._lookup = /* @__PURE__ */ Object.create(null);
      for (let i = 0; i < this.fields.length; i++) {
        this._lookup[this.fields[i].localName] = this.fields[i];
      }
    }
    return this._lookup[localName];
  }
};

// node_modules/@bufbuild/protobuf/dist/esm/private/field-normalize.js
function normalizeFieldInfos(fieldInfos, packedByDefault) {
  var _a2, _b, _c, _d2, _e, _f2;
  const r2 = [];
  let o;
  for (const field of typeof fieldInfos == "function" ? fieldInfos() : fieldInfos) {
    const f = field;
    f.localName = localFieldName(field.name, field.oneof !== void 0);
    f.jsonName = (_a2 = field.jsonName) !== null && _a2 !== void 0 ? _a2 : fieldJsonName(field.name);
    f.repeated = (_b = field.repeated) !== null && _b !== void 0 ? _b : false;
    if (field.kind == "scalar") {
      f.L = (_c = field.L) !== null && _c !== void 0 ? _c : LongType.BIGINT;
    }
    f.delimited = (_d2 = field.delimited) !== null && _d2 !== void 0 ? _d2 : false;
    f.req = (_e = field.req) !== null && _e !== void 0 ? _e : false;
    f.opt = (_f2 = field.opt) !== null && _f2 !== void 0 ? _f2 : false;
    if (field.packed === void 0) {
      if (packedByDefault) {
        f.packed = field.kind == "enum" || field.kind == "scalar" && field.T != ScalarType.BYTES && field.T != ScalarType.STRING;
      } else {
        f.packed = false;
      }
    }
    if (field.oneof !== void 0) {
      const ooname = typeof field.oneof == "string" ? field.oneof : field.oneof.name;
      if (!o || o.name != ooname) {
        o = new InternalOneofInfo(ooname);
      }
      f.oneof = o;
      o.addField(f);
    }
    r2.push(f);
  }
  return r2;
}

// node_modules/@bufbuild/protobuf/dist/esm/proto3.js
var proto3 = makeProtoRuntime(
  "proto3",
  (fields) => {
    return new InternalFieldList(fields, (source) => normalizeFieldInfos(source, true));
  },
  // TODO merge with proto2 and initExtensionField, also see initPartial, equals, clone
  (target) => {
    for (const member of target.getType().fields.byMember()) {
      if (member.opt) {
        continue;
      }
      const name = member.localName, t = target;
      if (member.repeated) {
        t[name] = [];
        continue;
      }
      switch (member.kind) {
        case "oneof":
          t[name] = { case: void 0 };
          break;
        case "enum":
          t[name] = 0;
          break;
        case "map":
          t[name] = {};
          break;
        case "scalar":
          t[name] = scalarZeroValue(member.T, member.L);
          break;
        case "message":
          break;
      }
    }
  }
);

// node_modules/frog/_lib/protobufs/generated/username_proof_pb.js
init_checked_fetch();
init_modules_watch_stub();
var UserNameType;
(function(UserNameType2) {
  UserNameType2[UserNameType2["USERNAME_TYPE_NONE"] = 0] = "USERNAME_TYPE_NONE";
  UserNameType2[UserNameType2["USERNAME_TYPE_FNAME"] = 1] = "USERNAME_TYPE_FNAME";
  UserNameType2[UserNameType2["USERNAME_TYPE_ENS_L1"] = 2] = "USERNAME_TYPE_ENS_L1";
})(UserNameType || (UserNameType = {}));
proto3.util.setEnumType(UserNameType, "UserNameType", [
  { no: 0, name: "USERNAME_TYPE_NONE" },
  { no: 1, name: "USERNAME_TYPE_FNAME" },
  { no: 2, name: "USERNAME_TYPE_ENS_L1" }
]);
var UserNameProof = class extends Message {
  constructor(data) {
    super();
    Object.defineProperty(this, "timestamp", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: protoInt64.zero
    });
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: new Uint8Array(0)
    });
    Object.defineProperty(this, "owner", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: new Uint8Array(0)
    });
    Object.defineProperty(this, "signature", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: new Uint8Array(0)
    });
    Object.defineProperty(this, "fid", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: protoInt64.zero
    });
    Object.defineProperty(this, "type", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: UserNameType.USERNAME_TYPE_NONE
    });
    proto3.util.initPartial(data, this);
  }
  static fromBinary(bytes4, options) {
    return new UserNameProof().fromBinary(bytes4, options);
  }
  static fromJson(jsonValue, options) {
    return new UserNameProof().fromJson(jsonValue, options);
  }
  static fromJsonString(jsonString, options) {
    return new UserNameProof().fromJsonString(jsonString, options);
  }
  static equals(a, b) {
    return proto3.util.equals(UserNameProof, a, b);
  }
};
Object.defineProperty(UserNameProof, "runtime", {
  enumerable: true,
  configurable: true,
  writable: true,
  value: proto3
});
Object.defineProperty(UserNameProof, "typeName", {
  enumerable: true,
  configurable: true,
  writable: true,
  value: "UserNameProof"
});
Object.defineProperty(UserNameProof, "fields", {
  enumerable: true,
  configurable: true,
  writable: true,
  value: proto3.util.newFieldList(() => [
    {
      no: 1,
      name: "timestamp",
      kind: "scalar",
      T: 4
      /* ScalarType.UINT64 */
    },
    {
      no: 2,
      name: "name",
      kind: "scalar",
      T: 12
      /* ScalarType.BYTES */
    },
    {
      no: 3,
      name: "owner",
      kind: "scalar",
      T: 12
      /* ScalarType.BYTES */
    },
    {
      no: 4,
      name: "signature",
      kind: "scalar",
      T: 12
      /* ScalarType.BYTES */
    },
    {
      no: 5,
      name: "fid",
      kind: "scalar",
      T: 4
      /* ScalarType.UINT64 */
    },
    { no: 6, name: "type", kind: "enum", T: proto3.getEnumType(UserNameType) }
  ])
});

// node_modules/frog/_lib/protobufs/generated/message_pb.js
var HashScheme;
(function(HashScheme2) {
  HashScheme2[HashScheme2["NONE"] = 0] = "NONE";
  HashScheme2[HashScheme2["BLAKE3"] = 1] = "BLAKE3";
})(HashScheme || (HashScheme = {}));
proto3.util.setEnumType(HashScheme, "HashScheme", [
  { no: 0, name: "HASH_SCHEME_NONE" },
  { no: 1, name: "HASH_SCHEME_BLAKE3" }
]);
var SignatureScheme;
(function(SignatureScheme2) {
  SignatureScheme2[SignatureScheme2["NONE"] = 0] = "NONE";
  SignatureScheme2[SignatureScheme2["ED25519"] = 1] = "ED25519";
  SignatureScheme2[SignatureScheme2["EIP712"] = 2] = "EIP712";
})(SignatureScheme || (SignatureScheme = {}));
proto3.util.setEnumType(SignatureScheme, "SignatureScheme", [
  { no: 0, name: "SIGNATURE_SCHEME_NONE" },
  { no: 1, name: "SIGNATURE_SCHEME_ED25519" },
  { no: 2, name: "SIGNATURE_SCHEME_EIP712" }
]);
var MessageType;
(function(MessageType2) {
  MessageType2[MessageType2["NONE"] = 0] = "NONE";
  MessageType2[MessageType2["CAST_ADD"] = 1] = "CAST_ADD";
  MessageType2[MessageType2["CAST_REMOVE"] = 2] = "CAST_REMOVE";
  MessageType2[MessageType2["REACTION_ADD"] = 3] = "REACTION_ADD";
  MessageType2[MessageType2["REACTION_REMOVE"] = 4] = "REACTION_REMOVE";
  MessageType2[MessageType2["LINK_ADD"] = 5] = "LINK_ADD";
  MessageType2[MessageType2["LINK_REMOVE"] = 6] = "LINK_REMOVE";
  MessageType2[MessageType2["VERIFICATION_ADD_ETH_ADDRESS"] = 7] = "VERIFICATION_ADD_ETH_ADDRESS";
  MessageType2[MessageType2["VERIFICATION_REMOVE"] = 8] = "VERIFICATION_REMOVE";
  MessageType2[MessageType2["USER_DATA_ADD"] = 11] = "USER_DATA_ADD";
  MessageType2[MessageType2["USERNAME_PROOF"] = 12] = "USERNAME_PROOF";
  MessageType2[MessageType2["FRAME_ACTION"] = 13] = "FRAME_ACTION";
})(MessageType || (MessageType = {}));
proto3.util.setEnumType(MessageType, "MessageType", [
  { no: 0, name: "MESSAGE_TYPE_NONE" },
  { no: 1, name: "MESSAGE_TYPE_CAST_ADD" },
  { no: 2, name: "MESSAGE_TYPE_CAST_REMOVE" },
  { no: 3, name: "MESSAGE_TYPE_REACTION_ADD" },
  { no: 4, name: "MESSAGE_TYPE_REACTION_REMOVE" },
  { no: 5, name: "MESSAGE_TYPE_LINK_ADD" },
  { no: 6, name: "MESSAGE_TYPE_LINK_REMOVE" },
  { no: 7, name: "MESSAGE_TYPE_VERIFICATION_ADD_ETH_ADDRESS" },
  { no: 8, name: "MESSAGE_TYPE_VERIFICATION_REMOVE" },
  { no: 11, name: "MESSAGE_TYPE_USER_DATA_ADD" },
  { no: 12, name: "MESSAGE_TYPE_USERNAME_PROOF" },
  { no: 13, name: "MESSAGE_TYPE_FRAME_ACTION" }
]);
var FarcasterNetwork;
(function(FarcasterNetwork2) {
  FarcasterNetwork2[FarcasterNetwork2["NONE"] = 0] = "NONE";
  FarcasterNetwork2[FarcasterNetwork2["MAINNET"] = 1] = "MAINNET";
  FarcasterNetwork2[FarcasterNetwork2["TESTNET"] = 2] = "TESTNET";
  FarcasterNetwork2[FarcasterNetwork2["DEVNET"] = 3] = "DEVNET";
})(FarcasterNetwork || (FarcasterNetwork = {}));
proto3.util.setEnumType(FarcasterNetwork, "FarcasterNetwork", [
  { no: 0, name: "FARCASTER_NETWORK_NONE" },
  { no: 1, name: "FARCASTER_NETWORK_MAINNET" },
  { no: 2, name: "FARCASTER_NETWORK_TESTNET" },
  { no: 3, name: "FARCASTER_NETWORK_DEVNET" }
]);
var UserDataType;
(function(UserDataType2) {
  UserDataType2[UserDataType2["NONE"] = 0] = "NONE";
  UserDataType2[UserDataType2["PFP"] = 1] = "PFP";
  UserDataType2[UserDataType2["DISPLAY"] = 2] = "DISPLAY";
  UserDataType2[UserDataType2["BIO"] = 3] = "BIO";
  UserDataType2[UserDataType2["URL"] = 5] = "URL";
  UserDataType2[UserDataType2["USERNAME"] = 6] = "USERNAME";
})(UserDataType || (UserDataType = {}));
proto3.util.setEnumType(UserDataType, "UserDataType", [
  { no: 0, name: "USER_DATA_TYPE_NONE" },
  { no: 1, name: "USER_DATA_TYPE_PFP" },
  { no: 2, name: "USER_DATA_TYPE_DISPLAY" },
  { no: 3, name: "USER_DATA_TYPE_BIO" },
  { no: 5, name: "USER_DATA_TYPE_URL" },
  { no: 6, name: "USER_DATA_TYPE_USERNAME" }
]);
var ReactionType;
(function(ReactionType2) {
  ReactionType2[ReactionType2["NONE"] = 0] = "NONE";
  ReactionType2[ReactionType2["LIKE"] = 1] = "LIKE";
  ReactionType2[ReactionType2["RECAST"] = 2] = "RECAST";
})(ReactionType || (ReactionType = {}));
proto3.util.setEnumType(ReactionType, "ReactionType", [
  { no: 0, name: "REACTION_TYPE_NONE" },
  { no: 1, name: "REACTION_TYPE_LIKE" },
  { no: 2, name: "REACTION_TYPE_RECAST" }
]);
var Protocol;
(function(Protocol2) {
  Protocol2[Protocol2["ETHEREUM"] = 0] = "ETHEREUM";
  Protocol2[Protocol2["SOLANA"] = 1] = "SOLANA";
})(Protocol || (Protocol = {}));
proto3.util.setEnumType(Protocol, "Protocol", [
  { no: 0, name: "PROTOCOL_ETHEREUM" },
  { no: 1, name: "PROTOCOL_SOLANA" }
]);
var Message2 = class extends Message {
  constructor(data) {
    super();
    Object.defineProperty(this, "data", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "hash", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: new Uint8Array(0)
    });
    Object.defineProperty(this, "hashScheme", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: HashScheme.NONE
    });
    Object.defineProperty(this, "signature", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: new Uint8Array(0)
    });
    Object.defineProperty(this, "signatureScheme", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: SignatureScheme.NONE
    });
    Object.defineProperty(this, "signer", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: new Uint8Array(0)
    });
    Object.defineProperty(this, "dataBytes", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    proto3.util.initPartial(data, this);
  }
  static fromBinary(bytes4, options) {
    return new Message2().fromBinary(bytes4, options);
  }
  static fromJson(jsonValue, options) {
    return new Message2().fromJson(jsonValue, options);
  }
  static fromJsonString(jsonString, options) {
    return new Message2().fromJsonString(jsonString, options);
  }
  static equals(a, b) {
    return proto3.util.equals(Message2, a, b);
  }
};
Object.defineProperty(Message2, "runtime", {
  enumerable: true,
  configurable: true,
  writable: true,
  value: proto3
});
Object.defineProperty(Message2, "typeName", {
  enumerable: true,
  configurable: true,
  writable: true,
  value: "Message"
});
Object.defineProperty(Message2, "fields", {
  enumerable: true,
  configurable: true,
  writable: true,
  value: proto3.util.newFieldList(() => [
    { no: 1, name: "data", kind: "message", T: MessageData },
    {
      no: 2,
      name: "hash",
      kind: "scalar",
      T: 12
      /* ScalarType.BYTES */
    },
    { no: 3, name: "hash_scheme", kind: "enum", T: proto3.getEnumType(HashScheme) },
    {
      no: 4,
      name: "signature",
      kind: "scalar",
      T: 12
      /* ScalarType.BYTES */
    },
    { no: 5, name: "signature_scheme", kind: "enum", T: proto3.getEnumType(SignatureScheme) },
    {
      no: 6,
      name: "signer",
      kind: "scalar",
      T: 12
      /* ScalarType.BYTES */
    },
    { no: 7, name: "data_bytes", kind: "scalar", T: 12, opt: true }
  ])
});
var MessageData = class extends Message {
  constructor(data) {
    super();
    Object.defineProperty(this, "type", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: MessageType.NONE
    });
    Object.defineProperty(this, "fid", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: protoInt64.zero
    });
    Object.defineProperty(this, "timestamp", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: 0
    });
    Object.defineProperty(this, "network", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: FarcasterNetwork.NONE
    });
    Object.defineProperty(this, "body", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: { case: void 0 }
    });
    proto3.util.initPartial(data, this);
  }
  static fromBinary(bytes4, options) {
    return new MessageData().fromBinary(bytes4, options);
  }
  static fromJson(jsonValue, options) {
    return new MessageData().fromJson(jsonValue, options);
  }
  static fromJsonString(jsonString, options) {
    return new MessageData().fromJsonString(jsonString, options);
  }
  static equals(a, b) {
    return proto3.util.equals(MessageData, a, b);
  }
};
Object.defineProperty(MessageData, "runtime", {
  enumerable: true,
  configurable: true,
  writable: true,
  value: proto3
});
Object.defineProperty(MessageData, "typeName", {
  enumerable: true,
  configurable: true,
  writable: true,
  value: "MessageData"
});
Object.defineProperty(MessageData, "fields", {
  enumerable: true,
  configurable: true,
  writable: true,
  value: proto3.util.newFieldList(() => [
    { no: 1, name: "type", kind: "enum", T: proto3.getEnumType(MessageType) },
    {
      no: 2,
      name: "fid",
      kind: "scalar",
      T: 4
      /* ScalarType.UINT64 */
    },
    {
      no: 3,
      name: "timestamp",
      kind: "scalar",
      T: 13
      /* ScalarType.UINT32 */
    },
    { no: 4, name: "network", kind: "enum", T: proto3.getEnumType(FarcasterNetwork) },
    { no: 5, name: "cast_add_body", kind: "message", T: CastAddBody, oneof: "body" },
    { no: 6, name: "cast_remove_body", kind: "message", T: CastRemoveBody, oneof: "body" },
    { no: 7, name: "reaction_body", kind: "message", T: ReactionBody, oneof: "body" },
    { no: 9, name: "verification_add_address_body", kind: "message", T: VerificationAddAddressBody, oneof: "body" },
    { no: 10, name: "verification_remove_body", kind: "message", T: VerificationRemoveBody, oneof: "body" },
    { no: 12, name: "user_data_body", kind: "message", T: UserDataBody, oneof: "body" },
    { no: 14, name: "link_body", kind: "message", T: LinkBody, oneof: "body" },
    { no: 15, name: "username_proof_body", kind: "message", T: UserNameProof, oneof: "body" },
    { no: 16, name: "frame_action_body", kind: "message", T: FrameActionBody, oneof: "body" }
  ])
});
var UserDataBody = class extends Message {
  constructor(data) {
    super();
    Object.defineProperty(this, "type", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: UserDataType.NONE
    });
    Object.defineProperty(this, "value", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: ""
    });
    proto3.util.initPartial(data, this);
  }
  static fromBinary(bytes4, options) {
    return new UserDataBody().fromBinary(bytes4, options);
  }
  static fromJson(jsonValue, options) {
    return new UserDataBody().fromJson(jsonValue, options);
  }
  static fromJsonString(jsonString, options) {
    return new UserDataBody().fromJsonString(jsonString, options);
  }
  static equals(a, b) {
    return proto3.util.equals(UserDataBody, a, b);
  }
};
Object.defineProperty(UserDataBody, "runtime", {
  enumerable: true,
  configurable: true,
  writable: true,
  value: proto3
});
Object.defineProperty(UserDataBody, "typeName", {
  enumerable: true,
  configurable: true,
  writable: true,
  value: "UserDataBody"
});
Object.defineProperty(UserDataBody, "fields", {
  enumerable: true,
  configurable: true,
  writable: true,
  value: proto3.util.newFieldList(() => [
    { no: 1, name: "type", kind: "enum", T: proto3.getEnumType(UserDataType) },
    {
      no: 2,
      name: "value",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    }
  ])
});
var Embed = class extends Message {
  constructor(data) {
    super();
    Object.defineProperty(this, "embed", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: { case: void 0 }
    });
    proto3.util.initPartial(data, this);
  }
  static fromBinary(bytes4, options) {
    return new Embed().fromBinary(bytes4, options);
  }
  static fromJson(jsonValue, options) {
    return new Embed().fromJson(jsonValue, options);
  }
  static fromJsonString(jsonString, options) {
    return new Embed().fromJsonString(jsonString, options);
  }
  static equals(a, b) {
    return proto3.util.equals(Embed, a, b);
  }
};
Object.defineProperty(Embed, "runtime", {
  enumerable: true,
  configurable: true,
  writable: true,
  value: proto3
});
Object.defineProperty(Embed, "typeName", {
  enumerable: true,
  configurable: true,
  writable: true,
  value: "Embed"
});
Object.defineProperty(Embed, "fields", {
  enumerable: true,
  configurable: true,
  writable: true,
  value: proto3.util.newFieldList(() => [
    { no: 1, name: "url", kind: "scalar", T: 9, oneof: "embed" },
    { no: 2, name: "cast_id", kind: "message", T: CastId, oneof: "embed" }
  ])
});
var CastAddBody = class extends Message {
  constructor(data) {
    super();
    Object.defineProperty(this, "embedsDeprecated", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: []
    });
    Object.defineProperty(this, "mentions", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: []
    });
    Object.defineProperty(this, "parent", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: { case: void 0 }
    });
    Object.defineProperty(this, "text", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: ""
    });
    Object.defineProperty(this, "mentionsPositions", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: []
    });
    Object.defineProperty(this, "embeds", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: []
    });
    proto3.util.initPartial(data, this);
  }
  static fromBinary(bytes4, options) {
    return new CastAddBody().fromBinary(bytes4, options);
  }
  static fromJson(jsonValue, options) {
    return new CastAddBody().fromJson(jsonValue, options);
  }
  static fromJsonString(jsonString, options) {
    return new CastAddBody().fromJsonString(jsonString, options);
  }
  static equals(a, b) {
    return proto3.util.equals(CastAddBody, a, b);
  }
};
Object.defineProperty(CastAddBody, "runtime", {
  enumerable: true,
  configurable: true,
  writable: true,
  value: proto3
});
Object.defineProperty(CastAddBody, "typeName", {
  enumerable: true,
  configurable: true,
  writable: true,
  value: "CastAddBody"
});
Object.defineProperty(CastAddBody, "fields", {
  enumerable: true,
  configurable: true,
  writable: true,
  value: proto3.util.newFieldList(() => [
    { no: 1, name: "embeds_deprecated", kind: "scalar", T: 9, repeated: true },
    { no: 2, name: "mentions", kind: "scalar", T: 4, repeated: true },
    { no: 3, name: "parent_cast_id", kind: "message", T: CastId, oneof: "parent" },
    { no: 7, name: "parent_url", kind: "scalar", T: 9, oneof: "parent" },
    {
      no: 4,
      name: "text",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    { no: 5, name: "mentions_positions", kind: "scalar", T: 13, repeated: true },
    { no: 6, name: "embeds", kind: "message", T: Embed, repeated: true }
  ])
});
var CastRemoveBody = class extends Message {
  constructor(data) {
    super();
    Object.defineProperty(this, "targetHash", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: new Uint8Array(0)
    });
    proto3.util.initPartial(data, this);
  }
  static fromBinary(bytes4, options) {
    return new CastRemoveBody().fromBinary(bytes4, options);
  }
  static fromJson(jsonValue, options) {
    return new CastRemoveBody().fromJson(jsonValue, options);
  }
  static fromJsonString(jsonString, options) {
    return new CastRemoveBody().fromJsonString(jsonString, options);
  }
  static equals(a, b) {
    return proto3.util.equals(CastRemoveBody, a, b);
  }
};
Object.defineProperty(CastRemoveBody, "runtime", {
  enumerable: true,
  configurable: true,
  writable: true,
  value: proto3
});
Object.defineProperty(CastRemoveBody, "typeName", {
  enumerable: true,
  configurable: true,
  writable: true,
  value: "CastRemoveBody"
});
Object.defineProperty(CastRemoveBody, "fields", {
  enumerable: true,
  configurable: true,
  writable: true,
  value: proto3.util.newFieldList(() => [
    {
      no: 1,
      name: "target_hash",
      kind: "scalar",
      T: 12
      /* ScalarType.BYTES */
    }
  ])
});
var CastId = class extends Message {
  constructor(data) {
    super();
    Object.defineProperty(this, "fid", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: protoInt64.zero
    });
    Object.defineProperty(this, "hash", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: new Uint8Array(0)
    });
    proto3.util.initPartial(data, this);
  }
  static fromBinary(bytes4, options) {
    return new CastId().fromBinary(bytes4, options);
  }
  static fromJson(jsonValue, options) {
    return new CastId().fromJson(jsonValue, options);
  }
  static fromJsonString(jsonString, options) {
    return new CastId().fromJsonString(jsonString, options);
  }
  static equals(a, b) {
    return proto3.util.equals(CastId, a, b);
  }
};
Object.defineProperty(CastId, "runtime", {
  enumerable: true,
  configurable: true,
  writable: true,
  value: proto3
});
Object.defineProperty(CastId, "typeName", {
  enumerable: true,
  configurable: true,
  writable: true,
  value: "CastId"
});
Object.defineProperty(CastId, "fields", {
  enumerable: true,
  configurable: true,
  writable: true,
  value: proto3.util.newFieldList(() => [
    {
      no: 1,
      name: "fid",
      kind: "scalar",
      T: 4
      /* ScalarType.UINT64 */
    },
    {
      no: 2,
      name: "hash",
      kind: "scalar",
      T: 12
      /* ScalarType.BYTES */
    }
  ])
});
var ReactionBody = class extends Message {
  constructor(data) {
    super();
    Object.defineProperty(this, "type", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: ReactionType.NONE
    });
    Object.defineProperty(this, "target", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: { case: void 0 }
    });
    proto3.util.initPartial(data, this);
  }
  static fromBinary(bytes4, options) {
    return new ReactionBody().fromBinary(bytes4, options);
  }
  static fromJson(jsonValue, options) {
    return new ReactionBody().fromJson(jsonValue, options);
  }
  static fromJsonString(jsonString, options) {
    return new ReactionBody().fromJsonString(jsonString, options);
  }
  static equals(a, b) {
    return proto3.util.equals(ReactionBody, a, b);
  }
};
Object.defineProperty(ReactionBody, "runtime", {
  enumerable: true,
  configurable: true,
  writable: true,
  value: proto3
});
Object.defineProperty(ReactionBody, "typeName", {
  enumerable: true,
  configurable: true,
  writable: true,
  value: "ReactionBody"
});
Object.defineProperty(ReactionBody, "fields", {
  enumerable: true,
  configurable: true,
  writable: true,
  value: proto3.util.newFieldList(() => [
    { no: 1, name: "type", kind: "enum", T: proto3.getEnumType(ReactionType) },
    { no: 2, name: "target_cast_id", kind: "message", T: CastId, oneof: "target" },
    { no: 3, name: "target_url", kind: "scalar", T: 9, oneof: "target" }
  ])
});
var VerificationAddAddressBody = class extends Message {
  constructor(data) {
    super();
    Object.defineProperty(this, "address", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: new Uint8Array(0)
    });
    Object.defineProperty(this, "claimSignature", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: new Uint8Array(0)
    });
    Object.defineProperty(this, "blockHash", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: new Uint8Array(0)
    });
    Object.defineProperty(this, "verificationType", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: 0
    });
    Object.defineProperty(this, "chainId", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: 0
    });
    Object.defineProperty(this, "protocol", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: Protocol.ETHEREUM
    });
    proto3.util.initPartial(data, this);
  }
  static fromBinary(bytes4, options) {
    return new VerificationAddAddressBody().fromBinary(bytes4, options);
  }
  static fromJson(jsonValue, options) {
    return new VerificationAddAddressBody().fromJson(jsonValue, options);
  }
  static fromJsonString(jsonString, options) {
    return new VerificationAddAddressBody().fromJsonString(jsonString, options);
  }
  static equals(a, b) {
    return proto3.util.equals(VerificationAddAddressBody, a, b);
  }
};
Object.defineProperty(VerificationAddAddressBody, "runtime", {
  enumerable: true,
  configurable: true,
  writable: true,
  value: proto3
});
Object.defineProperty(VerificationAddAddressBody, "typeName", {
  enumerable: true,
  configurable: true,
  writable: true,
  value: "VerificationAddAddressBody"
});
Object.defineProperty(VerificationAddAddressBody, "fields", {
  enumerable: true,
  configurable: true,
  writable: true,
  value: proto3.util.newFieldList(() => [
    {
      no: 1,
      name: "address",
      kind: "scalar",
      T: 12
      /* ScalarType.BYTES */
    },
    {
      no: 2,
      name: "claim_signature",
      kind: "scalar",
      T: 12
      /* ScalarType.BYTES */
    },
    {
      no: 3,
      name: "block_hash",
      kind: "scalar",
      T: 12
      /* ScalarType.BYTES */
    },
    {
      no: 4,
      name: "verification_type",
      kind: "scalar",
      T: 13
      /* ScalarType.UINT32 */
    },
    {
      no: 5,
      name: "chain_id",
      kind: "scalar",
      T: 13
      /* ScalarType.UINT32 */
    },
    { no: 7, name: "protocol", kind: "enum", T: proto3.getEnumType(Protocol) }
  ])
});
var VerificationRemoveBody = class extends Message {
  constructor(data) {
    super();
    Object.defineProperty(this, "address", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: new Uint8Array(0)
    });
    Object.defineProperty(this, "protocol", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: Protocol.ETHEREUM
    });
    proto3.util.initPartial(data, this);
  }
  static fromBinary(bytes4, options) {
    return new VerificationRemoveBody().fromBinary(bytes4, options);
  }
  static fromJson(jsonValue, options) {
    return new VerificationRemoveBody().fromJson(jsonValue, options);
  }
  static fromJsonString(jsonString, options) {
    return new VerificationRemoveBody().fromJsonString(jsonString, options);
  }
  static equals(a, b) {
    return proto3.util.equals(VerificationRemoveBody, a, b);
  }
};
Object.defineProperty(VerificationRemoveBody, "runtime", {
  enumerable: true,
  configurable: true,
  writable: true,
  value: proto3
});
Object.defineProperty(VerificationRemoveBody, "typeName", {
  enumerable: true,
  configurable: true,
  writable: true,
  value: "VerificationRemoveBody"
});
Object.defineProperty(VerificationRemoveBody, "fields", {
  enumerable: true,
  configurable: true,
  writable: true,
  value: proto3.util.newFieldList(() => [
    {
      no: 1,
      name: "address",
      kind: "scalar",
      T: 12
      /* ScalarType.BYTES */
    },
    { no: 2, name: "protocol", kind: "enum", T: proto3.getEnumType(Protocol) }
  ])
});
var LinkBody = class extends Message {
  constructor(data) {
    super();
    Object.defineProperty(this, "type", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: ""
    });
    Object.defineProperty(this, "displayTimestamp", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "target", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: { case: void 0 }
    });
    proto3.util.initPartial(data, this);
  }
  static fromBinary(bytes4, options) {
    return new LinkBody().fromBinary(bytes4, options);
  }
  static fromJson(jsonValue, options) {
    return new LinkBody().fromJson(jsonValue, options);
  }
  static fromJsonString(jsonString, options) {
    return new LinkBody().fromJsonString(jsonString, options);
  }
  static equals(a, b) {
    return proto3.util.equals(LinkBody, a, b);
  }
};
Object.defineProperty(LinkBody, "runtime", {
  enumerable: true,
  configurable: true,
  writable: true,
  value: proto3
});
Object.defineProperty(LinkBody, "typeName", {
  enumerable: true,
  configurable: true,
  writable: true,
  value: "LinkBody"
});
Object.defineProperty(LinkBody, "fields", {
  enumerable: true,
  configurable: true,
  writable: true,
  value: proto3.util.newFieldList(() => [
    {
      no: 1,
      name: "type",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    { no: 2, name: "displayTimestamp", kind: "scalar", T: 13, opt: true },
    { no: 3, name: "target_fid", kind: "scalar", T: 4, oneof: "target" }
  ])
});
var FrameActionBody = class extends Message {
  constructor(data) {
    super();
    Object.defineProperty(this, "url", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: new Uint8Array(0)
    });
    Object.defineProperty(this, "buttonIndex", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: 0
    });
    Object.defineProperty(this, "castId", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "inputText", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: new Uint8Array(0)
    });
    Object.defineProperty(this, "state", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: new Uint8Array(0)
    });
    Object.defineProperty(this, "transactionId", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: new Uint8Array(0)
    });
    Object.defineProperty(this, "address", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: new Uint8Array(0)
    });
    proto3.util.initPartial(data, this);
  }
  static fromBinary(bytes4, options) {
    return new FrameActionBody().fromBinary(bytes4, options);
  }
  static fromJson(jsonValue, options) {
    return new FrameActionBody().fromJson(jsonValue, options);
  }
  static fromJsonString(jsonString, options) {
    return new FrameActionBody().fromJsonString(jsonString, options);
  }
  static equals(a, b) {
    return proto3.util.equals(FrameActionBody, a, b);
  }
};
Object.defineProperty(FrameActionBody, "runtime", {
  enumerable: true,
  configurable: true,
  writable: true,
  value: proto3
});
Object.defineProperty(FrameActionBody, "typeName", {
  enumerable: true,
  configurable: true,
  writable: true,
  value: "FrameActionBody"
});
Object.defineProperty(FrameActionBody, "fields", {
  enumerable: true,
  configurable: true,
  writable: true,
  value: proto3.util.newFieldList(() => [
    {
      no: 1,
      name: "url",
      kind: "scalar",
      T: 12
      /* ScalarType.BYTES */
    },
    {
      no: 2,
      name: "button_index",
      kind: "scalar",
      T: 13
      /* ScalarType.UINT32 */
    },
    { no: 3, name: "cast_id", kind: "message", T: CastId },
    {
      no: 4,
      name: "input_text",
      kind: "scalar",
      T: 12
      /* ScalarType.BYTES */
    },
    {
      no: 5,
      name: "state",
      kind: "scalar",
      T: 12
      /* ScalarType.BYTES */
    },
    {
      no: 6,
      name: "transaction_id",
      kind: "scalar",
      T: 12
      /* ScalarType.BYTES */
    },
    {
      no: 7,
      name: "address",
      kind: "scalar",
      T: 12
      /* ScalarType.BYTES */
    }
  ])
});

// node_modules/frog/_lib/utils/verifyFrame.js
async function verifyFrame({ frameUrl, hub, trustedData, url }) {
  const body = hexToBytes(`0x${trustedData.messageBytes}`);
  const response = await fetch(`${hub.apiUrl}/v1/validateMessage`, {
    ...hub.fetchOptions,
    method: "POST",
    headers: {
      "Content-Type": "application/octet-stream",
      ...hub.fetchOptions?.headers
    },
    body
  }).then((res) => res.json());
  if (!response.valid)
    throw new Error(`message is invalid. ${response.details}`);
  if (!parsePath(url)?.startsWith(parsePath(frameUrl)))
    throw new Error(`Invalid frame url: ${frameUrl}. Expected: ${url}.`);
  const message2 = Message2.fromBinary(body);
  const frameData = messageToFrameData(message2);
  return { frameData };
}
function messageToFrameData(message2) {
  const frameActionBody = message2.data?.body.value;
  const frameData = {
    address: frameActionBody.address ? bytesToHex(frameActionBody.address) : void 0,
    castId: {
      fid: Number(frameActionBody.castId?.fid),
      hash: bytesToHex(frameActionBody.castId?.hash)
    },
    fid: Number(message2.data?.fid),
    messageHash: bytesToHex(message2.hash),
    network: message2.data?.network,
    timestamp: message2.data?.timestamp,
    url: bytesToString(frameActionBody.url),
    buttonIndex: frameActionBody.buttonIndex,
    inputText: bytesToString(frameActionBody.inputText),
    state: bytesToString(frameActionBody.state),
    transactionId: frameActionBody.transactionId ? bytesToHex(frameActionBody.transactionId) : void 0
  };
  return frameData;
}

// node_modules/frog/_lib/utils/requestBodyToContext.js
async function requestBodyToContext(c, { hub, secret, verify: verify3 = true }) {
  const { trustedData, untrustedData } = await c.req.json().catch(() => {
  }) || {};
  const { initialPath, previousState, previousButtonValues } = await (async () => {
    if (untrustedData?.state) {
      const state = deserializeJson(untrustedData.state);
      if (secret && state.previousState)
        state.previousState = JSON.parse(await verify2(state.previousState, secret));
      return state;
    }
    if (c.req.query())
      return fromQuery(c.req.query());
    return {};
  })();
  const trustedFrameData = await (async () => {
    if (verify3 === false)
      return null;
    if (!trustedData)
      return null;
    if (!hub)
      return null;
    try {
      const { frameData } = await verifyFrame({
        hub,
        frameUrl: untrustedData.url,
        trustedData,
        url: c.req.url
      });
      return { ...frameData, state: frameData.state || untrustedData.state };
    } catch (err) {
      if (verify3 === "silent")
        return null;
      throw err;
    }
  })();
  return {
    env: c.env,
    initialPath: initialPath ? initialPath : new URL(c.req.url).pathname,
    previousState,
    previousButtonValues,
    frameData: trustedFrameData || untrustedData,
    req: c.req,
    status: c.req.method === "POST" ? "response" : "initial",
    url: c.req.url,
    var: c.var,
    verified: Boolean(trustedFrameData)
  };
}

// node_modules/frog/_lib/utils/serializeJson.js
init_checked_fetch();
init_modules_watch_stub();
function serializeJson(data = {}) {
  return encodeURIComponent(JSON.stringify(data));
}

// node_modules/frog/_lib/utils/toSearchParams.js
init_checked_fetch();
init_modules_watch_stub();
function toSearchParams(object) {
  const params = new URLSearchParams();
  for (const [key, value] of Object.entries(object)) {
    const encoded = (() => {
      if (typeof value === "string")
        return encodeURIComponent(value);
      if (typeof value === "number")
        return value.toString();
      if (typeof value === "boolean")
        return value.toString();
      if (typeof value === "object" && value !== null) {
        return encodeURIComponent(Array.isArray(value) ? `#A_${value.join(",")}` : `#O_${JSON.stringify(value)}`);
      }
      return void 0;
    })();
    if (encoded)
      params.set(key, encoded);
  }
  return params;
}

// node_modules/frog/_lib/version.js
init_checked_fetch();
init_modules_watch_stub();
var version2 = "0.6.5";

// node_modules/frog/_lib/frog-base.js
var FrogBase = class {
  constructor({ assetsPath, basePath, browserLocation, dev, headers, honoOptions, hubApiUrl, hub, imageAspectRatio, imageOptions, initialState, origin, secret, verify: verify3 } = {}) {
    Object.defineProperty(this, "_initialState", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "assetsPath", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "basePath", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "browserLocation", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "dev", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "headers", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "hono", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "hubApiUrl", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "hub", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "imageAspectRatio", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "1.91:1"
    });
    Object.defineProperty(this, "imageOptions", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "origin", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "fetch", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "get", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "post", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "secret", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "verify", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: true
    });
    Object.defineProperty(this, "frame", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: (...parameters) => {
        const [path, middlewares, handler, options = {}] = getRouteParameters(...parameters);
        const { verify: verify4 = this.verify } = options;
        this.hono.use(parsePath(path), ...middlewares, async (c) => {
          const url = new URL(c.req.url);
          const origin2 = this.origin ?? url.origin;
          const assetsUrl = origin2 + parsePath(this.assetsPath);
          const baseUrl = origin2 + parsePath(this.basePath);
          const { context, getState } = getFrameContext({
            context: await requestBodyToContext(c, {
              hub: this.hub || (this.hubApiUrl ? { apiUrl: this.hubApiUrl } : void 0),
              secret: this.secret,
              verify: verify4
            }),
            initialState: this._initialState,
            origin: origin2
          });
          if (context.url !== parsePath(c.req.url))
            return c.redirect(context.url);
          const response = await handler(context);
          if (response instanceof Response)
            return response;
          const { action, browserLocation: browserLocation2 = this.browserLocation, headers: headers2 = this.headers, imageAspectRatio: imageAspectRatio2 = this.imageAspectRatio, image, imageOptions: imageOptions2, intents, ogImage, title = "Frog Frame" } = response.data;
          const buttonValues = getButtonValues(parseIntents(intents));
          if (context.status === "redirect" && context.buttonIndex) {
            const buttonValue = buttonValues[context.buttonIndex - 1];
            const location = buttonValue?.replace(/^_r:/, "");
            if (!location)
              throw new Error("location required to redirect");
            return c.redirect(location, 302);
          }
          const browser = detect(c.req.header("user-agent"));
          const browserLocation_ = parseBrowserLocation(c, browserLocation2, {
            basePath: this.basePath,
            path
          });
          if (browser?.name && browserLocation_)
            return c.redirect(browserLocation_.startsWith("http") ? browserLocation_ : `${origin2 + import_path_browserify.default.resolve(this.basePath, browserLocation_)}`, 302);
          const previousState = await (async () => {
            const state = await context.deriveState();
            if (!this.secret)
              return state;
            if (!state)
              return state;
            return sign2(JSON.stringify(state), this.secret);
          })();
          const nextFrameStateSearch = toSearchParams({
            initialPath: context.initialPath,
            previousButtonValues: buttonValues
          });
          const nextFrameStateMeta = serializeJson({
            initialPath: context.initialPath,
            previousButtonValues: buttonValues,
            previousState
          });
          const imageUrl = await (async () => {
            if (typeof image !== "string") {
              const encodedImage = import_lz_string.default.compressToEncodedURIComponent(JSON.stringify(await parseImage(image, { assetsUrl })));
              const imageParams = toSearchParams({
                image: encodedImage,
                imageOptions: imageOptions2 ? {
                  ...imageOptions2,
                  // TODO: Remove once `fonts` is removed from `imageOptions`.
                  fonts: void 0
                } : void 0,
                headers: headers2
              });
              return `${parsePath(context.url)}/image?${imageParams}`;
            }
            if (image.startsWith("http") || image.startsWith("data"))
              return image;
            return `${assetsUrl + parsePath(image)}`;
          })();
          const ogImageUrl = (() => {
            if (!ogImage)
              return void 0;
            if (ogImage.startsWith("http"))
              return ogImage;
            return baseUrl + parsePath(ogImage);
          })();
          const postUrl = (() => {
            if (!action)
              return context.url;
            if (action.startsWith("http"))
              return action;
            return baseUrl + parsePath(action);
          })();
          const parsedIntents = parseIntents(intents, {
            baseUrl,
            search: context.status === "initial" ? nextFrameStateSearch.toString() : void 0
          });
          for (const [key, value] of Object.entries(headers2 ?? {}))
            c.header(key, value);
          const isDevEnabled = (
            // check if devtools are enabled on constructor.
            (this.dev?.enabled ?? true) && // check if route has `/dev` path.
            this.hono.routes.some((r2) => {
              const currentFullPath = (this.basePath === "/" ? "" : this.basePath) + parsePath(path);
              if (!r2.path.startsWith(currentFullPath))
                return false;
              if (!r2.path.includes("/dev"))
                return false;
              return true;
            })
          );
          const serializedContext = serializeJson({
            ...context,
            // note: unserializable entities are undefined.
            env: context.env ? Object.assign(context.env, {
              incoming: void 0,
              outgoing: void 0
            }) : void 0,
            req: void 0,
            state: getState()
          });
          const body = isDevEnabled ? jsxDEV2("body", { style: {
            alignItems: "center",
            display: "flex",
            justifyContent: "center",
            minHeight: "100vh",
            overflow: "hidden"
          }, children: jsxDEV2("a", { style: { textDecoration: "none" }, href: `${context.url}/dev`, children: "open \u{1D487}\u{1D493}\u{1D482}\u{1D48E}\u{1D486} devtools" }) }) : jsxDEV2("body", {});
          return c.render(jsxDEV2(Fragment2, { children: [html`<!DOCTYPE html>`, jsxDEV2("html", { lang: "en", children: [jsxDEV2("head", { children: [jsxDEV2("meta", { property: "fc:frame", content: "vNext" }), jsxDEV2("meta", { property: "fc:frame:image:aspect_ratio", content: imageAspectRatio2 }), jsxDEV2("meta", { property: "fc:frame:image", content: imageUrl }), jsxDEV2("meta", { property: "og:image", content: ogImageUrl ?? imageUrl }), jsxDEV2("meta", { property: "og:title", content: title }), jsxDEV2("meta", { property: "fc:frame:post_url", content: context.status === "initial" ? `${postUrl}?${nextFrameStateSearch.toString()}` : postUrl }), context.status !== "initial" && jsxDEV2("meta", { property: "fc:frame:state", content: nextFrameStateMeta }), parsedIntents, isDevEnabled && jsxDEV2("meta", { property: "frog:context", content: serializedContext }), jsxDEV2("meta", { property: "frog:version", content: version2 })] }), body] })] }));
        });
        this.hono.get(`${parsePath(path)}/image`, async (c) => {
          const defaultImageOptions = await (async () => {
            if (typeof this.imageOptions === "function")
              return await this.imageOptions();
            return this.imageOptions;
          })();
          const fonts = await (async () => {
            if (typeof options?.fonts === "function")
              return await options.fonts();
            if (options?.fonts)
              return options.fonts;
            return defaultImageOptions?.fonts;
          })();
          const { headers: headers2 = this.headers, image, imageOptions: imageOptions2 = defaultImageOptions } = fromQuery(c.req.query());
          const image_ = JSON.parse(import_lz_string.default.decompressFromEncodedURIComponent(image));
          return new ImageResponse(image_, {
            ...imageOptions2,
            fonts: await parseFonts(fonts),
            headers: imageOptions2?.headers ?? headers2
          });
        });
        return this;
      }
    });
    Object.defineProperty(this, "transaction", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: (...parameters) => {
        const [path, middlewares, handler, options = {}] = getRouteParameters(...parameters);
        const { verify: verify4 = this.verify } = options;
        this.hono.post(parsePath(path), ...middlewares, async (c) => {
          const { context } = getTransactionContext({
            context: await requestBodyToContext(c, {
              hub: this.hub || (this.hubApiUrl ? { apiUrl: this.hubApiUrl } : void 0),
              secret: this.secret,
              verify: verify4
            }),
            req: c.req
          });
          const response = await handler(context);
          if (response instanceof Response)
            return response;
          return c.json(response.data);
        });
        return this;
      }
    });
    Object.defineProperty(this, "use", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: (...args) => {
        this.hono.use(...args);
        return this;
      }
    });
    this.hono = new Hono2(honoOptions);
    if (basePath)
      this.hono = this.hono.basePath(basePath);
    if (browserLocation)
      this.browserLocation = browserLocation;
    if (headers)
      this.headers = headers;
    if (dev)
      this.dev = { enabled: true, ...dev ?? {} };
    if (hubApiUrl)
      this.hubApiUrl = hubApiUrl;
    if (hub)
      this.hub = hub;
    if (imageAspectRatio)
      this.imageAspectRatio = imageAspectRatio;
    if (imageOptions)
      this.imageOptions = imageOptions;
    if (origin)
      this.origin = origin;
    if (secret)
      this.secret = secret;
    if (typeof verify3 !== "undefined")
      this.verify = verify3;
    this.basePath = basePath ?? "/";
    this.assetsPath = assetsPath ?? this.basePath;
    this.fetch = this.hono.fetch.bind(this.hono);
    this.get = this.hono.get.bind(this.hono);
    this.post = this.hono.post.bind(this.hono);
    if (initialState)
      this._initialState = initialState;
  }
  route(path, frog) {
    if (frog.assetsPath === "/")
      frog.assetsPath = this.assetsPath;
    if (frog.basePath === "/")
      frog.basePath = parsePath(this.basePath) + parsePath(path);
    if (!frog.browserLocation)
      frog.browserLocation = this.browserLocation;
    if (!frog.dev)
      frog.dev = this.dev;
    if (!frog.headers)
      frog.headers = this.headers;
    if (!frog.hubApiUrl)
      frog.hubApiUrl = this.hubApiUrl;
    if (!frog.hub)
      frog.hub = this.hub;
    if (!frog.imageOptions)
      frog.imageOptions = this.imageOptions;
    if (!frog.origin)
      frog.origin = this.origin;
    if (!frog.secret)
      frog.secret = this.secret;
    if (!frog.verify)
      frog.verify = this.verify;
    this.hono.route(path, frog.hono);
    return this;
  }
};

// src/routes/poap.tsx
init_checked_fetch();
init_modules_watch_stub();

// node_modules/@kodadot1/uniquery/dist/index.mjs
init_checked_fetch();
init_modules_watch_stub();

// node_modules/ofetch/dist/index.mjs
init_checked_fetch();
init_modules_watch_stub();

// node_modules/ofetch/dist/shared/ofetch.00501375.mjs
init_checked_fetch();
init_modules_watch_stub();

// node_modules/destr/dist/index.mjs
init_checked_fetch();
init_modules_watch_stub();
var suspectProtoRx = /"(?:_|\\u0{2}5[Ff]){2}(?:p|\\u0{2}70)(?:r|\\u0{2}72)(?:o|\\u0{2}6[Ff])(?:t|\\u0{2}74)(?:o|\\u0{2}6[Ff])(?:_|\\u0{2}5[Ff]){2}"\s*:/;
var suspectConstructorRx = /"(?:c|\\u0063)(?:o|\\u006[Ff])(?:n|\\u006[Ee])(?:s|\\u0073)(?:t|\\u0074)(?:r|\\u0072)(?:u|\\u0075)(?:c|\\u0063)(?:t|\\u0074)(?:o|\\u006[Ff])(?:r|\\u0072)"\s*:/;
var JsonSigRx = /^\s*["[{]|^\s*-?\d{1,16}(\.\d{1,17})?([Ee][+-]?\d+)?\s*$/;
function jsonParseTransform(key, value) {
  if (key === "__proto__" || key === "constructor" && value && typeof value === "object" && "prototype" in value) {
    warnKeyDropped(key);
    return;
  }
  return value;
}
function warnKeyDropped(key) {
  console.warn(`[destr] Dropping "${key}" key to prevent prototype pollution.`);
}
function destr(value, options = {}) {
  if (typeof value !== "string") {
    return value;
  }
  const _value = value.trim();
  if (
    // eslint-disable-next-line unicorn/prefer-at
    value[0] === '"' && value.endsWith('"') && !value.includes("\\")
  ) {
    return _value.slice(1, -1);
  }
  if (_value.length <= 9) {
    const _lval = _value.toLowerCase();
    if (_lval === "true") {
      return true;
    }
    if (_lval === "false") {
      return false;
    }
    if (_lval === "undefined") {
      return void 0;
    }
    if (_lval === "null") {
      return null;
    }
    if (_lval === "nan") {
      return Number.NaN;
    }
    if (_lval === "infinity") {
      return Number.POSITIVE_INFINITY;
    }
    if (_lval === "-infinity") {
      return Number.NEGATIVE_INFINITY;
    }
  }
  if (!JsonSigRx.test(value)) {
    if (options.strict) {
      throw new SyntaxError("[destr] Invalid JSON");
    }
    return value;
  }
  try {
    if (suspectProtoRx.test(value) || suspectConstructorRx.test(value)) {
      if (options.strict) {
        throw new Error("[destr] Possible prototype pollution");
      }
      return JSON.parse(value, jsonParseTransform);
    }
    return JSON.parse(value);
  } catch (error) {
    if (options.strict) {
      throw error;
    }
    return value;
  }
}

// node_modules/ufo/dist/index.mjs
init_checked_fetch();
init_modules_watch_stub();
var r = String.fromCharCode;
var HASH_RE = /#/g;
var AMPERSAND_RE = /&/g;
var SLASH_RE = /\//g;
var EQUAL_RE = /=/g;
var PLUS_RE = /\+/g;
var ENC_CARET_RE = /%5e/gi;
var ENC_BACKTICK_RE = /%60/gi;
var ENC_PIPE_RE = /%7c/gi;
var ENC_SPACE_RE = /%20/gi;
function encode2(text) {
  return encodeURI("" + text).replace(ENC_PIPE_RE, "|");
}
function encodeQueryValue(input) {
  return encode2(typeof input === "string" ? input : JSON.stringify(input)).replace(PLUS_RE, "%2B").replace(ENC_SPACE_RE, "+").replace(HASH_RE, "%23").replace(AMPERSAND_RE, "%26").replace(ENC_BACKTICK_RE, "`").replace(ENC_CARET_RE, "^").replace(SLASH_RE, "%2F");
}
function encodeQueryKey(text) {
  return encodeQueryValue(text).replace(EQUAL_RE, "%3D");
}
function decode3(text = "") {
  try {
    return decodeURIComponent("" + text);
  } catch {
    return "" + text;
  }
}
function decodeQueryKey(text) {
  return decode3(text.replace(PLUS_RE, " "));
}
function decodeQueryValue(text) {
  return decode3(text.replace(PLUS_RE, " "));
}
function parseQuery(parametersString = "") {
  const object = {};
  if (parametersString[0] === "?") {
    parametersString = parametersString.slice(1);
  }
  for (const parameter of parametersString.split("&")) {
    const s = parameter.match(/([^=]+)=?(.*)/) || [];
    if (s.length < 2) {
      continue;
    }
    const key = decodeQueryKey(s[1]);
    if (key === "__proto__" || key === "constructor") {
      continue;
    }
    const value = decodeQueryValue(s[2] || "");
    if (object[key] === void 0) {
      object[key] = value;
    } else if (Array.isArray(object[key])) {
      object[key].push(value);
    } else {
      object[key] = [object[key], value];
    }
  }
  return object;
}
function encodeQueryItem(key, value) {
  if (typeof value === "number" || typeof value === "boolean") {
    value = String(value);
  }
  if (!value) {
    return encodeQueryKey(key);
  }
  if (Array.isArray(value)) {
    return value.map((_value) => `${encodeQueryKey(key)}=${encodeQueryValue(_value)}`).join("&");
  }
  return `${encodeQueryKey(key)}=${encodeQueryValue(value)}`;
}
function stringifyQuery(query2) {
  return Object.keys(query2).filter((k) => query2[k] !== void 0).map((k) => encodeQueryItem(k, query2[k])).filter(Boolean).join("&");
}
var PROTOCOL_STRICT_REGEX = /^[\s\w\0+.-]{2,}:([/\\]{1,2})/;
var PROTOCOL_REGEX = /^[\s\w\0+.-]{2,}:([/\\]{2})?/;
var PROTOCOL_RELATIVE_REGEX = /^([/\\]\s*){2,}[^/\\]/;
var TRAILING_SLASH_RE = /\/$|\/\?|\/#/;
var JOIN_LEADING_SLASH_RE = /^\.?\//;
function hasProtocol(inputString, opts = {}) {
  if (typeof opts === "boolean") {
    opts = { acceptRelative: opts };
  }
  if (opts.strict) {
    return PROTOCOL_STRICT_REGEX.test(inputString);
  }
  return PROTOCOL_REGEX.test(inputString) || (opts.acceptRelative ? PROTOCOL_RELATIVE_REGEX.test(inputString) : false);
}
function hasTrailingSlash(input = "", respectQueryAndFragment) {
  if (!respectQueryAndFragment) {
    return input.endsWith("/");
  }
  return TRAILING_SLASH_RE.test(input);
}
function withoutTrailingSlash(input = "", respectQueryAndFragment) {
  if (!respectQueryAndFragment) {
    return (hasTrailingSlash(input) ? input.slice(0, -1) : input) || "/";
  }
  if (!hasTrailingSlash(input, true)) {
    return input || "/";
  }
  let path = input;
  let fragment = "";
  const fragmentIndex = input.indexOf("#");
  if (fragmentIndex >= 0) {
    path = input.slice(0, fragmentIndex);
    fragment = input.slice(fragmentIndex);
  }
  const [s02, ...s] = path.split("?");
  return (s02.slice(0, -1) || "/") + (s.length > 0 ? `?${s.join("?")}` : "") + fragment;
}
function withTrailingSlash(input = "", respectQueryAndFragment) {
  if (!respectQueryAndFragment) {
    return input.endsWith("/") ? input : input + "/";
  }
  if (hasTrailingSlash(input, true)) {
    return input || "/";
  }
  let path = input;
  let fragment = "";
  const fragmentIndex = input.indexOf("#");
  if (fragmentIndex >= 0) {
    path = input.slice(0, fragmentIndex);
    fragment = input.slice(fragmentIndex);
    if (!path) {
      return fragment;
    }
  }
  const [s02, ...s] = path.split("?");
  return s02 + "/" + (s.length > 0 ? `?${s.join("?")}` : "") + fragment;
}
function withBase(input, base) {
  if (isEmptyURL(base) || hasProtocol(input)) {
    return input;
  }
  const _base = withoutTrailingSlash(base);
  if (input.startsWith(_base)) {
    return input;
  }
  return joinURL(_base, input);
}
function withQuery(input, query2) {
  const parsed = parseURL(input);
  const mergedQuery = { ...parseQuery(parsed.search), ...query2 };
  parsed.search = stringifyQuery(mergedQuery);
  return stringifyParsedURL(parsed);
}
function isEmptyURL(url) {
  return !url || url === "/";
}
function isNonEmptyURL(url) {
  return url && url !== "/";
}
function joinURL(base, ...input) {
  let url = base || "";
  for (const segment of input.filter((url2) => isNonEmptyURL(url2))) {
    if (url) {
      const _segment = segment.replace(JOIN_LEADING_SLASH_RE, "");
      url = withTrailingSlash(url) + _segment;
    } else {
      url = segment;
    }
  }
  return url;
}
var protocolRelative = Symbol.for("ufo:protocolRelative");
function parseURL(input = "", defaultProto) {
  const _specialProtoMatch = input.match(
    /^[\s\0]*(blob:|data:|javascript:|vbscript:)(.*)/i
  );
  if (_specialProtoMatch) {
    const [, _proto, _pathname = ""] = _specialProtoMatch;
    return {
      protocol: _proto.toLowerCase(),
      pathname: _pathname,
      href: _proto + _pathname,
      auth: "",
      host: "",
      search: "",
      hash: ""
    };
  }
  if (!hasProtocol(input, { acceptRelative: true })) {
    return defaultProto ? parseURL(defaultProto + input) : parsePath2(input);
  }
  const [, protocol = "", auth, hostAndPath = ""] = input.replace(/\\/g, "/").match(/^[\s\0]*([\w+.-]{2,}:)?\/\/([^/@]+@)?(.*)/) || [];
  const [, host = "", path = ""] = hostAndPath.match(/([^#/?]*)(.*)?/) || [];
  const { pathname, search, hash: hash2 } = parsePath2(
    path.replace(/\/(?=[A-Za-z]:)/, "")
  );
  return {
    protocol: protocol.toLowerCase(),
    auth: auth ? auth.slice(0, Math.max(0, auth.length - 1)) : "",
    host,
    pathname,
    search,
    hash: hash2,
    [protocolRelative]: !protocol
  };
}
function parsePath2(input = "") {
  const [pathname = "", search = "", hash2 = ""] = (input.match(/([^#?]*)(\?[^#]*)?(#.*)?/) || []).splice(1);
  return {
    pathname,
    search,
    hash: hash2
  };
}
function stringifyParsedURL(parsed) {
  const pathname = parsed.pathname || "";
  const search = parsed.search ? (parsed.search.startsWith("?") ? "" : "?") + parsed.search : "";
  const hash2 = parsed.hash || "";
  const auth = parsed.auth ? parsed.auth + "@" : "";
  const host = parsed.host || "";
  const proto = parsed.protocol || parsed[protocolRelative] ? (parsed.protocol || "") + "//" : "";
  return proto + auth + host + pathname + search + hash2;
}

// node_modules/ofetch/dist/shared/ofetch.00501375.mjs
var FetchError = class extends Error {
  constructor(message2, opts) {
    super(message2, opts);
    this.name = "FetchError";
    if (opts?.cause && !this.cause) {
      this.cause = opts.cause;
    }
  }
};
function createFetchError(ctx) {
  const errorMessage = ctx.error?.message || ctx.error?.toString() || "";
  const method = ctx.request?.method || ctx.options?.method || "GET";
  const url = ctx.request?.url || String(ctx.request) || "/";
  const requestStr = `[${method}] ${JSON.stringify(url)}`;
  const statusStr = ctx.response ? `${ctx.response.status} ${ctx.response.statusText}` : "<no response>";
  const message2 = `${requestStr}: ${statusStr}${errorMessage ? ` ${errorMessage}` : ""}`;
  const fetchError = new FetchError(
    message2,
    ctx.error ? { cause: ctx.error } : void 0
  );
  for (const key of ["request", "options", "response"]) {
    Object.defineProperty(fetchError, key, {
      get() {
        return ctx[key];
      }
    });
  }
  for (const [key, refKey] of [
    ["data", "_data"],
    ["status", "status"],
    ["statusCode", "status"],
    ["statusText", "statusText"],
    ["statusMessage", "statusText"]
  ]) {
    Object.defineProperty(fetchError, key, {
      get() {
        return ctx.response && ctx.response[refKey];
      }
    });
  }
  return fetchError;
}
var payloadMethods = new Set(
  Object.freeze(["PATCH", "POST", "PUT", "DELETE"])
);
function isPayloadMethod(method = "GET") {
  return payloadMethods.has(method.toUpperCase());
}
function isJSONSerializable(value) {
  if (value === void 0) {
    return false;
  }
  const t = typeof value;
  if (t === "string" || t === "number" || t === "boolean" || t === null) {
    return true;
  }
  if (t !== "object") {
    return false;
  }
  if (Array.isArray(value)) {
    return true;
  }
  if (value.buffer) {
    return false;
  }
  return value.constructor && value.constructor.name === "Object" || typeof value.toJSON === "function";
}
var textTypes = /* @__PURE__ */ new Set([
  "image/svg",
  "application/xml",
  "application/xhtml",
  "application/html"
]);
var JSON_RE = /^application\/(?:[\w!#$%&*.^`~-]*\+)?json(;.+)?$/i;
function detectResponseType(_contentType = "") {
  if (!_contentType) {
    return "json";
  }
  const contentType = _contentType.split(";").shift() || "";
  if (JSON_RE.test(contentType)) {
    return "json";
  }
  if (textTypes.has(contentType) || contentType.startsWith("text/")) {
    return "text";
  }
  return "blob";
}
function mergeFetchOptions(input, defaults2, Headers3 = globalThis.Headers) {
  const merged = {
    ...defaults2,
    ...input
  };
  if (defaults2?.params && input?.params) {
    merged.params = {
      ...defaults2?.params,
      ...input?.params
    };
  }
  if (defaults2?.query && input?.query) {
    merged.query = {
      ...defaults2?.query,
      ...input?.query
    };
  }
  if (defaults2?.headers && input?.headers) {
    merged.headers = new Headers3(defaults2?.headers || {});
    for (const [key, value] of new Headers3(input?.headers || {})) {
      merged.headers.set(key, value);
    }
  }
  return merged;
}
var retryStatusCodes = /* @__PURE__ */ new Set([
  408,
  // Request Timeout
  409,
  // Conflict
  425,
  // Too Early
  429,
  // Too Many Requests
  500,
  // Internal Server Error
  502,
  // Bad Gateway
  503,
  // Service Unavailable
  504
  //  Gateway Timeout
]);
var nullBodyResponses = /* @__PURE__ */ new Set([101, 204, 205, 304]);
function createFetch(globalOptions = {}) {
  const {
    fetch: fetch3 = globalThis.fetch,
    Headers: Headers3 = globalThis.Headers,
    AbortController: AbortController3 = globalThis.AbortController
  } = globalOptions;
  async function onError(context) {
    const isAbort = context.error && context.error.name === "AbortError" && !context.options.timeout || false;
    if (context.options.retry !== false && !isAbort) {
      let retries;
      if (typeof context.options.retry === "number") {
        retries = context.options.retry;
      } else {
        retries = isPayloadMethod(context.options.method) ? 0 : 1;
      }
      const responseCode = context.response && context.response.status || 500;
      if (retries > 0 && (Array.isArray(context.options.retryStatusCodes) ? context.options.retryStatusCodes.includes(responseCode) : retryStatusCodes.has(responseCode))) {
        const retryDelay = context.options.retryDelay || 0;
        if (retryDelay > 0) {
          await new Promise((resolve) => setTimeout(resolve, retryDelay));
        }
        return $fetchRaw(context.request, {
          ...context.options,
          retry: retries - 1,
          timeout: context.options.timeout
        });
      }
    }
    const error = createFetchError(context);
    if (Error.captureStackTrace) {
      Error.captureStackTrace(error, $fetchRaw);
    }
    throw error;
  }
  const $fetchRaw = async function $fetchRaw2(_request, _options = {}) {
    const context = {
      request: _request,
      options: mergeFetchOptions(_options, globalOptions.defaults, Headers3),
      response: void 0,
      error: void 0
    };
    context.options.method = context.options.method?.toUpperCase();
    if (context.options.onRequest) {
      await context.options.onRequest(context);
    }
    if (typeof context.request === "string") {
      if (context.options.baseURL) {
        context.request = withBase(context.request, context.options.baseURL);
      }
      if (context.options.query || context.options.params) {
        context.request = withQuery(context.request, {
          ...context.options.params,
          ...context.options.query
        });
      }
    }
    if (context.options.body && isPayloadMethod(context.options.method)) {
      if (isJSONSerializable(context.options.body)) {
        context.options.body = typeof context.options.body === "string" ? context.options.body : JSON.stringify(context.options.body);
        context.options.headers = new Headers3(context.options.headers || {});
        if (!context.options.headers.has("content-type")) {
          context.options.headers.set("content-type", "application/json");
        }
        if (!context.options.headers.has("accept")) {
          context.options.headers.set("accept", "application/json");
        }
      } else if (
        // ReadableStream Body
        "pipeTo" in context.options.body && typeof context.options.body.pipeTo === "function" || // Node.js Stream Body
        typeof context.options.body.pipe === "function"
      ) {
        if (!("duplex" in context.options)) {
          context.options.duplex = "half";
        }
      }
    }
    if (!context.options.signal && context.options.timeout) {
      const controller = new AbortController3();
      setTimeout(() => controller.abort(), context.options.timeout);
      context.options.signal = controller.signal;
    }
    try {
      context.response = await fetch3(
        context.request,
        context.options
      );
    } catch (error) {
      context.error = error;
      if (context.options.onRequestError) {
        await context.options.onRequestError(context);
      }
      return await onError(context);
    }
    const hasBody = context.response.body && !nullBodyResponses.has(context.response.status) && context.options.method !== "HEAD";
    if (hasBody) {
      const responseType = (context.options.parseResponse ? "json" : context.options.responseType) || detectResponseType(context.response.headers.get("content-type") || "");
      switch (responseType) {
        case "json": {
          const data = await context.response.text();
          const parseFunction = context.options.parseResponse || destr;
          context.response._data = parseFunction(data);
          break;
        }
        case "stream": {
          context.response._data = context.response.body;
          break;
        }
        default: {
          context.response._data = await context.response[responseType]();
        }
      }
    }
    if (context.options.onResponse) {
      await context.options.onResponse(context);
    }
    if (!context.options.ignoreResponseError && context.response.status >= 400 && context.response.status < 600) {
      if (context.options.onResponseError) {
        await context.options.onResponseError(context);
      }
      return await onError(context);
    }
    return context.response;
  };
  const $fetch2 = async function $fetch22(request, options) {
    const r2 = await $fetchRaw(request, options);
    return r2._data;
  };
  $fetch2.raw = $fetchRaw;
  $fetch2.native = (...args) => fetch3(...args);
  $fetch2.create = (defaultOptions = {}) => createFetch({
    ...globalOptions,
    defaults: {
      ...globalOptions.defaults,
      ...defaultOptions
    }
  });
  return $fetch2;
}

// node_modules/ofetch/dist/index.mjs
var _globalThis = function() {
  if (typeof globalThis !== "undefined") {
    return globalThis;
  }
  if (typeof self !== "undefined") {
    return self;
  }
  if (typeof window !== "undefined") {
    return window;
  }
  if (typeof global !== "undefined") {
    return global;
  }
  throw new Error("unable to locate global object");
}();
var fetch2 = _globalThis.fetch || (() => Promise.reject(new Error("[ofetch] global.fetch is not supported!")));
var Headers2 = _globalThis.Headers;
var AbortController2 = _globalThis.AbortController;
var ofetch = createFetch({ fetch: fetch2, Headers: Headers2, AbortController: AbortController2 });
var $fetch = ofetch;

// node_modules/@kodadot1/static/dist/index.mjs
init_checked_fetch();
init_modules_watch_stub();
var toChainProperty = (ss58Format, tokenDecimals, tokenSymbol, blockExplorer) => {
  return {
    ss58Format,
    tokenDecimals,
    tokenSymbol,
    blockExplorer
  };
};
var DEFAULT_CHAIN_PROPERTIES = toChainProperty(
  2,
  12,
  "KSM",
  "https://kusama.subscan.io/"
);
var CHAINS = {
  rmrk: DEFAULT_CHAIN_PROPERTIES,
  ksm: DEFAULT_CHAIN_PROPERTIES,
  bsx: toChainProperty(10041, 12, "BSX", "https://basilisk.subscan.io/"),
  ahk: toChainProperty(2, 12, "KSM", "https://statemine.subscan.io/"),
  dot: toChainProperty(0, 10, "DOT", "https://polkadot.subscan.io/"),
  ahp: toChainProperty(0, 10, "DOT", "https://statemint.subscan.io/")
  // ahr: toChainProperty(42, 12, 'ROC', 'https://rockmine.subscan.io/'),
  // movr: toChainProperty(1285, 18, 'MOVR', 'https://moonriver.subscan.io/'),
  // glmr: toChainProperty(1284, 18, 'GLMR', 'https://moonbeam.subscan.io/'),
};
var chainPrefixes = [
  "ahp",
  "ahk",
  "rmrk",
  "ksm",
  "dot",
  "bsx"
  // 'ahr',
  // 'movr',
  // 'glmr',
];
var chainPrefixesMap = chainPrefixes.reduce(
  (acc, prefix) => ({
    ...acc,
    [prefix]: prefix
  }),
  {}
);
var KUSAMA_ENDPOINTS = [
  "wss://kusama-rpc.polkadot.io",
  // 'wss://kusama.public.curie.radiumblock.co/ws', // https://github.com/polkadot-js/apps/issues/9763
  "wss://rpc.ibp.network/kusama",
  "wss://rpc.dotters.network/kusama",
  "wss://1rpc.io/ksm",
  "wss://kusama-rpc.dwellir.com"
];
var POLKADOT_ENDPOINTS = [
  "wss://rpc.polkadot.io",
  "wss://polkadot.public.curie.radiumblock.co/ws",
  "wss://rpc.ibp.network/polkadot",
  "wss://rpc.dotters.network/polkadot",
  "wss://1rpc.io/dot",
  "wss://polkadot-rpc.dwellir.com"
];
var ENDPOINT_MAP = {
  bsx: "wss://rpc.basilisk.cloud",
  rmrk: KUSAMA_ENDPOINTS[0],
  ksm: KUSAMA_ENDPOINTS[0],
  ahk: "wss://kusama-asset-hub-rpc.polkadot.io",
  dot: POLKADOT_ENDPOINTS[0],
  ahp: "wss://polkadot-asset-hub-rpc.polkadot.io"
  // ahr: 'wss://rococo-asset-hub-rpc.polkadot.io',
  // glmr: 'wss://public-rpc.pinknode.io/moonbeam',
  // movr: 'wss://wss.api.moonriver.moonbeam.network',
};
var INDEXERS = {
  bsx: "https://squid.subsquid.io/snekk/graphql",
  rmrk: "https://squid.subsquid.io/rubick/graphql",
  ksm: "https://squid.subsquid.io/marck/v/v2/graphql",
  ahk: "https://query-stick.stellate.sh",
  dot: "https://squid.subsquid.io/rubick/graphql",
  // TODO: change to dot indexer when available
  ahp: "https://squid.subsquid.io/speck/graphql"
  // ahr: 'https://squid.subsquid.io/snack/graphql',
  // movr: 'https://squid.subsquid.io/antick/v/001-rc0/graphql',
  // glmr: 'https://squid.subsquid.io/click/v/002/graphql',
};
var toApolloEndpoint = (httpEndpoint) => ({
  httpEndpoint
});
var reducer = (acc, [key, value]) => {
  acc[key] = toApolloEndpoint(value);
  return acc;
};
var APOLLO_ENDPOINTS = Object.entries(
  INDEXERS
  // eslint-disable-next-line unicorn/no-array-reduce
).reduce(
  (accumulator, element) => reducer(accumulator, element),
  {}
);

// node_modules/@kodadot1/uniquery/dist/index.mjs
var import_gql_query_builder = __toESM(require_build(), 1);
var getOptions = ({
  baseURL,
  query: query2
}) => ({
  baseURL,
  method: "POST",
  body: query2
});
function getUrl$1(chain2, provider = "") {
  const result = INDEXERS[chain2];
  if (!result || provider === "subquery") {
    const message2 = chain2 ? `Indexer for chain ${chain2} not found, allowed values are ${Object.keys(
      INDEXERS
    )}` : `Cannot use fetch for non-existinng chain, add parameter prefix when calling getClient or fetchQuery`;
    throw new ReferenceError(message2);
  }
  return result;
}
function build2(operation, fields, variables) {
  return (0, import_gql_query_builder.query)({
    operation,
    variables,
    fields
  });
}
var defaultField = [
  "id",
  "createdAt",
  "name",
  "image",
  "metadata",
  "currentOwner",
  "issuer"
];
var defaultEventField = [
  "id",
  "interaction",
  "timestamp",
  "caller",
  "meta"
];
var DEFAULT_LIMIT = 200;
var defaultQueryOptions = {
  limit: DEFAULT_LIMIT
};
function hasMetaField(field) {
  return typeof field === "string" && field === "meta";
}
function extendFields(fields) {
  const set = /* @__PURE__ */ new Set([...defaultField, ...fields]);
  return [...set];
}
function getFields(fields, defaultList = defaultField, replaceMetaField = true) {
  const list = fields ?? defaultList;
  if (replaceMetaField) {
    const metaIndex = list.findIndex(hasMetaField);
    if (metaIndex !== -1) {
      list.splice(
        metaIndex,
        1,
        {
          meta: ["id", "name", "description", "image", "animationUrl", "type"]
        }
      );
    }
  }
  return list;
}
function optionToQuery(options, injectDefault = true) {
  const final = injectDefault ? ensureOptions(options) : options;
  let query2 = "";
  if (final.limit) {
    query2 += `limit: ${final.limit}`;
  }
  if (final.offset) {
    query2 += `, offset: ${final.offset}`;
  }
  if (final.orderBy) {
    query2 += `, orderBy: ${final.orderBy}`;
  }
  return query2;
}
function ensureOptions(options) {
  const queryOptions = options ?? {};
  return {
    ...defaultQueryOptions,
    ...queryOptions,
    limit: Math.min(
      queryOptions.limit ?? DEFAULT_LIMIT,
      defaultQueryOptions.limit
    )
  };
}
function includeBurned(options) {
  if (options && options.burned) {
    return "";
  }
  return "burned_eq: false";
}
var entityMap = {
  collection: "collection: collectionEntityById",
  collections: "collections: collectionEntities",
  collectionCount: "collectionCount: collectionEntitiesConnection",
  event: "event: eventEntityById",
  events: "events: events",
  eventCount: "eventCount: eventsConnection",
  item: "item: nftEntityById",
  items: "items: nftEntities",
  itemCount: "itemCount: nftEntitiesConnection"
};
var realEntityName = {
  collection: "CollectionEntity",
  item: "NFTEntity",
  event: "Event"
};
function addWhere(whereType, whereValue) {
  if (whereValue) {
    return {
      where: {
        type: whereType,
        value: whereValue
      }
    };
  }
  return {};
}
function genericCountQuery(entity, whereValue) {
  const name = entity + "Count";
  const operation = entityMap[name];
  const types2 = realEntityName[entity];
  const whereType = `${types2}WhereInput`;
  const where = addWhere(whereType, whereValue);
  return {
    operation,
    fields: ["totalCount"],
    variables: {
      orderBy: { value: "id_ASC", type: `[${types2}OrderByInput!]!` },
      ...where
    },
    whereType: `${types2}WhereInput`
  };
}
var __defProp2 = Object.defineProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp2(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField = (obj, key, value) => {
  __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};
var SquidClient = class {
  constructor(...args) {
    __publicField(this, "prefix");
    if (args.length === 1 && args[0] !== void 0) {
      this.prefix = args[0];
    }
  }
  collectionById(id2, fields) {
    const toQuery = getFields(fields);
    return build2("collection: collectionEntityById", toQuery, {
      id: { type: "String", required: true, value: id2, name: "id" }
    });
  }
  collectionCountByIssuer(issuer) {
    const { operation, fields, variables } = genericCountQuery("collection", {
      issuer_eq: issuer
    });
    return build2(operation, fields, variables);
  }
  collectionCountByName(name) {
    const gcq = genericCountQuery("collection", {
      name_containsInsensitive: name
    });
    return build2(gcq.operation, gcq.fields, gcq.variables);
  }
  collectionCountByOwner(owner) {
    const gcq = genericCountQuery("collection", { currentOwner_eq: owner });
    return build2(gcq.operation, gcq.fields, gcq.variables);
  }
  collectionCountCreatedAfter(date) {
    const gcq = genericCountQuery("collection", {
      createdAt_gte: date.toISOString()
    });
    return build2(gcq.operation, gcq.fields, gcq.variables);
  }
  collectionListBy(id2, field, options) {
    const toQuery = getFields(options?.fields);
    return build2(
      `collections: collectionEntities(where: {${field}_eq: "${id2}"})`,
      toQuery
    );
  }
  collectionListByIssuer(issuer, options) {
    const toQuery = getFields(options?.fields);
    const optionList = optionToQuery(options, true);
    return build2(
      `collections: collectionEntities(where: {issuer_eq: "${issuer}"} ${optionList})`,
      toQuery
    );
  }
  collectionListByName(name, options) {
    const toQuery = getFields(options?.fields);
    const optionList = optionToQuery(options, true);
    return build2(
      `collections: collectionEntities(where: {name_containsInsensitive: "${name}"} ${optionList})`,
      toQuery
    );
  }
  collectionListByOwner(owner, options) {
    const toQuery = getFields(options?.fields);
    const optionList = optionToQuery(options, true);
    return build2(
      `collections: collectionEntities(where: {currentOwner_eq: "${owner}"}  ${optionList})`,
      toQuery
    );
  }
  collectionListCreatedAfter(date, options) {
    const toQuery = getFields(options?.fields);
    const optionList = optionToQuery(options, true);
    return build2(
      `collections: collectionEntities(where: {createdAt_gte: "${date.toISOString()}"}  ${optionList})`,
      toQuery
    );
  }
  eventList(options) {
    const toQuery = getFields(options?.fields, defaultEventField, false);
    const optionList = optionToQuery(options, true);
    return build2(`events(${optionList})`, toQuery);
  }
  eventListByAddress(address, options) {
    const toQuery = getFields(options?.fields, defaultEventField, false);
    const optionList = optionToQuery(options, true);
    return build2(
      `events(where: {caller_eq: "${address}" } ${optionList})`,
      toQuery
    );
  }
  eventListByCollectionId(id2, options) {
    const toQuery = getFields(options?.fields, defaultEventField, false);
    const optionList = optionToQuery(options, true);
    return build2(
      `events(where: {nft: { collection: {id_eq: "${id2}"}}} ${optionList})`,
      toQuery
    );
  }
  eventListByCollectionIdAndInteraction(id2, interaction, options) {
    const toQuery = getFields(options?.fields, defaultEventField, false);
    const optionList = optionToQuery(options, true);
    return build2(
      `events(where: {nft: { collection: {id_eq: "${id2}"}} interaction_eq: ${interaction} } ${optionList})`,
      toQuery
    );
  }
  eventListByCollectionIdAndInteractionList(id2, interactions, options) {
    const toQuery = getFields(options?.fields, defaultEventField, false);
    const optionList = optionToQuery(options, true);
    const list = JSON.stringify(interactions).replace(/"/g, "");
    return build2(
      `events(where: {nft: { collection: {id_eq: "${id2}"}} interaction_in: ${list} } ${optionList})`,
      toQuery
    );
  }
  eventListByInteraction(interaction, options) {
    const toQuery = getFields(options?.fields, defaultEventField, false);
    const optionList = optionToQuery(options, true);
    return build2(
      `events(where: {interaction_eq: ${interaction}} ${optionList})`,
      toQuery
    );
  }
  eventListByItemId(id2, options) {
    const toQuery = getFields(options?.fields, defaultEventField, false);
    const optionList = optionToQuery(options, true);
    return build2(
      `events(where: {nft: {id_eq: "${id2}"}} ${optionList})`,
      toQuery
    );
  }
  eventListByItemIdAndInteraction(id2, interaction, options) {
    const toQuery = getFields(options?.fields, defaultEventField, false);
    const optionList = optionToQuery(options, true);
    return build2(
      `events(where: {nft: {id_eq: "${id2}" } interaction_eq: ${interaction} } ${optionList})`,
      toQuery
    );
  }
  eventListByItemIdAndInteractionList(id2, interactions, options) {
    const toQuery = getFields(options?.fields, defaultEventField, false);
    const optionList = optionToQuery(options, true);
    const list = JSON.stringify(interactions).replace(/"/g, "");
    return build2(
      `events(where: {nft: {id_eq: "${id2}" } interaction_in: ${list} } ${optionList})`,
      toQuery
    );
  }
  itemById(id2, fields) {
    const toQuery = getFields(fields);
    return build2("item: nftEntityById", toQuery, {
      id: { type: "String", required: true, value: id2, name: "id" }
    });
  }
  itemCountByOwner(owner) {
    const gcq = genericCountQuery("item", { currentOwner_eq: owner });
    return build2(gcq.operation, gcq.fields, gcq.variables);
  }
  itemCountByIssuer(issuer) {
    const { operation, fields, variables } = genericCountQuery("item", {
      issuer_eq: issuer
    });
    return build2(operation, fields, variables);
  }
  itemCountByName(name) {
    const gcq = genericCountQuery("item", { name_containsInsensitive: name });
    return build2(gcq.operation, gcq.fields, gcq.variables);
  }
  itemCountCollectedBy(address) {
    const gcq = genericCountQuery("item", {
      currentOwner_eq: address,
      issuer_not_eq: address
    });
    return build2(gcq.operation, gcq.fields, gcq.variables);
  }
  itemCountSoldBy(address) {
    const gcq = genericCountQuery("item", {
      currentOwner_not_eq: address,
      issuer_eq: address
    });
    return build2(gcq.operation, gcq.fields, gcq.variables);
  }
  itemCountByCollectionId(id2) {
    const value = { id_eq: id2 };
    const gcq = genericCountQuery("item", { collection: value });
    return build2(gcq.operation, gcq.fields, gcq.variables);
  }
  itemCountForSale() {
    const gcq = genericCountQuery("item", { price_gt: 0 });
    return build2(gcq.operation, gcq.fields, gcq.variables);
  }
  itemCountForSaleByCollectionId(id2) {
    const value = { id_eq: id2 };
    const gcq = genericCountQuery("item", { collection: value, price_gt: 0 });
    return build2(gcq.operation, gcq.fields, gcq.variables);
  }
  itemCountByCollectionIdAndOwner(id2, owner) {
    const value = { id_eq: id2 };
    const gcq = genericCountQuery("item", {
      collection: value,
      currentOwner_eq: owner
    });
    return build2(gcq.operation, gcq.fields, gcq.variables);
  }
  itemCountCreatedAfter(date) {
    const gcq = genericCountQuery("item", { createdAt_gte: date.toISOString() });
    return build2(gcq.operation, gcq.fields, gcq.variables);
  }
  itemListByOwner(owner, options) {
    const toQuery = getFields(options?.fields);
    const optionList = optionToQuery(options, true);
    const burned = includeBurned(options);
    return build2(
      `items: nftEntities(where: {currentOwner_eq: "${owner}", ${burned}} ${optionList})`,
      toQuery
    );
  }
  itemListByIssuer(issuer, options) {
    const toQuery = getFields(options?.fields);
    const optionList = optionToQuery(options, true);
    const burned = includeBurned(options);
    return build2(
      `items: nftEntities(where: {issuer_eq: "${issuer}",  ${burned}} ${optionList})`,
      toQuery
    );
  }
  itemListByName(name, options) {
    const toQuery = getFields(options?.fields);
    const optionList = optionToQuery(options, true);
    const burned = includeBurned(options);
    return build2(
      `items: nftEntities(where: {name_containsInsensitive: "${name}", ${burned}} ${optionList})`,
      toQuery
    );
  }
  itemListCollectedBy(address, options) {
    const toQuery = getFields(options?.fields);
    const optionList = optionToQuery(options, true);
    const burned = includeBurned(options);
    return build2(
      `items: nftEntities(where: {currentOwner_eq: "${address}", issuer_not_eq: "${address}", ${burned}} ${optionList})`,
      toQuery
    );
  }
  itemListSoldBy(address, options) {
    const toQuery = getFields(options?.fields);
    const optionList = optionToQuery(options, true);
    return build2(
      `items: nftEntities(where: {currentOwner_not_eq: "${address}", issuer_eq: "${address}"} ${optionList})`,
      toQuery
    );
  }
  itemListByCollectionId(id2, options) {
    const toQuery = getFields(options?.fields);
    const optionList = optionToQuery(options, true);
    return build2(
      `items: nftEntities(where: {collection: {id_eq: "${id2}"}} ${optionList})`,
      toQuery
    );
  }
  itemListForSale(options) {
    const toQuery = getFields(options?.fields);
    const optionList = optionToQuery(options, true);
    return build2(
      `items: nftEntities(where: {price_gt: "0"} ${optionList})`,
      toQuery
    );
  }
  itemListForSaleByCollectionId(id2, options) {
    const toQuery = getFields(options?.fields);
    const optionList = optionToQuery(options, true);
    return build2(
      `items: nftEntities(where: {collection: {id_eq: "${id2}"}, price_gt: "0"} ${optionList})`,
      toQuery
    );
  }
  itemListBy(id2, field, options) {
    const toQuery = getFields(options?.fields);
    return build2(`items: nftEntities(where: {${field}_eq: "${id2}"})`, toQuery);
  }
  itemListByCollectionIdAndOwner(id2, owner, options) {
    const toQuery = getFields(options?.fields);
    const optionList = optionToQuery(options, true);
    return build2(
      `items: nftEntities(where: { currentOwner_eq: "${owner}", collection: {id_eq: "${id2}"}} ${optionList})`,
      toQuery
    );
  }
  itemListByCollectionIdList(ids, options) {
    const toQuery = getFields(options?.fields);
    const optionList = optionToQuery(options, true);
    const list = JSON.stringify(ids);
    return build2(
      `items: nftEntities(where: {collection: {id_in: ${list}}} ${optionList})`,
      toQuery
    );
  }
  itemListByMetadataId(id2, options) {
    const toQuery = getFields(options?.fields);
    const optionList = optionToQuery(options, true);
    return build2(
      `items: nftEntities(where: {meta: {id_eq: "${id2}"}} ${optionList})`,
      toQuery
    );
  }
  itemListByMetadataIdMatch(id2, options) {
    const toQuery = getFields(options?.fields);
    const optionList = optionToQuery(options, true);
    return build2(
      `items: nftEntities(where: {meta: {id_containsInsensitive: "${id2}"}} ${optionList})`,
      toQuery
    );
  }
  itemListCreatedAfter(date, options) {
    const toQuery = getFields(options?.fields);
    const optionList = optionToQuery(options, true);
    return build2(
      `items: nftEntities(where: {createdAt_gte: "${date.toISOString()}"} ${optionList})`,
      toQuery
    );
  }
  fetch(query2) {
    const baseURL = getUrl$1(this.prefix);
    const opts = getOptions({ query: query2, baseURL, path: "" });
    return $fetch(baseURL, opts);
  }
};
var SquidClient$1 = SquidClient;
function getClient(prefix) {
  return new SquidClient$1(prefix);
}

// node_modules/@kodadot1/minipfs/dist/index.mjs
init_checked_fetch();
init_modules_watch_stub();
var IPFS_FS_PREFIX = "ipfs://ipfs/";
var IPFS_NS_PREFIX = "ipfs://ipns/";
var IPFS_PREFIX = "ipfs://";
var IPNS_PREFIX = "ipns://";
var HTTP_REGEX = /^https?:\/\//;
var ARWEAVE_REGEX = /^ar:\/\//;
var IPFS_REGEX = /^ipfs:\/\//;
var ARWEAVE_BASE = "https://arweave.net/";
var toArweavePath = (uri) => {
  const hash2 = uri.replace(ARWEAVE_REGEX, "");
  return `${ARWEAVE_BASE}${hash2}`;
};
var PINATA_GATEWAY = "https://gateway.pinata.cloud";
var ipfsProviders = {
  apillon: "https://ipfs.apillon.io",
  aragon: "https://ipfs.eth.aragon.network",
  astyanax: "https://ipfs.astyanax.io",
  cf: "https://cf-ipfs.com",
  cloudflare: "https://cloudflare-ipfs.com",
  dweb: "https://dweb.link",
  filebase_kodadot: "https://kodadot-ultra.myfilebase.com",
  fleek: "https://ipfs.fleek.co",
  gateway: "https://gateway.ipfs.io",
  infura: "https://infura-ipfs.io",
  infura_kodadot1: "https://kodadot1.infura-ipfs.io",
  ipfs: "https://ipfs.io",
  kodadot: "https://image.w.kodadot.xyz",
  kodadot_beta: "https://image-beta.w.kodadot.xyz",
  nftstorage: "https://nftstorage.link",
  rmrk: "https://ipfs2.rmrk.link"
};
var DEFAULT_PROVIDER_LIST = [
  "kodadot",
  "filebase_kodadot"
];
var getProviderList = (providers = DEFAULT_PROVIDER_LIST) => {
  const list = providers.length ? providers : DEFAULT_PROVIDER_LIST;
  return list.map((provider) => ipfsProviders[provider]);
};
var getProperURI = (uri, providers = []) => {
  const providerList = getProviderList(providers);
  return providerList.map((provider) => `${provider}${uri}`);
};
var isV0Cid = (cid) => {
  return cid.length === 46 && cid.startsWith("Qm");
};
var isV1Cid = (cid) => {
  return cid.length === 59 && cid.startsWith("baf");
};
var isCID = (uri) => {
  return isV0Cid(uri) || isV1Cid(uri);
};
var isPath = (uri) => {
  return /^\/ip[fn]s\//.test(uri);
};
var toIPFSPath = (uri) => {
  if (isCID(uri)) {
    return `/ipfs/${uri}`;
  }
  if (isPath(uri)) {
    return uri;
  }
  throw new TypeError(`Invalid IPFS URI: ${uri}`);
};
function isDefaultPinataProvider(uri) {
  return uri.startsWith(PINATA_GATEWAY);
}
var canBeIPFS = (uri) => {
  return isCID(uri) || isPath(uri);
};
var extractIPFS = (uri) => {
  if (uri.startsWith(IPFS_FS_PREFIX) || uri.startsWith(IPFS_NS_PREFIX)) {
    return uri.replace("ipfs:/", "");
  }
  if (uri.startsWith(IPFS_PREFIX) || uri.startsWith(IPNS_PREFIX)) {
    const value = uri.replace(":/", "");
    return "/" + value;
  }
  return uri.replace(IPFS_PREFIX, "");
};
function isBaseSixtyFour(data) {
  return /^data:([a-z]+)\/([\.\-\+a-z]+);base64,/.test(data);
}
function isBaseSixtyFourJSON(data) {
  return /^data:application\/json;base64,/.test(data);
}
function canBeJSON(data) {
  return data.startsWith("{") && data.endsWith("}") || data.startsWith("[") && data.endsWith("]");
}
function fromBaseSixtyFour(data) {
  if (isBaseSixtyFour(data)) {
    return atob(data.split(",").at(1));
  }
  return "";
}
function baseSixtyFourFormatter(data) {
  if (isBaseSixtyFourJSON(data)) {
    return JSON.parse(fromBaseSixtyFour(data));
  }
  return fromBaseSixtyFour(data);
}
function sanitize(path) {
  if (canBeIPFS(path)) {
    return { path: toIPFSPath(path), needProvider: true };
  }
  if (canBeJSON(path)) {
    return {
      path,
      needProvider: false,
      formatter: JSON.parse
    };
  }
  if (isBaseSixtyFour(path)) {
    return {
      path,
      needProvider: false,
      formatter: baseSixtyFourFormatter
    };
  }
  if (IPFS_REGEX.test(path)) {
    return { path: toIPFSPath(extractIPFS(path)), needProvider: true };
  }
  if (HTTP_REGEX.test(path)) {
    if (isDefaultPinataProvider(path)) {
      return {
        path: path.replace(PINATA_GATEWAY, ""),
        needProvider: true
      };
    }
    return { path, needProvider: false };
  }
  if (ARWEAVE_REGEX.test(path)) {
    return { path: toArweavePath(path), needProvider: false };
  }
  throw new Error(`[KODADOT::MINIPFS] Invalid URI: ${path}`);
}
function $purify(uri, providers = []) {
  const { needProvider, path } = sanitize(uri);
  if (needProvider) {
    return getProperURI(path, providers);
  }
  return [path];
}
function $purifyOne(uri, providers) {
  return $purify(uri, [providers]).at(0);
}

// src/utils.ts
init_checked_fetch();
init_modules_watch_stub();

// node_modules/@polkadot/x-textdecoder/browser.js
init_checked_fetch();
init_modules_watch_stub();

// node_modules/@polkadot/x-global/index.js
init_checked_fetch();
init_modules_watch_stub();
function evaluateThis(fn2) {
  return fn2("return this");
}
var xglobal = typeof globalThis !== "undefined" ? globalThis : typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : evaluateThis(Function);
function extractGlobal(name, fallback2) {
  return typeof xglobal[name] === "undefined" ? fallback2 : xglobal[name];
}

// node_modules/@polkadot/x-textdecoder/fallback.js
init_checked_fetch();
init_modules_watch_stub();
var TextDecoder2 = class {
  __encoding;
  constructor(encoding) {
    this.__encoding = encoding;
  }
  decode(value) {
    let result = "";
    for (let i = 0, count = value.length; i < count; i++) {
      result += String.fromCharCode(value[i]);
    }
    return result;
  }
};

// node_modules/@polkadot/x-textdecoder/browser.js
var TextDecoder3 = /* @__PURE__ */ extractGlobal("TextDecoder", TextDecoder2);

// node_modules/@polkadot/x-textencoder/browser.js
init_checked_fetch();
init_modules_watch_stub();

// node_modules/@polkadot/x-textencoder/fallback.js
init_checked_fetch();
init_modules_watch_stub();
var TextEncoder2 = class {
  encode(value) {
    const count = value.length;
    const u8a2 = new Uint8Array(count);
    for (let i = 0; i < count; i++) {
      u8a2[i] = value.charCodeAt(i);
    }
    return u8a2;
  }
};

// node_modules/@polkadot/x-textencoder/browser.js
var TextEncoder3 = /* @__PURE__ */ extractGlobal("TextEncoder", TextEncoder2);

// node_modules/@polkadot/util/is/function.js
init_checked_fetch();
init_modules_watch_stub();
function isFunction(value) {
  return typeof value === "function";
}

// node_modules/@polkadot/x-bigint/index.js
init_checked_fetch();
init_modules_watch_stub();
function invalidFallback() {
  return Number.NaN;
}
var BigInt2 = /* @__PURE__ */ extractGlobal("BigInt", invalidFallback);

// node_modules/@polkadot/util/hex/toU8a.js
init_checked_fetch();
init_modules_watch_stub();
var CHR = "0123456789abcdef";
var U8 = new Uint8Array(256);
var U16 = new Uint8Array(256 * 256);
for (let i = 0, count = CHR.length; i < count; i++) {
  U8[CHR[i].charCodeAt(0) | 0] = i | 0;
  if (i > 9) {
    U8[CHR[i].toUpperCase().charCodeAt(0) | 0] = i | 0;
  }
}
for (let i = 0; i < 256; i++) {
  const s = i << 8;
  for (let j = 0; j < 256; j++) {
    U16[s | j] = U8[i] << 4 | U8[j];
  }
}
function hexToU8a(value, bitLength3 = -1) {
  if (!value) {
    return new Uint8Array();
  }
  let s = value.startsWith("0x") ? 2 : 0;
  const decLength = Math.ceil((value.length - s) / 2);
  const endLength = Math.ceil(bitLength3 === -1 ? decLength : bitLength3 / 8);
  const result = new Uint8Array(endLength);
  const offset = endLength > decLength ? endLength - decLength : 0;
  for (let i = offset; i < endLength; i++, s += 2) {
    result[i] = U16[value.charCodeAt(s) << 8 | value.charCodeAt(s + 1)];
  }
  return result;
}

// node_modules/@polkadot/util/is/hex.js
init_checked_fetch();
init_modules_watch_stub();
var REGEX_HEX_PREFIXED = /^0x[\da-fA-F]+$/;
function isHex2(value, bitLength3 = -1, ignoreLength) {
  return typeof value === "string" && (value === "0x" || REGEX_HEX_PREFIXED.test(value)) && (bitLength3 === -1 ? ignoreLength || value.length % 2 === 0 : value.length === 2 + Math.ceil(bitLength3 / 4));
}

// node_modules/@polkadot/util/u8a/index.js
init_checked_fetch();
init_modules_watch_stub();

// node_modules/@polkadot/util/u8a/toU8a.js
init_checked_fetch();
init_modules_watch_stub();

// node_modules/@polkadot/util/is/buffer.js
init_checked_fetch();
init_modules_watch_stub();

// node_modules/@polkadot/util/has.js
init_checked_fetch();
init_modules_watch_stub();
var hasBigInt = typeof BigInt2 === "function" && typeof BigInt2.asIntN === "function";
var hasBuffer = typeof xglobal.Buffer === "function" && typeof xglobal.Buffer.isBuffer === "function";
var hasProcess = typeof xglobal.process === "object";

// node_modules/@polkadot/util/is/buffer.js
function isBuffer(value) {
  return hasBuffer && !!value && isFunction(value.readDoubleLE) && xglobal.Buffer.isBuffer(value);
}

// node_modules/@polkadot/util/is/u8a.js
init_checked_fetch();
init_modules_watch_stub();
function isU8a(value) {
  return (value && value.constructor) === Uint8Array || value instanceof Uint8Array;
}

// node_modules/@polkadot/util/string/toU8a.js
init_checked_fetch();
init_modules_watch_stub();
var encoder5 = new TextEncoder3();
function stringToU8a(value) {
  return value ? encoder5.encode(value.toString()) : new Uint8Array();
}

// node_modules/@polkadot/util/u8a/toU8a.js
function u8aToU8a(value) {
  return isU8a(value) ? isBuffer(value) ? new Uint8Array(value) : value : isHex2(value) ? hexToU8a(value) : Array.isArray(value) ? new Uint8Array(value) : stringToU8a(value);
}

// node_modules/@polkadot/util/u8a/concat.js
init_checked_fetch();
init_modules_watch_stub();
function u8aConcat(...list) {
  const count = list.length;
  const u8as = new Array(count);
  let length = 0;
  for (let i = 0; i < count; i++) {
    u8as[i] = u8aToU8a(list[i]);
    length += u8as[i].length;
  }
  return u8aConcatStrict(u8as, length);
}
function u8aConcatStrict(u8as, length = 0) {
  const count = u8as.length;
  let offset = 0;
  if (!length) {
    for (let i = 0; i < count; i++) {
      length += u8as[i].length;
    }
  }
  const result = new Uint8Array(length);
  for (let i = 0; i < count; i++) {
    result.set(u8as[i], offset);
    offset += u8as[i].length;
  }
  return result;
}

// node_modules/@polkadot/util/u8a/toHex.js
init_checked_fetch();
init_modules_watch_stub();
var U82 = new Array(256);
var U162 = new Array(256 * 256);
for (let n = 0; n < 256; n++) {
  U82[n] = n.toString(16).padStart(2, "0");
}
for (let i = 0; i < 256; i++) {
  const s = i << 8;
  for (let j = 0; j < 256; j++) {
    U162[s | j] = U82[i] + U82[j];
  }
}
function hex(value, result) {
  const mod = value.length % 2 | 0;
  const length = value.length - mod | 0;
  for (let i = 0; i < length; i += 2) {
    result += U162[value[i] << 8 | value[i + 1]];
  }
  if (mod) {
    result += U82[value[length] | 0];
  }
  return result;
}
function u8aToHex(value, bitLength3 = -1, isPrefixed = true) {
  const empty = isPrefixed ? "0x" : "";
  if (!value?.length) {
    return empty;
  } else if (bitLength3 > 0) {
    const length = Math.ceil(bitLength3 / 8);
    if (value.length > length) {
      return `${hex(value.subarray(0, length / 2), empty)}\u2026${hex(value.subarray(value.length - length / 2), "")}`;
    }
  }
  return hex(value, empty);
}

// node_modules/@polkadot/util/u8a/toString.js
init_checked_fetch();
init_modules_watch_stub();
var decoder3 = new TextDecoder3("utf-8");
function u8aToString(value) {
  return value ? decoder3.decode(value) : "";
}

// node_modules/@polkadot/util/is/index.js
init_checked_fetch();
init_modules_watch_stub();

// node_modules/@polkadot/util/string/index.js
init_checked_fetch();
init_modules_watch_stub();

// node_modules/@polkadot/x-randomvalues/browser.js
init_checked_fetch();
init_modules_watch_stub();
var crypto2 = xglobal.crypto;
function getRandomValues(arr) {
  return crypto2.getRandomValues(arr);
}

// node_modules/@polkadot/wasm-crypto/bundle.js
init_checked_fetch();
init_modules_watch_stub();

// node_modules/@polkadot/wasm-crypto/init.js
init_checked_fetch();
init_modules_watch_stub();

// node_modules/@polkadot/wasm-bridge/bridge.js
init_checked_fetch();
init_modules_watch_stub();

// node_modules/@polkadot/wasm-bridge/wbg.js
init_checked_fetch();
init_modules_watch_stub();
var DEFAULT_CRYPTO = { getRandomValues };
var DEFAULT_SELF = { crypto: DEFAULT_CRYPTO };
var Wbg = class {
  __internal__bridge;
  constructor(bridge2) {
    this.__internal__bridge = bridge2;
  }
  /** @internal */
  abort = () => {
    throw new Error("abort");
  };
  /** @internal */
  __wbindgen_is_undefined = (idx) => {
    return this.__internal__bridge.getObject(idx) === void 0;
  };
  /** @internal */
  __wbindgen_throw = (ptr, len) => {
    throw new Error(this.__internal__bridge.getString(ptr, len));
  };
  /** @internal */
  __wbg_self_1b7a39e3a92c949c = () => {
    return this.__internal__bridge.addObject(DEFAULT_SELF);
  };
  /** @internal */
  __wbg_require_604837428532a733 = (ptr, len) => {
    throw new Error(`Unable to require ${this.__internal__bridge.getString(ptr, len)}`);
  };
  /** @internal */
  __wbg_crypto_968f1772287e2df0 = (_idx) => {
    return this.__internal__bridge.addObject(DEFAULT_CRYPTO);
  };
  /** @internal */
  __wbg_getRandomValues_a3d34b4fee3c2869 = (_idx) => {
    return this.__internal__bridge.addObject(DEFAULT_CRYPTO.getRandomValues);
  };
  /** @internal */
  __wbg_getRandomValues_f5e14ab7ac8e995d = (_arg0, ptr, len) => {
    DEFAULT_CRYPTO.getRandomValues(this.__internal__bridge.getU8a(ptr, len));
  };
  /** @internal */
  __wbg_randomFillSync_d5bd2d655fdf256a = (_idx, _ptr, _len) => {
    throw new Error("randomFillsync is not available");
  };
  /** @internal */
  __wbindgen_object_drop_ref = (idx) => {
    this.__internal__bridge.takeObject(idx);
  };
};

// node_modules/@polkadot/wasm-bridge/bridge.js
var Bridge = class {
  __internal__createWasm;
  __internal__heap;
  __internal__wbg;
  __internal__cachegetInt32;
  __internal__cachegetUint8;
  __internal__heapNext;
  __internal__wasm;
  __internal__wasmError;
  __internal__wasmPromise;
  __internal__type;
  constructor(createWasm2) {
    this.__internal__createWasm = createWasm2;
    this.__internal__cachegetInt32 = null;
    this.__internal__cachegetUint8 = null;
    this.__internal__heap = new Array(32).fill(void 0).concat(void 0, null, true, false);
    this.__internal__heapNext = this.__internal__heap.length;
    this.__internal__type = "none";
    this.__internal__wasm = null;
    this.__internal__wasmError = null;
    this.__internal__wasmPromise = null;
    this.__internal__wbg = { ...new Wbg(this) };
  }
  /** @description Returns the init error */
  get error() {
    return this.__internal__wasmError;
  }
  /** @description Returns the init type */
  get type() {
    return this.__internal__type;
  }
  /** @description Returns the created wasm interface */
  get wasm() {
    return this.__internal__wasm;
  }
  /** @description Performs the wasm initialization */
  async init(createWasm2) {
    if (!this.__internal__wasmPromise || createWasm2) {
      this.__internal__wasmPromise = (createWasm2 || this.__internal__createWasm)(this.__internal__wbg);
    }
    const { error, type, wasm } = await this.__internal__wasmPromise;
    this.__internal__type = type;
    this.__internal__wasm = wasm;
    this.__internal__wasmError = error;
    return this.__internal__wasm;
  }
  /**
   * @internal
   * @description Gets an object from the heap
   */
  getObject(idx) {
    return this.__internal__heap[idx];
  }
  /**
   * @internal
   * @description Removes an object from the heap
   */
  dropObject(idx) {
    if (idx < 36) {
      return;
    }
    this.__internal__heap[idx] = this.__internal__heapNext;
    this.__internal__heapNext = idx;
  }
  /**
   * @internal
   * @description Retrieves and removes an object to the heap
   */
  takeObject(idx) {
    const ret = this.getObject(idx);
    this.dropObject(idx);
    return ret;
  }
  /**
   * @internal
   * @description Adds an object to the heap
   */
  addObject(obj) {
    if (this.__internal__heapNext === this.__internal__heap.length) {
      this.__internal__heap.push(this.__internal__heap.length + 1);
    }
    const idx = this.__internal__heapNext;
    this.__internal__heapNext = this.__internal__heap[idx];
    this.__internal__heap[idx] = obj;
    return idx;
  }
  /**
   * @internal
   * @description Retrieve an Int32 in the WASM interface
   */
  getInt32() {
    if (this.__internal__cachegetInt32 === null || this.__internal__cachegetInt32.buffer !== this.__internal__wasm.memory.buffer) {
      this.__internal__cachegetInt32 = new Int32Array(this.__internal__wasm.memory.buffer);
    }
    return this.__internal__cachegetInt32;
  }
  /**
   * @internal
   * @description Retrieve an Uint8Array in the WASM interface
   */
  getUint8() {
    if (this.__internal__cachegetUint8 === null || this.__internal__cachegetUint8.buffer !== this.__internal__wasm.memory.buffer) {
      this.__internal__cachegetUint8 = new Uint8Array(this.__internal__wasm.memory.buffer);
    }
    return this.__internal__cachegetUint8;
  }
  /**
   * @internal
   * @description Retrieves an Uint8Array in the WASM interface
   */
  getU8a(ptr, len) {
    return this.getUint8().subarray(ptr / 1, ptr / 1 + len);
  }
  /**
   * @internal
   * @description Retrieves a string in the WASM interface
   */
  getString(ptr, len) {
    return u8aToString(this.getU8a(ptr, len));
  }
  /**
   * @internal
   * @description Allocates an Uint8Array in the WASM interface
   */
  allocU8a(arg) {
    const ptr = this.__internal__wasm.__wbindgen_malloc(arg.length * 1);
    this.getUint8().set(arg, ptr / 1);
    return [ptr, arg.length];
  }
  /**
   * @internal
   * @description Allocates a string in the WASM interface
   */
  allocString(arg) {
    return this.allocU8a(stringToU8a(arg));
  }
  /**
   * @internal
   * @description Retrieves an Uint8Array from the WASM interface
   */
  resultU8a() {
    const r02 = this.getInt32()[8 / 4 + 0];
    const r12 = this.getInt32()[8 / 4 + 1];
    const ret = this.getU8a(r02, r12).slice();
    this.__internal__wasm.__wbindgen_free(r02, r12 * 1);
    return ret;
  }
  /**
   * @internal
   * @description Retrieve a string from the WASM interface
   */
  resultString() {
    return u8aToString(this.resultU8a());
  }
};

// node_modules/@polkadot/wasm-bridge/init.js
init_checked_fetch();
init_modules_watch_stub();
function createWasmFn(root, wasmBytes2, asmFn) {
  return async (wbg) => {
    const result = {
      error: null,
      type: "none",
      wasm: null
    };
    try {
      if (!wasmBytes2?.length) {
        throw new Error("No WebAssembly provided for initialization");
      } else if (typeof WebAssembly !== "object" || typeof WebAssembly.instantiate !== "function") {
        throw new Error("WebAssembly is not available in your environment");
      }
      const source = await WebAssembly.instantiate(wasmBytes2, { wbg });
      result.wasm = source.instance.exports;
      result.type = "wasm";
    } catch (error) {
      if (typeof asmFn === "function") {
        result.wasm = asmFn(wbg);
        result.type = "asm";
      } else {
        result.error = `FATAL: Unable to initialize @polkadot/wasm-${root}:: ${error.message}`;
        console.error(result.error);
      }
    }
    return result;
  };
}

// node_modules/@polkadot/wasm-crypto-init/wasm.js
init_checked_fetch();
init_modules_watch_stub();

// node_modules/@polkadot/wasm-crypto-wasm/bundle.js
init_checked_fetch();
init_modules_watch_stub();

// node_modules/@polkadot/wasm-util/bundle.js
init_checked_fetch();
init_modules_watch_stub();

// node_modules/@polkadot/wasm-util/base64.js
init_checked_fetch();
init_modules_watch_stub();
var CHR2 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
var map = new Array(256);
for (let i = 0, count = CHR2.length; i < count; i++) {
  map[CHR2.charCodeAt(i)] = i;
}
function base64Decode(data, out) {
  let byte = 0;
  let bits2 = 0;
  let pos = -1;
  for (let i = 0, last = out.length - 1; pos !== last; i++) {
    byte = byte << 6 | map[data.charCodeAt(i)];
    if ((bits2 += 6) >= 8) {
      out[++pos] = byte >>> (bits2 -= 8) & 255;
    }
  }
  return out;
}

// node_modules/@polkadot/wasm-util/fflate.js
init_checked_fetch();
init_modules_watch_stub();
var u8 = Uint8Array;
var u16 = Uint16Array;
var u322 = Uint32Array;
var clim = new u8([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]);
var fleb = new u8([
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  1,
  1,
  1,
  1,
  2,
  2,
  2,
  2,
  3,
  3,
  3,
  3,
  4,
  4,
  4,
  4,
  5,
  5,
  5,
  5,
  0,
  /* unused */
  0,
  0,
  /* impossible */
  0
]);
var fdeb = new u8([
  0,
  0,
  0,
  0,
  1,
  1,
  2,
  2,
  3,
  3,
  4,
  4,
  5,
  5,
  6,
  6,
  7,
  7,
  8,
  8,
  9,
  9,
  10,
  10,
  11,
  11,
  12,
  12,
  13,
  13,
  /* unused */
  0,
  0
]);
var freb = (eb, start) => {
  const b = new u16(31);
  for (let i = 0; i < 31; ++i) {
    b[i] = start += 1 << eb[i - 1];
  }
  const r2 = new u322(b[30]);
  for (let i = 1; i < 30; ++i) {
    for (let j = b[i]; j < b[i + 1]; ++j) {
      r2[j] = j - b[i] << 5 | i;
    }
  }
  return [b, r2];
};
var [fl2, revfl] = freb(fleb, 2);
fl2[28] = 258, revfl[258] = 28;
var [fd2] = freb(fdeb, 0);
var rev = new u16(32768);
for (let i = 0; i < 32768; ++i) {
  let x = (i & 43690) >>> 1 | (i & 21845) << 1;
  x = (x & 52428) >>> 2 | (x & 13107) << 2;
  x = (x & 61680) >>> 4 | (x & 3855) << 4;
  rev[i] = ((x & 65280) >>> 8 | (x & 255) << 8) >>> 1;
}
var hMap = (cd2, mb, r2) => {
  const s = cd2.length;
  let i = 0;
  const l = new u16(mb);
  for (; i < s; ++i) {
    if (cd2[i])
      ++l[cd2[i] - 1];
  }
  const le2 = new u16(mb);
  for (i = 1; i < mb; ++i) {
    le2[i] = le2[i - 1] + l[i - 1] << 1;
  }
  let co;
  if (r2) {
    co = new u16(1 << mb);
    const rvb = 15 - mb;
    for (i = 0; i < s; ++i) {
      if (cd2[i]) {
        const sv2 = i << 4 | cd2[i];
        const r3 = mb - cd2[i];
        let v = le2[cd2[i] - 1]++ << r3;
        for (const m2 = v | (1 << r3) - 1; v <= m2; ++v) {
          co[rev[v] >> rvb] = sv2;
        }
      }
    }
  } else {
    co = new u16(s);
    for (i = 0; i < s; ++i) {
      if (cd2[i]) {
        co[i] = rev[le2[cd2[i] - 1]++] >> 15 - cd2[i];
      }
    }
  }
  return co;
};
var flt = new u8(288);
for (let i = 0; i < 144; ++i)
  flt[i] = 8;
for (let i = 144; i < 256; ++i)
  flt[i] = 9;
for (let i = 256; i < 280; ++i)
  flt[i] = 7;
for (let i = 280; i < 288; ++i)
  flt[i] = 8;
var fdt = new u8(32);
for (let i = 0; i < 32; ++i)
  fdt[i] = 5;
var flrm = hMap(flt, 9, 1);
var fdrm = hMap(fdt, 5, 1);
var bits = (d, p2, m2) => {
  const o = p2 >>> 3;
  return (d[o] | d[o + 1] << 8) >>> (p2 & 7) & m2;
};
var bits16 = (d, p2) => {
  const o = p2 >>> 3;
  return (d[o] | d[o + 1] << 8 | d[o + 2] << 16) >>> (p2 & 7);
};
var shft = (p2) => (p2 >>> 3) + (p2 & 7 && 1);
var slc = (v, s, e) => {
  if (s == null || s < 0)
    s = 0;
  if (e == null || e > v.length)
    e = v.length;
  const n = new (v instanceof u16 ? u16 : v instanceof u322 ? u322 : u8)(e - s);
  n.set(v.subarray(s, e));
  return n;
};
var max = (a) => {
  let m2 = a[0];
  for (let i = 1, count = a.length; i < count; ++i) {
    if (a[i] > m2)
      m2 = a[i];
  }
  return m2;
};
var inflt = (dat, buf, st2) => {
  const noSt = !st2 || st2.i;
  if (!st2)
    st2 = {};
  const sl2 = dat.length;
  const noBuf = !buf || !noSt;
  if (!buf)
    buf = new u8(sl2 * 3);
  const cbuf = (l) => {
    let bl2 = buf.length;
    if (l > bl2) {
      const nbuf = new u8(Math.max(bl2 << 1, l));
      nbuf.set(buf);
      buf = nbuf;
    }
  };
  let final = st2.f || 0, pos = st2.p || 0, bt = st2.b || 0, lm2 = st2.l, dm2 = st2.d, lbt = st2.m, dbt = st2.n;
  if (final && !lm2)
    return buf;
  const tbts = sl2 << 3;
  do {
    if (!lm2) {
      st2.f = final = bits(dat, pos, 1);
      const type = bits(dat, pos + 1, 3);
      pos += 3;
      if (!type) {
        const s = shft(pos) + 4, l = dat[s - 4] | dat[s - 3] << 8, t = s + l;
        if (t > sl2) {
          if (noSt)
            throw "unexpected EOF";
          break;
        }
        if (noBuf)
          cbuf(bt + l);
        buf.set(dat.subarray(s, t), bt);
        st2.b = bt += l, st2.p = pos = t << 3;
        continue;
      } else if (type == 1)
        lm2 = flrm, dm2 = fdrm, lbt = 9, dbt = 5;
      else if (type == 2) {
        const hLit = bits(dat, pos, 31) + 257, hcLen = bits(dat, pos + 10, 15) + 4;
        const tl2 = hLit + bits(dat, pos + 5, 31) + 1;
        pos += 14;
        const ldt = new u8(tl2);
        const clt = new u8(19);
        for (let i = 0; i < hcLen; ++i) {
          clt[clim[i]] = bits(dat, pos + i * 3, 7);
        }
        pos += hcLen * 3;
        const clb = max(clt), clbmsk = (1 << clb) - 1;
        if (!noSt && pos + tl2 * (clb + 7) > tbts)
          break;
        const clm = hMap(clt, clb, 1);
        for (let i = 0; i < tl2; ) {
          const r2 = clm[bits(dat, pos, clbmsk)];
          pos += r2 & 15;
          const s = r2 >>> 4;
          if (s < 16) {
            ldt[i++] = s;
          } else {
            let c = 0, n = 0;
            if (s == 16)
              n = 3 + bits(dat, pos, 3), pos += 2, c = ldt[i - 1];
            else if (s == 17)
              n = 3 + bits(dat, pos, 7), pos += 3;
            else if (s == 18)
              n = 11 + bits(dat, pos, 127), pos += 7;
            while (n--)
              ldt[i++] = c;
          }
        }
        const lt = ldt.subarray(0, hLit), dt = ldt.subarray(hLit);
        lbt = max(lt);
        dbt = max(dt);
        lm2 = hMap(lt, lbt, 1);
        dm2 = hMap(dt, dbt, 1);
      } else
        throw "invalid block type";
      if (pos > tbts)
        throw "unexpected EOF";
    }
    if (noBuf)
      cbuf(bt + 131072);
    const lms = (1 << lbt) - 1, dms = (1 << dbt) - 1;
    const mxa = lbt + dbt + 18;
    while (noSt || pos + mxa < tbts) {
      const c = lm2[bits16(dat, pos) & lms], sym = c >>> 4;
      pos += c & 15;
      if (pos > tbts)
        throw "unexpected EOF";
      if (!c)
        throw "invalid length/literal";
      if (sym < 256)
        buf[bt++] = sym;
      else if (sym == 256) {
        lm2 = void 0;
        break;
      } else {
        let add2 = sym - 254;
        if (sym > 264) {
          const i = sym - 257, b = fleb[i];
          add2 = bits(dat, pos, (1 << b) - 1) + fl2[i];
          pos += b;
        }
        const d = dm2[bits16(dat, pos) & dms], dsym = d >>> 4;
        if (!d)
          throw "invalid distance";
        pos += d & 15;
        let dt = fd2[dsym];
        if (dsym > 3) {
          const b = fdeb[dsym];
          dt += bits16(dat, pos) & (1 << b) - 1, pos += b;
        }
        if (pos > tbts)
          throw "unexpected EOF";
        if (noBuf)
          cbuf(bt + 131072);
        const end = bt + add2;
        for (; bt < end; bt += 4) {
          buf[bt] = buf[bt - dt];
          buf[bt + 1] = buf[bt + 1 - dt];
          buf[bt + 2] = buf[bt + 2 - dt];
          buf[bt + 3] = buf[bt + 3 - dt];
        }
        bt = end;
      }
    }
    st2.l = lm2, st2.p = pos, st2.b = bt;
    if (lm2)
      final = 1, st2.m = lbt, st2.d = dm2, st2.n = dbt;
  } while (!final);
  return bt == buf.length ? buf : slc(buf, 0, bt);
};
var zlv = (d) => {
  if ((d[0] & 15) != 8 || d[0] >>> 4 > 7 || (d[0] << 8 | d[1]) % 31)
    throw "invalid zlib data";
  if (d[1] & 32)
    throw "invalid zlib data: preset dictionaries not supported";
};
function unzlibSync(data, out) {
  return inflt((zlv(data), data.subarray(2, -4)), out);
}

// node_modules/@polkadot/wasm-crypto-wasm/bundle.js
var import_bytes = __toESM(require_bytes(), 1);
var wasmBytes = /* @__PURE__ */ unzlibSync(base64Decode(import_bytes.bytes, new Uint8Array(import_bytes.lenIn)), new Uint8Array(import_bytes.lenOut));

// node_modules/@polkadot/wasm-crypto-init/wasm.js
var createWasm = /* @__PURE__ */ createWasmFn("crypto", wasmBytes, null);

// node_modules/@polkadot/wasm-crypto/init.js
var bridge = new Bridge(createWasm);

// node_modules/@polkadot/wasm-crypto/bundle.js
function withWasm(fn2) {
  return (...params) => {
    if (!bridge.wasm) {
      throw new Error("The WASM interface has not been initialized. Ensure that you wait for the initialization Promise with waitReady() from @polkadot/wasm-crypto (or cryptoWaitReady() from @polkadot/util-crypto) before attempting to use WASM-only interfaces.");
    }
    return fn2(bridge.wasm, ...params);
  };
}
var blake2b = /* @__PURE__ */ withWasm((wasm, data, key, size2) => {
  wasm.ext_blake2b(8, ...bridge.allocU8a(data), ...bridge.allocU8a(key), size2);
  return bridge.resultU8a();
});
function isReady() {
  return !!bridge.wasm;
}

// node_modules/@polkadot/util-crypto/address/index.js
init_checked_fetch();
init_modules_watch_stub();

// node_modules/@polkadot/util-crypto/address/decode.js
init_checked_fetch();
init_modules_watch_stub();

// node_modules/@polkadot/util-crypto/base58/index.js
init_checked_fetch();
init_modules_watch_stub();

// node_modules/@polkadot/util-crypto/base58/bs58.js
init_checked_fetch();
init_modules_watch_stub();

// node_modules/@scure/base/lib/esm/index.js
init_checked_fetch();
init_modules_watch_stub();
function assertNumber(n) {
  if (!Number.isSafeInteger(n))
    throw new Error(`Wrong integer: ${n}`);
}
function isBytes(a) {
  return a instanceof Uint8Array || a != null && typeof a === "object" && a.constructor.name === "Uint8Array";
}
function chain(...args) {
  const id2 = (a) => a;
  const wrap4 = (a, b) => (c) => a(b(c));
  const encode3 = args.map((x) => x.encode).reduceRight(wrap4, id2);
  const decode4 = args.map((x) => x.decode).reduce(wrap4, id2);
  return { encode: encode3, decode: decode4 };
}
function alphabet(alphabet2) {
  return {
    encode: (digits) => {
      if (!Array.isArray(digits) || digits.length && typeof digits[0] !== "number")
        throw new Error("alphabet.encode input should be an array of numbers");
      return digits.map((i) => {
        assertNumber(i);
        if (i < 0 || i >= alphabet2.length)
          throw new Error(`Digit index outside alphabet: ${i} (alphabet: ${alphabet2.length})`);
        return alphabet2[i];
      });
    },
    decode: (input) => {
      if (!Array.isArray(input) || input.length && typeof input[0] !== "string")
        throw new Error("alphabet.decode input should be array of strings");
      return input.map((letter) => {
        if (typeof letter !== "string")
          throw new Error(`alphabet.decode: not string element=${letter}`);
        const index = alphabet2.indexOf(letter);
        if (index === -1)
          throw new Error(`Unknown letter: "${letter}". Allowed: ${alphabet2}`);
        return index;
      });
    }
  };
}
function join(separator = "") {
  if (typeof separator !== "string")
    throw new Error("join separator should be string");
  return {
    encode: (from) => {
      if (!Array.isArray(from) || from.length && typeof from[0] !== "string")
        throw new Error("join.encode input should be array of strings");
      for (let i of from)
        if (typeof i !== "string")
          throw new Error(`join.encode: non-string input=${i}`);
      return from.join(separator);
    },
    decode: (to) => {
      if (typeof to !== "string")
        throw new Error("join.decode input should be string");
      return to.split(separator);
    }
  };
}
function padding(bits2, chr = "=") {
  assertNumber(bits2);
  if (typeof chr !== "string")
    throw new Error("padding chr should be string");
  return {
    encode(data) {
      if (!Array.isArray(data) || data.length && typeof data[0] !== "string")
        throw new Error("padding.encode input should be array of strings");
      for (let i of data)
        if (typeof i !== "string")
          throw new Error(`padding.encode: non-string input=${i}`);
      while (data.length * bits2 % 8)
        data.push(chr);
      return data;
    },
    decode(input) {
      if (!Array.isArray(input) || input.length && typeof input[0] !== "string")
        throw new Error("padding.encode input should be array of strings");
      for (let i of input)
        if (typeof i !== "string")
          throw new Error(`padding.decode: non-string input=${i}`);
      let end = input.length;
      if (end * bits2 % 8)
        throw new Error("Invalid padding: string should have whole number of bytes");
      for (; end > 0 && input[end - 1] === chr; end--) {
        if (!((end - 1) * bits2 % 8))
          throw new Error("Invalid padding: string has too much padding");
      }
      return input.slice(0, end);
    }
  };
}
function normalize(fn2) {
  if (typeof fn2 !== "function")
    throw new Error("normalize fn should be function");
  return { encode: (from) => from, decode: (to) => fn2(to) };
}
function convertRadix(data, from, to) {
  if (from < 2)
    throw new Error(`convertRadix: wrong from=${from}, base cannot be less than 2`);
  if (to < 2)
    throw new Error(`convertRadix: wrong to=${to}, base cannot be less than 2`);
  if (!Array.isArray(data))
    throw new Error("convertRadix: data should be array");
  if (!data.length)
    return [];
  let pos = 0;
  const res = [];
  const digits = Array.from(data);
  digits.forEach((d) => {
    assertNumber(d);
    if (d < 0 || d >= from)
      throw new Error(`Wrong integer: ${d}`);
  });
  while (true) {
    let carry = 0;
    let done = true;
    for (let i = pos; i < digits.length; i++) {
      const digit = digits[i];
      const digitBase = from * carry + digit;
      if (!Number.isSafeInteger(digitBase) || from * carry / from !== carry || digitBase - digit !== from * carry) {
        throw new Error("convertRadix: carry overflow");
      }
      carry = digitBase % to;
      const rounded = Math.floor(digitBase / to);
      digits[i] = rounded;
      if (!Number.isSafeInteger(rounded) || rounded * to + carry !== digitBase)
        throw new Error("convertRadix: carry overflow");
      if (!done)
        continue;
      else if (!rounded)
        pos = i;
      else
        done = false;
    }
    res.push(carry);
    if (done)
      break;
  }
  for (let i = 0; i < data.length - 1 && data[i] === 0; i++)
    res.push(0);
  return res.reverse();
}
var gcd = (
  /* @__NO_SIDE_EFFECTS__ */
  (a, b) => !b ? a : gcd(b, a % b)
);
var radix2carry = (
  /*@__NO_SIDE_EFFECTS__ */
  (from, to) => from + (to - gcd(from, to))
);
function convertRadix2(data, from, to, padding2) {
  if (!Array.isArray(data))
    throw new Error("convertRadix2: data should be array");
  if (from <= 0 || from > 32)
    throw new Error(`convertRadix2: wrong from=${from}`);
  if (to <= 0 || to > 32)
    throw new Error(`convertRadix2: wrong to=${to}`);
  if (radix2carry(from, to) > 32) {
    throw new Error(`convertRadix2: carry overflow from=${from} to=${to} carryBits=${radix2carry(from, to)}`);
  }
  let carry = 0;
  let pos = 0;
  const mask = 2 ** to - 1;
  const res = [];
  for (const n of data) {
    assertNumber(n);
    if (n >= 2 ** from)
      throw new Error(`convertRadix2: invalid data word=${n} from=${from}`);
    carry = carry << from | n;
    if (pos + from > 32)
      throw new Error(`convertRadix2: carry overflow pos=${pos} from=${from}`);
    pos += from;
    for (; pos >= to; pos -= to)
      res.push((carry >> pos - to & mask) >>> 0);
    carry &= 2 ** pos - 1;
  }
  carry = carry << to - pos & mask;
  if (!padding2 && pos >= from)
    throw new Error("Excess padding");
  if (!padding2 && carry)
    throw new Error(`Non-zero padding: ${carry}`);
  if (padding2 && pos > 0)
    res.push(carry >>> 0);
  return res;
}
function radix(num) {
  assertNumber(num);
  return {
    encode: (bytes4) => {
      if (!isBytes(bytes4))
        throw new Error("radix.encode input should be Uint8Array");
      return convertRadix(Array.from(bytes4), 2 ** 8, num);
    },
    decode: (digits) => {
      if (!Array.isArray(digits) || digits.length && typeof digits[0] !== "number")
        throw new Error("radix.decode input should be array of numbers");
      return Uint8Array.from(convertRadix(digits, num, 2 ** 8));
    }
  };
}
function radix2(bits2, revPadding = false) {
  assertNumber(bits2);
  if (bits2 <= 0 || bits2 > 32)
    throw new Error("radix2: bits should be in (0..32]");
  if (radix2carry(8, bits2) > 32 || radix2carry(bits2, 8) > 32)
    throw new Error("radix2: carry overflow");
  return {
    encode: (bytes4) => {
      if (!isBytes(bytes4))
        throw new Error("radix2.encode input should be Uint8Array");
      return convertRadix2(Array.from(bytes4), 8, bits2, !revPadding);
    },
    decode: (digits) => {
      if (!Array.isArray(digits) || digits.length && typeof digits[0] !== "number")
        throw new Error("radix2.decode input should be array of numbers");
      return Uint8Array.from(convertRadix2(digits, bits2, 8, revPadding));
    }
  };
}
var base16 = /* @__PURE__ */ chain(radix2(4), alphabet("0123456789ABCDEF"), join(""));
var base32 = /* @__PURE__ */ chain(radix2(5), alphabet("ABCDEFGHIJKLMNOPQRSTUVWXYZ234567"), padding(5), join(""));
var base32hex = /* @__PURE__ */ chain(radix2(5), alphabet("0123456789ABCDEFGHIJKLMNOPQRSTUV"), padding(5), join(""));
var base32crockford = /* @__PURE__ */ chain(radix2(5), alphabet("0123456789ABCDEFGHJKMNPQRSTVWXYZ"), join(""), normalize((s) => s.toUpperCase().replace(/O/g, "0").replace(/[IL]/g, "1")));
var base64 = /* @__PURE__ */ chain(radix2(6), alphabet("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"), padding(6), join(""));
var base64url = /* @__PURE__ */ chain(radix2(6), alphabet("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_"), padding(6), join(""));
var base64urlnopad = /* @__PURE__ */ chain(radix2(6), alphabet("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_"), join(""));
var genBase58 = (abc) => chain(radix(58), alphabet(abc), join(""));
var base58 = /* @__PURE__ */ genBase58("123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz");
var BECH_ALPHABET = /* @__PURE__ */ chain(alphabet("qpzry9x8gf2tvdw0s3jn54khce6mua7l"), join(""));
var hex2 = /* @__PURE__ */ chain(radix2(4), alphabet("0123456789abcdef"), join(""), normalize((s) => {
  if (typeof s !== "string" || s.length % 2)
    throw new TypeError(`hex.decode: expected string, got ${typeof s} with length ${s.length}`);
  return s.toLowerCase();
}));

// node_modules/@polkadot/util-crypto/base32/helpers.js
init_checked_fetch();
init_modules_watch_stub();
function createDecode({ coder, ipfs }, validate) {
  return (value, ipfsCompat) => {
    validate(value, ipfsCompat);
    return coder.decode(ipfs && ipfsCompat ? value.substring(1) : value);
  };
}
function createValidate({ chars, ipfs, type, withPadding }) {
  return (value, ipfsCompat) => {
    if (typeof value !== "string") {
      throw new Error(`Expected ${type} string input`);
    } else if (ipfs && ipfsCompat && !value.startsWith(ipfs)) {
      throw new Error(`Expected ipfs-compatible ${type} to start with '${ipfs}'`);
    }
    for (let i = ipfsCompat ? 1 : 0, count = value.length; i < count; i++) {
      if (chars.includes(value[i])) {
      } else if (withPadding && value[i] === "=") {
        if (i === count - 1) {
        } else if (value[i + 1] === "=") {
        } else {
          throw new Error(`Invalid ${type} padding sequence "${value[i]}${value[i + 1]}" at index ${i}`);
        }
      } else {
        throw new Error(`Invalid ${type} character "${value[i]}" (0x${value.charCodeAt(i).toString(16)}) at index ${i}`);
      }
    }
    return true;
  };
}

// node_modules/@polkadot/util-crypto/base58/bs58.js
var config = {
  chars: "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz",
  coder: base58,
  ipfs: "z",
  type: "base58"
};
var base58Validate = /* @__PURE__ */ createValidate(config);
var base58Decode = /* @__PURE__ */ createDecode(config, base58Validate);

// node_modules/@polkadot/util-crypto/address/checksum.js
init_checked_fetch();
init_modules_watch_stub();

// node_modules/@polkadot/util-crypto/address/sshash.js
init_checked_fetch();
init_modules_watch_stub();

// node_modules/@polkadot/util-crypto/blake2/asU8a.js
init_checked_fetch();
init_modules_watch_stub();

// node_modules/@noble/hashes/esm/blake2b.js
init_checked_fetch();
init_modules_watch_stub();

// node_modules/@noble/hashes/esm/_blake2.js
init_checked_fetch();
init_modules_watch_stub();

// node_modules/@noble/hashes/esm/_assert.js
init_checked_fetch();
init_modules_watch_stub();
function number2(n) {
  if (!Number.isSafeInteger(n) || n < 0)
    throw new Error(`Wrong positive integer: ${n}`);
}
function isBytes2(a) {
  return a instanceof Uint8Array || a != null && typeof a === "object" && a.constructor.name === "Uint8Array";
}
function bytes3(b, ...lengths) {
  if (!isBytes2(b))
    throw new Error("Expected Uint8Array");
  if (lengths.length > 0 && !lengths.includes(b.length))
    throw new Error(`Expected Uint8Array of length ${lengths}, not of length=${b.length}`);
}
function exists2(instance, checkFinished = true) {
  if (instance.destroyed)
    throw new Error("Hash instance has been destroyed");
  if (checkFinished && instance.finished)
    throw new Error("Hash#digest() has already been called");
}
function output2(out, instance) {
  bytes3(out);
  const min = instance.outputLen;
  if (out.length < min) {
    throw new Error(`digestInto() expects output buffer of length at least ${min}`);
  }
}

// node_modules/@noble/hashes/esm/utils.js
init_checked_fetch();
init_modules_watch_stub();
var u323 = (arr) => new Uint32Array(arr.buffer, arr.byteOffset, Math.floor(arr.byteLength / 4));
function isBytes3(a) {
  return a instanceof Uint8Array || a != null && typeof a === "object" && a.constructor.name === "Uint8Array";
}
var isLE2 = new Uint8Array(new Uint32Array([287454020]).buffer)[0] === 68;
if (!isLE2)
  throw new Error("Non little-endian hardware is not supported");
function utf8ToBytes2(str) {
  if (typeof str !== "string")
    throw new Error(`utf8ToBytes expected string, got ${typeof str}`);
  return new Uint8Array(new TextEncoder().encode(str));
}
function toBytes3(data) {
  if (typeof data === "string")
    data = utf8ToBytes2(data);
  if (!isBytes3(data))
    throw new Error(`expected Uint8Array, got ${typeof data}`);
  return data;
}
var Hash2 = class {
  // Safe version that clones internal state
  clone() {
    return this._cloneInto();
  }
};
var toStr2 = {}.toString;
function wrapConstructorWithOpts(hashCons) {
  const hashC = (msg, opts) => hashCons(opts).update(toBytes3(msg)).digest();
  const tmp = hashCons({});
  hashC.outputLen = tmp.outputLen;
  hashC.blockLen = tmp.blockLen;
  hashC.create = (opts) => hashCons(opts);
  return hashC;
}

// node_modules/@noble/hashes/esm/_blake2.js
var SIGMA = /* @__PURE__ */ new Uint8Array([
  0,
  1,
  2,
  3,
  4,
  5,
  6,
  7,
  8,
  9,
  10,
  11,
  12,
  13,
  14,
  15,
  14,
  10,
  4,
  8,
  9,
  15,
  13,
  6,
  1,
  12,
  0,
  2,
  11,
  7,
  5,
  3,
  11,
  8,
  12,
  0,
  5,
  2,
  15,
  13,
  10,
  14,
  3,
  6,
  7,
  1,
  9,
  4,
  7,
  9,
  3,
  1,
  13,
  12,
  11,
  14,
  2,
  6,
  5,
  10,
  4,
  0,
  15,
  8,
  9,
  0,
  5,
  7,
  2,
  4,
  10,
  15,
  14,
  1,
  11,
  12,
  6,
  8,
  3,
  13,
  2,
  12,
  6,
  10,
  0,
  11,
  8,
  3,
  4,
  13,
  7,
  5,
  15,
  14,
  1,
  9,
  12,
  5,
  1,
  15,
  14,
  13,
  4,
  10,
  0,
  7,
  6,
  3,
  9,
  2,
  8,
  11,
  13,
  11,
  7,
  14,
  12,
  1,
  3,
  9,
  5,
  0,
  15,
  4,
  8,
  6,
  2,
  10,
  6,
  15,
  14,
  9,
  11,
  3,
  0,
  8,
  12,
  2,
  13,
  7,
  1,
  4,
  10,
  5,
  10,
  2,
  8,
  4,
  7,
  6,
  1,
  5,
  15,
  11,
  9,
  14,
  3,
  12,
  13,
  0,
  0,
  1,
  2,
  3,
  4,
  5,
  6,
  7,
  8,
  9,
  10,
  11,
  12,
  13,
  14,
  15,
  14,
  10,
  4,
  8,
  9,
  15,
  13,
  6,
  1,
  12,
  0,
  2,
  11,
  7,
  5,
  3
]);
var BLAKE2 = class extends Hash2 {
  constructor(blockLen, outputLen, opts = {}, keyLen, saltLen, persLen) {
    super();
    this.blockLen = blockLen;
    this.outputLen = outputLen;
    this.length = 0;
    this.pos = 0;
    this.finished = false;
    this.destroyed = false;
    number2(blockLen);
    number2(outputLen);
    number2(keyLen);
    if (outputLen < 0 || outputLen > keyLen)
      throw new Error("outputLen bigger than keyLen");
    if (opts.key !== void 0 && (opts.key.length < 1 || opts.key.length > keyLen))
      throw new Error(`key must be up 1..${keyLen} byte long or undefined`);
    if (opts.salt !== void 0 && opts.salt.length !== saltLen)
      throw new Error(`salt must be ${saltLen} byte long or undefined`);
    if (opts.personalization !== void 0 && opts.personalization.length !== persLen)
      throw new Error(`personalization must be ${persLen} byte long or undefined`);
    this.buffer32 = u323(this.buffer = new Uint8Array(blockLen));
  }
  update(data) {
    exists2(this);
    const { blockLen, buffer, buffer32 } = this;
    data = toBytes3(data);
    const len = data.length;
    const offset = data.byteOffset;
    const buf = data.buffer;
    for (let pos = 0; pos < len; ) {
      if (this.pos === blockLen) {
        this.compress(buffer32, 0, false);
        this.pos = 0;
      }
      const take = Math.min(blockLen - this.pos, len - pos);
      const dataOffset = offset + pos;
      if (take === blockLen && !(dataOffset % 4) && pos + take < len) {
        const data32 = new Uint32Array(buf, dataOffset, Math.floor((len - pos) / 4));
        for (let pos32 = 0; pos + blockLen < len; pos32 += buffer32.length, pos += blockLen) {
          this.length += blockLen;
          this.compress(data32, pos32, false);
        }
        continue;
      }
      buffer.set(data.subarray(pos, pos + take), this.pos);
      this.pos += take;
      this.length += take;
      pos += take;
    }
    return this;
  }
  digestInto(out) {
    exists2(this);
    output2(out, this);
    const { pos, buffer32 } = this;
    this.finished = true;
    this.buffer.subarray(pos).fill(0);
    this.compress(buffer32, 0, true);
    const out32 = u323(out);
    this.get().forEach((v, i) => out32[i] = v);
  }
  digest() {
    const { buffer, outputLen } = this;
    this.digestInto(buffer);
    const res = buffer.slice(0, outputLen);
    this.destroy();
    return res;
  }
  _cloneInto(to) {
    const { buffer, length, finished, destroyed, outputLen, pos } = this;
    to || (to = new this.constructor({ dkLen: outputLen }));
    to.set(...this.get());
    to.length = length;
    to.finished = finished;
    to.destroyed = destroyed;
    to.outputLen = outputLen;
    to.buffer.set(buffer);
    to.pos = pos;
    return to;
  }
};

// node_modules/@noble/hashes/esm/_u64.js
init_checked_fetch();
init_modules_watch_stub();
var U32_MASK642 = /* @__PURE__ */ BigInt(2 ** 32 - 1);
var _32n2 = /* @__PURE__ */ BigInt(32);
function fromBig2(n, le2 = false) {
  if (le2)
    return { h: Number(n & U32_MASK642), l: Number(n >> _32n2 & U32_MASK642) };
  return { h: Number(n >> _32n2 & U32_MASK642) | 0, l: Number(n & U32_MASK642) | 0 };
}
function split2(lst, le2 = false) {
  let Ah2 = new Uint32Array(lst.length);
  let Al2 = new Uint32Array(lst.length);
  for (let i = 0; i < lst.length; i++) {
    const { h: h2, l } = fromBig2(lst[i], le2);
    [Ah2[i], Al2[i]] = [h2, l];
  }
  return [Ah2, Al2];
}
var toBig = (h2, l) => BigInt(h2 >>> 0) << _32n2 | BigInt(l >>> 0);
var shrSH = (h2, _l2, s) => h2 >>> s;
var shrSL = (h2, l, s) => h2 << 32 - s | l >>> s;
var rotrSH = (h2, l, s) => h2 >>> s | l << 32 - s;
var rotrSL = (h2, l, s) => h2 << 32 - s | l >>> s;
var rotrBH = (h2, l, s) => h2 << 64 - s | l >>> s - 32;
var rotrBL = (h2, l, s) => h2 >>> s - 32 | l << 64 - s;
var rotr32H = (_h2, l) => l;
var rotr32L = (h2, _l2) => h2;
var rotlSH2 = (h2, l, s) => h2 << s | l >>> 32 - s;
var rotlSL2 = (h2, l, s) => l << s | h2 >>> 32 - s;
var rotlBH2 = (h2, l, s) => l << s - 32 | h2 >>> 64 - s;
var rotlBL2 = (h2, l, s) => h2 << s - 32 | l >>> 64 - s;
function add(Ah2, Al2, Bh2, Bl2) {
  const l = (Al2 >>> 0) + (Bl2 >>> 0);
  return { h: Ah2 + Bh2 + (l / 2 ** 32 | 0) | 0, l: l | 0 };
}
var add3L = (Al2, Bl2, Cl2) => (Al2 >>> 0) + (Bl2 >>> 0) + (Cl2 >>> 0);
var add3H = (low, Ah2, Bh2, Ch2) => Ah2 + Bh2 + Ch2 + (low / 2 ** 32 | 0) | 0;
var add4L = (Al2, Bl2, Cl2, Dl2) => (Al2 >>> 0) + (Bl2 >>> 0) + (Cl2 >>> 0) + (Dl2 >>> 0);
var add4H = (low, Ah2, Bh2, Ch2, Dh2) => Ah2 + Bh2 + Ch2 + Dh2 + (low / 2 ** 32 | 0) | 0;
var add5L = (Al2, Bl2, Cl2, Dl2, El2) => (Al2 >>> 0) + (Bl2 >>> 0) + (Cl2 >>> 0) + (Dl2 >>> 0) + (El2 >>> 0);
var add5H = (low, Ah2, Bh2, Ch2, Dh2, Eh2) => Ah2 + Bh2 + Ch2 + Dh2 + Eh2 + (low / 2 ** 32 | 0) | 0;
var u64 = {
  fromBig: fromBig2,
  split: split2,
  toBig,
  shrSH,
  shrSL,
  rotrSH,
  rotrSL,
  rotrBH,
  rotrBL,
  rotr32H,
  rotr32L,
  rotlSH: rotlSH2,
  rotlSL: rotlSL2,
  rotlBH: rotlBH2,
  rotlBL: rotlBL2,
  add,
  add3L,
  add3H,
  add4L,
  add4H,
  add5H,
  add5L
};
var u64_default = u64;

// node_modules/@noble/hashes/esm/blake2b.js
var IV = /* @__PURE__ */ new Uint32Array([
  4089235720,
  1779033703,
  2227873595,
  3144134277,
  4271175723,
  1013904242,
  1595750129,
  2773480762,
  2917565137,
  1359893119,
  725511199,
  2600822924,
  4215389547,
  528734635,
  327033209,
  1541459225
]);
var BUF = /* @__PURE__ */ new Uint32Array(32);
function G12(a, b, c, d, msg, x) {
  const Xl2 = msg[x], Xh2 = msg[x + 1];
  let Al2 = BUF[2 * a], Ah2 = BUF[2 * a + 1];
  let Bl2 = BUF[2 * b], Bh2 = BUF[2 * b + 1];
  let Cl2 = BUF[2 * c], Ch2 = BUF[2 * c + 1];
  let Dl2 = BUF[2 * d], Dh2 = BUF[2 * d + 1];
  let ll2 = u64_default.add3L(Al2, Bl2, Xl2);
  Ah2 = u64_default.add3H(ll2, Ah2, Bh2, Xh2);
  Al2 = ll2 | 0;
  ({ Dh: Dh2, Dl: Dl2 } = { Dh: Dh2 ^ Ah2, Dl: Dl2 ^ Al2 });
  ({ Dh: Dh2, Dl: Dl2 } = { Dh: u64_default.rotr32H(Dh2, Dl2), Dl: u64_default.rotr32L(Dh2, Dl2) });
  ({ h: Ch2, l: Cl2 } = u64_default.add(Ch2, Cl2, Dh2, Dl2));
  ({ Bh: Bh2, Bl: Bl2 } = { Bh: Bh2 ^ Ch2, Bl: Bl2 ^ Cl2 });
  ({ Bh: Bh2, Bl: Bl2 } = { Bh: u64_default.rotrSH(Bh2, Bl2, 24), Bl: u64_default.rotrSL(Bh2, Bl2, 24) });
  BUF[2 * a] = Al2, BUF[2 * a + 1] = Ah2;
  BUF[2 * b] = Bl2, BUF[2 * b + 1] = Bh2;
  BUF[2 * c] = Cl2, BUF[2 * c + 1] = Ch2;
  BUF[2 * d] = Dl2, BUF[2 * d + 1] = Dh2;
}
function G2(a, b, c, d, msg, x) {
  const Xl2 = msg[x], Xh2 = msg[x + 1];
  let Al2 = BUF[2 * a], Ah2 = BUF[2 * a + 1];
  let Bl2 = BUF[2 * b], Bh2 = BUF[2 * b + 1];
  let Cl2 = BUF[2 * c], Ch2 = BUF[2 * c + 1];
  let Dl2 = BUF[2 * d], Dh2 = BUF[2 * d + 1];
  let ll2 = u64_default.add3L(Al2, Bl2, Xl2);
  Ah2 = u64_default.add3H(ll2, Ah2, Bh2, Xh2);
  Al2 = ll2 | 0;
  ({ Dh: Dh2, Dl: Dl2 } = { Dh: Dh2 ^ Ah2, Dl: Dl2 ^ Al2 });
  ({ Dh: Dh2, Dl: Dl2 } = { Dh: u64_default.rotrSH(Dh2, Dl2, 16), Dl: u64_default.rotrSL(Dh2, Dl2, 16) });
  ({ h: Ch2, l: Cl2 } = u64_default.add(Ch2, Cl2, Dh2, Dl2));
  ({ Bh: Bh2, Bl: Bl2 } = { Bh: Bh2 ^ Ch2, Bl: Bl2 ^ Cl2 });
  ({ Bh: Bh2, Bl: Bl2 } = { Bh: u64_default.rotrBH(Bh2, Bl2, 63), Bl: u64_default.rotrBL(Bh2, Bl2, 63) });
  BUF[2 * a] = Al2, BUF[2 * a + 1] = Ah2;
  BUF[2 * b] = Bl2, BUF[2 * b + 1] = Bh2;
  BUF[2 * c] = Cl2, BUF[2 * c + 1] = Ch2;
  BUF[2 * d] = Dl2, BUF[2 * d + 1] = Dh2;
}
var BLAKE2b = class extends BLAKE2 {
  constructor(opts = {}) {
    super(128, opts.dkLen === void 0 ? 64 : opts.dkLen, opts, 64, 16, 16);
    this.v0l = IV[0] | 0;
    this.v0h = IV[1] | 0;
    this.v1l = IV[2] | 0;
    this.v1h = IV[3] | 0;
    this.v2l = IV[4] | 0;
    this.v2h = IV[5] | 0;
    this.v3l = IV[6] | 0;
    this.v3h = IV[7] | 0;
    this.v4l = IV[8] | 0;
    this.v4h = IV[9] | 0;
    this.v5l = IV[10] | 0;
    this.v5h = IV[11] | 0;
    this.v6l = IV[12] | 0;
    this.v6h = IV[13] | 0;
    this.v7l = IV[14] | 0;
    this.v7h = IV[15] | 0;
    const keyLength = opts.key ? opts.key.length : 0;
    this.v0l ^= this.outputLen | keyLength << 8 | 1 << 16 | 1 << 24;
    if (opts.salt) {
      const salt = u323(toBytes3(opts.salt));
      this.v4l ^= salt[0];
      this.v4h ^= salt[1];
      this.v5l ^= salt[2];
      this.v5h ^= salt[3];
    }
    if (opts.personalization) {
      const pers = u323(toBytes3(opts.personalization));
      this.v6l ^= pers[0];
      this.v6h ^= pers[1];
      this.v7l ^= pers[2];
      this.v7h ^= pers[3];
    }
    if (opts.key) {
      const tmp = new Uint8Array(this.blockLen);
      tmp.set(toBytes3(opts.key));
      this.update(tmp);
    }
  }
  // prettier-ignore
  get() {
    let { v0l, v0h, v1l, v1h, v2l, v2h, v3l, v3h, v4l, v4h, v5l, v5h, v6l, v6h, v7l, v7h } = this;
    return [v0l, v0h, v1l, v1h, v2l, v2h, v3l, v3h, v4l, v4h, v5l, v5h, v6l, v6h, v7l, v7h];
  }
  // prettier-ignore
  set(v0l, v0h, v1l, v1h, v2l, v2h, v3l, v3h, v4l, v4h, v5l, v5h, v6l, v6h, v7l, v7h) {
    this.v0l = v0l | 0;
    this.v0h = v0h | 0;
    this.v1l = v1l | 0;
    this.v1h = v1h | 0;
    this.v2l = v2l | 0;
    this.v2h = v2h | 0;
    this.v3l = v3l | 0;
    this.v3h = v3h | 0;
    this.v4l = v4l | 0;
    this.v4h = v4h | 0;
    this.v5l = v5l | 0;
    this.v5h = v5h | 0;
    this.v6l = v6l | 0;
    this.v6h = v6h | 0;
    this.v7l = v7l | 0;
    this.v7h = v7h | 0;
  }
  compress(msg, offset, isLast) {
    this.get().forEach((v, i) => BUF[i] = v);
    BUF.set(IV, 16);
    let { h: h2, l } = u64_default.fromBig(BigInt(this.length));
    BUF[24] = IV[8] ^ l;
    BUF[25] = IV[9] ^ h2;
    if (isLast) {
      BUF[28] = ~BUF[28];
      BUF[29] = ~BUF[29];
    }
    let j = 0;
    const s = SIGMA;
    for (let i = 0; i < 12; i++) {
      G12(0, 4, 8, 12, msg, offset + 2 * s[j++]);
      G2(0, 4, 8, 12, msg, offset + 2 * s[j++]);
      G12(1, 5, 9, 13, msg, offset + 2 * s[j++]);
      G2(1, 5, 9, 13, msg, offset + 2 * s[j++]);
      G12(2, 6, 10, 14, msg, offset + 2 * s[j++]);
      G2(2, 6, 10, 14, msg, offset + 2 * s[j++]);
      G12(3, 7, 11, 15, msg, offset + 2 * s[j++]);
      G2(3, 7, 11, 15, msg, offset + 2 * s[j++]);
      G12(0, 5, 10, 15, msg, offset + 2 * s[j++]);
      G2(0, 5, 10, 15, msg, offset + 2 * s[j++]);
      G12(1, 6, 11, 12, msg, offset + 2 * s[j++]);
      G2(1, 6, 11, 12, msg, offset + 2 * s[j++]);
      G12(2, 7, 8, 13, msg, offset + 2 * s[j++]);
      G2(2, 7, 8, 13, msg, offset + 2 * s[j++]);
      G12(3, 4, 9, 14, msg, offset + 2 * s[j++]);
      G2(3, 4, 9, 14, msg, offset + 2 * s[j++]);
    }
    this.v0l ^= BUF[0] ^ BUF[16];
    this.v0h ^= BUF[1] ^ BUF[17];
    this.v1l ^= BUF[2] ^ BUF[18];
    this.v1h ^= BUF[3] ^ BUF[19];
    this.v2l ^= BUF[4] ^ BUF[20];
    this.v2h ^= BUF[5] ^ BUF[21];
    this.v3l ^= BUF[6] ^ BUF[22];
    this.v3h ^= BUF[7] ^ BUF[23];
    this.v4l ^= BUF[8] ^ BUF[24];
    this.v4h ^= BUF[9] ^ BUF[25];
    this.v5l ^= BUF[10] ^ BUF[26];
    this.v5h ^= BUF[11] ^ BUF[27];
    this.v6l ^= BUF[12] ^ BUF[28];
    this.v6h ^= BUF[13] ^ BUF[29];
    this.v7l ^= BUF[14] ^ BUF[30];
    this.v7h ^= BUF[15] ^ BUF[31];
    BUF.fill(0);
  }
  destroy() {
    this.destroyed = true;
    this.buffer32.fill(0);
    this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
  }
};
var blake2b2 = /* @__PURE__ */ wrapConstructorWithOpts((opts) => new BLAKE2b(opts));

// node_modules/@polkadot/util-crypto/helpers.js
init_checked_fetch();
init_modules_watch_stub();
function createAsHex(fn2) {
  return (...args) => u8aToHex(fn2(...args));
}

// node_modules/@polkadot/util-crypto/blake2/asU8a.js
function blake2AsU8a(data, bitLength3 = 256, key, onlyJs) {
  const byteLength = Math.ceil(bitLength3 / 8);
  const u8a2 = u8aToU8a(data);
  return !hasBigInt || !onlyJs && isReady() ? blake2b(u8a2, u8aToU8a(key), byteLength) : key ? blake2b2(u8a2, { dkLen: byteLength, key }) : blake2b2(u8a2, { dkLen: byteLength });
}
var blake2AsHex = /* @__PURE__ */ createAsHex(blake2AsU8a);

// node_modules/@polkadot/util-crypto/address/sshash.js
var SS58_PREFIX = stringToU8a("SS58PRE");
function sshash(key) {
  return blake2AsU8a(u8aConcat(SS58_PREFIX, key), 512);
}

// node_modules/@polkadot/util-crypto/address/checksum.js
function checkAddressChecksum(decoded) {
  const ss58Length = decoded[0] & 64 ? 2 : 1;
  const ss58Decoded = ss58Length === 1 ? decoded[0] : (decoded[0] & 63) << 2 | decoded[1] >> 6 | (decoded[1] & 63) << 8;
  const isPublicKey = [34 + ss58Length, 35 + ss58Length].includes(decoded.length);
  const length = decoded.length - (isPublicKey ? 2 : 1);
  const hash2 = sshash(decoded.subarray(0, length));
  const isValid = (decoded[0] & 128) === 0 && ![46, 47].includes(decoded[0]) && (isPublicKey ? decoded[decoded.length - 2] === hash2[0] && decoded[decoded.length - 1] === hash2[1] : decoded[decoded.length - 1] === hash2[0]);
  return [isValid, length, ss58Length, ss58Decoded];
}

// node_modules/@polkadot/util-crypto/address/defaults.js
init_checked_fetch();
init_modules_watch_stub();

// node_modules/@polkadot/util-crypto/networks.js
init_checked_fetch();
init_modules_watch_stub();

// node_modules/@polkadot/networks/interfaces.js
init_checked_fetch();
init_modules_watch_stub();

// node_modules/@substrate/ss58-registry/esm/index.js
init_checked_fetch();
init_modules_watch_stub();
var esm_default = [
  {
    "prefix": 0,
    "network": "polkadot",
    "displayName": "Polkadot Relay Chain",
    "symbols": [
      "DOT"
    ],
    "decimals": [
      10
    ],
    "standardAccount": "*25519",
    "website": "https://polkadot.network"
  },
  {
    "prefix": 1,
    "network": "BareSr25519",
    "displayName": "Bare 32-bit Schnorr/Ristretto (S/R 25519) public key.",
    "symbols": [],
    "decimals": [],
    "standardAccount": "Sr25519",
    "website": null
  },
  {
    "prefix": 2,
    "network": "kusama",
    "displayName": "Kusama Relay Chain",
    "symbols": [
      "KSM"
    ],
    "decimals": [
      12
    ],
    "standardAccount": "*25519",
    "website": "https://kusama.network"
  },
  {
    "prefix": 3,
    "network": "BareEd25519",
    "displayName": "Bare 32-bit Ed25519 public key.",
    "symbols": [],
    "decimals": [],
    "standardAccount": "Ed25519",
    "website": null
  },
  {
    "prefix": 4,
    "network": "katalchain",
    "displayName": "Katal Chain",
    "symbols": [],
    "decimals": [],
    "standardAccount": "*25519",
    "website": null
  },
  {
    "prefix": 5,
    "network": "astar",
    "displayName": "Astar Network",
    "symbols": [
      "ASTR"
    ],
    "decimals": [
      18
    ],
    "standardAccount": "*25519",
    "website": "https://astar.network"
  },
  {
    "prefix": 6,
    "network": "bifrost",
    "displayName": "Bifrost",
    "symbols": [
      "BNC"
    ],
    "decimals": [
      12
    ],
    "standardAccount": "*25519",
    "website": "https://bifrost.finance/"
  },
  {
    "prefix": 7,
    "network": "edgeware",
    "displayName": "Edgeware",
    "symbols": [
      "EDG"
    ],
    "decimals": [
      18
    ],
    "standardAccount": "*25519",
    "website": "https://edgewa.re"
  },
  {
    "prefix": 8,
    "network": "karura",
    "displayName": "Karura",
    "symbols": [
      "KAR"
    ],
    "decimals": [
      12
    ],
    "standardAccount": "*25519",
    "website": "https://karura.network/"
  },
  {
    "prefix": 9,
    "network": "reynolds",
    "displayName": "Laminar Reynolds Canary",
    "symbols": [
      "REY"
    ],
    "decimals": [
      18
    ],
    "standardAccount": "*25519",
    "website": "http://laminar.network/"
  },
  {
    "prefix": 10,
    "network": "acala",
    "displayName": "Acala",
    "symbols": [
      "ACA"
    ],
    "decimals": [
      12
    ],
    "standardAccount": "*25519",
    "website": "https://acala.network/"
  },
  {
    "prefix": 11,
    "network": "laminar",
    "displayName": "Laminar",
    "symbols": [
      "LAMI"
    ],
    "decimals": [
      18
    ],
    "standardAccount": "*25519",
    "website": "http://laminar.network/"
  },
  {
    "prefix": 12,
    "network": "polymesh",
    "displayName": "Polymesh",
    "symbols": [
      "POLYX"
    ],
    "decimals": [
      6
    ],
    "standardAccount": "*25519",
    "website": "https://polymath.network/"
  },
  {
    "prefix": 13,
    "network": "integritee",
    "displayName": "Integritee",
    "symbols": [
      "TEER"
    ],
    "decimals": [
      12
    ],
    "standardAccount": "*25519",
    "website": "https://integritee.network"
  },
  {
    "prefix": 14,
    "network": "totem",
    "displayName": "Totem",
    "symbols": [
      "TOTEM"
    ],
    "decimals": [
      0
    ],
    "standardAccount": "*25519",
    "website": "https://totemaccounting.com"
  },
  {
    "prefix": 15,
    "network": "synesthesia",
    "displayName": "Synesthesia",
    "symbols": [
      "SYN"
    ],
    "decimals": [
      12
    ],
    "standardAccount": "*25519",
    "website": "https://synesthesia.network/"
  },
  {
    "prefix": 16,
    "network": "kulupu",
    "displayName": "Kulupu",
    "symbols": [
      "KLP"
    ],
    "decimals": [
      12
    ],
    "standardAccount": "*25519",
    "website": "https://kulupu.network/"
  },
  {
    "prefix": 17,
    "network": "dark",
    "displayName": "Dark Mainnet",
    "symbols": [],
    "decimals": [],
    "standardAccount": "*25519",
    "website": null
  },
  {
    "prefix": 18,
    "network": "darwinia",
    "displayName": "Darwinia Network",
    "symbols": [
      "RING"
    ],
    "decimals": [
      18
    ],
    "standardAccount": "secp256k1",
    "website": "https://darwinia.network"
  },
  {
    "prefix": 19,
    "network": "watr",
    "displayName": "Watr Protocol",
    "symbols": [
      "WATR"
    ],
    "decimals": [
      18
    ],
    "standardAccount": "*25519",
    "website": "https://www.watr.org"
  },
  {
    "prefix": 20,
    "network": "stafi",
    "displayName": "Stafi",
    "symbols": [
      "FIS"
    ],
    "decimals": [
      12
    ],
    "standardAccount": "*25519",
    "website": "https://stafi.io"
  },
  {
    "prefix": 21,
    "network": "karmachain",
    "displayName": "Karmacoin",
    "symbols": [
      "KCOIN"
    ],
    "decimals": [
      6
    ],
    "standardAccount": "*25519",
    "website": "https://karmaco.in"
  },
  {
    "prefix": 22,
    "network": "dock-pos-mainnet",
    "displayName": "Dock Mainnet",
    "symbols": [
      "DCK"
    ],
    "decimals": [
      6
    ],
    "standardAccount": "*25519",
    "website": "https://dock.io"
  },
  {
    "prefix": 23,
    "network": "shift",
    "displayName": "ShiftNrg",
    "symbols": [],
    "decimals": [],
    "standardAccount": "*25519",
    "website": null
  },
  {
    "prefix": 24,
    "network": "zero",
    "displayName": "ZERO",
    "symbols": [
      "ZERO"
    ],
    "decimals": [
      18
    ],
    "standardAccount": "*25519",
    "website": "https://zero.io"
  },
  {
    "prefix": 25,
    "network": "zero-alphaville",
    "displayName": "ZERO Alphaville",
    "symbols": [
      "ZERO"
    ],
    "decimals": [
      18
    ],
    "standardAccount": "*25519",
    "website": "https://zero.io"
  },
  {
    "prefix": 26,
    "network": "jupiter",
    "displayName": "Jupiter",
    "symbols": [
      "jDOT"
    ],
    "decimals": [
      10
    ],
    "standardAccount": "*25519",
    "website": "https://jupiter.patract.io"
  },
  {
    "prefix": 27,
    "network": "kabocha",
    "displayName": "Kabocha",
    "symbols": [
      "KAB"
    ],
    "decimals": [
      12
    ],
    "standardAccount": "*25519",
    "website": "https://kabocha.network"
  },
  {
    "prefix": 28,
    "network": "subsocial",
    "displayName": "Subsocial",
    "symbols": [],
    "decimals": [],
    "standardAccount": "*25519",
    "website": null
  },
  {
    "prefix": 29,
    "network": "cord",
    "displayName": "CORD Network",
    "symbols": [
      "DHI",
      "WAY"
    ],
    "decimals": [
      12,
      12
    ],
    "standardAccount": "*25519",
    "website": "https://cord.network/"
  },
  {
    "prefix": 30,
    "network": "phala",
    "displayName": "Phala Network",
    "symbols": [
      "PHA"
    ],
    "decimals": [
      12
    ],
    "standardAccount": "*25519",
    "website": "https://phala.network"
  },
  {
    "prefix": 31,
    "network": "litentry",
    "displayName": "Litentry Network",
    "symbols": [
      "LIT"
    ],
    "decimals": [
      12
    ],
    "standardAccount": "*25519",
    "website": "https://litentry.com/"
  },
  {
    "prefix": 32,
    "network": "robonomics",
    "displayName": "Robonomics",
    "symbols": [
      "XRT"
    ],
    "decimals": [
      9
    ],
    "standardAccount": "*25519",
    "website": "https://robonomics.network"
  },
  {
    "prefix": 33,
    "network": "datahighway",
    "displayName": "DataHighway",
    "symbols": [],
    "decimals": [],
    "standardAccount": "*25519",
    "website": null
  },
  {
    "prefix": 34,
    "network": "ares",
    "displayName": "Ares Protocol",
    "symbols": [
      "ARES"
    ],
    "decimals": [
      12
    ],
    "standardAccount": "*25519",
    "website": "https://www.aresprotocol.com/"
  },
  {
    "prefix": 35,
    "network": "vln",
    "displayName": "Valiu Liquidity Network",
    "symbols": [
      "USDv"
    ],
    "decimals": [
      15
    ],
    "standardAccount": "*25519",
    "website": "https://valiu.com/"
  },
  {
    "prefix": 36,
    "network": "centrifuge",
    "displayName": "Centrifuge Chain",
    "symbols": [
      "CFG"
    ],
    "decimals": [
      18
    ],
    "standardAccount": "*25519",
    "website": "https://centrifuge.io/"
  },
  {
    "prefix": 37,
    "network": "nodle",
    "displayName": "Nodle Chain",
    "symbols": [
      "NODL"
    ],
    "decimals": [
      11
    ],
    "standardAccount": "*25519",
    "website": "https://nodle.io/"
  },
  {
    "prefix": 38,
    "network": "kilt",
    "displayName": "KILT Spiritnet",
    "symbols": [
      "KILT"
    ],
    "decimals": [
      15
    ],
    "standardAccount": "*25519",
    "website": "https://kilt.io/"
  },
  {
    "prefix": 39,
    "network": "mathchain",
    "displayName": "MathChain mainnet",
    "symbols": [
      "MATH"
    ],
    "decimals": [
      18
    ],
    "standardAccount": "*25519",
    "website": "https://mathwallet.org"
  },
  {
    "prefix": 40,
    "network": "mathchain-testnet",
    "displayName": "MathChain testnet",
    "symbols": [
      "MATH"
    ],
    "decimals": [
      18
    ],
    "standardAccount": "*25519",
    "website": "https://mathwallet.org"
  },
  {
    "prefix": 41,
    "network": "polimec",
    "displayName": "Polimec Protocol",
    "symbols": [
      "PLMC"
    ],
    "decimals": [
      10
    ],
    "standardAccount": "*25519",
    "website": "https://www.polimec.org/"
  },
  {
    "prefix": 42,
    "network": "substrate",
    "displayName": "Substrate",
    "symbols": [],
    "decimals": [],
    "standardAccount": "*25519",
    "website": "https://substrate.io/"
  },
  {
    "prefix": 43,
    "network": "BareSecp256k1",
    "displayName": "Bare 32-bit ECDSA SECP-256k1 public key.",
    "symbols": [],
    "decimals": [],
    "standardAccount": "secp256k1",
    "website": null
  },
  {
    "prefix": 44,
    "network": "chainx",
    "displayName": "ChainX",
    "symbols": [
      "PCX"
    ],
    "decimals": [
      8
    ],
    "standardAccount": "*25519",
    "website": "https://chainx.org/"
  },
  {
    "prefix": 45,
    "network": "uniarts",
    "displayName": "UniArts Network",
    "symbols": [
      "UART",
      "UINK"
    ],
    "decimals": [
      12,
      12
    ],
    "standardAccount": "*25519",
    "website": "https://uniarts.me"
  },
  {
    "prefix": 46,
    "network": "reserved46",
    "displayName": "This prefix is reserved.",
    "symbols": [],
    "decimals": [],
    "standardAccount": null,
    "website": null
  },
  {
    "prefix": 47,
    "network": "reserved47",
    "displayName": "This prefix is reserved.",
    "symbols": [],
    "decimals": [],
    "standardAccount": null,
    "website": null
  },
  {
    "prefix": 48,
    "network": "neatcoin",
    "displayName": "Neatcoin Mainnet",
    "symbols": [
      "NEAT"
    ],
    "decimals": [
      12
    ],
    "standardAccount": "*25519",
    "website": "https://neatcoin.org"
  },
  {
    "prefix": 49,
    "network": "picasso",
    "displayName": "Picasso",
    "symbols": [
      "PICA"
    ],
    "decimals": [
      12
    ],
    "standardAccount": "*25519",
    "website": "https://picasso.composable.finance"
  },
  {
    "prefix": 50,
    "network": "composable",
    "displayName": "Composable Finance",
    "symbols": [
      "LAYR"
    ],
    "decimals": [
      12
    ],
    "standardAccount": "*25519",
    "website": "https://composable.finance"
  },
  {
    "prefix": 51,
    "network": "oak",
    "displayName": "OAK Network",
    "symbols": [
      "OAK",
      "TUR"
    ],
    "decimals": [
      10,
      10
    ],
    "standardAccount": "*25519",
    "website": "https://oak.tech"
  },
  {
    "prefix": 52,
    "network": "KICO",
    "displayName": "KICO",
    "symbols": [
      "KICO"
    ],
    "decimals": [
      14
    ],
    "standardAccount": "*25519",
    "website": "https://dico.io"
  },
  {
    "prefix": 53,
    "network": "DICO",
    "displayName": "DICO",
    "symbols": [
      "DICO"
    ],
    "decimals": [
      14
    ],
    "standardAccount": "*25519",
    "website": "https://dico.io"
  },
  {
    "prefix": 54,
    "network": "cere",
    "displayName": "Cere Network",
    "symbols": [
      "CERE"
    ],
    "decimals": [
      10
    ],
    "standardAccount": "*25519",
    "website": "https://cere.network"
  },
  {
    "prefix": 55,
    "network": "xxnetwork",
    "displayName": "xx network",
    "symbols": [
      "XX"
    ],
    "decimals": [
      9
    ],
    "standardAccount": "*25519",
    "website": "https://xx.network"
  },
  {
    "prefix": 56,
    "network": "pendulum",
    "displayName": "Pendulum chain",
    "symbols": [
      "PEN"
    ],
    "decimals": [
      12
    ],
    "standardAccount": "*25519",
    "website": "https://pendulumchain.org/"
  },
  {
    "prefix": 57,
    "network": "amplitude",
    "displayName": "Amplitude chain",
    "symbols": [
      "AMPE"
    ],
    "decimals": [
      12
    ],
    "standardAccount": "*25519",
    "website": "https://pendulumchain.org/"
  },
  {
    "prefix": 58,
    "network": "eternal-civilization",
    "displayName": "Eternal Civilization",
    "symbols": [
      "ECC"
    ],
    "decimals": [
      12
    ],
    "standardAccount": "*25519",
    "website": "http://www.ysknfr.cn/"
  },
  {
    "prefix": 63,
    "network": "hydradx",
    "displayName": "HydraDX",
    "symbols": [
      "HDX"
    ],
    "decimals": [
      12
    ],
    "standardAccount": "*25519",
    "website": "https://hydradx.io"
  },
  {
    "prefix": 65,
    "network": "aventus",
    "displayName": "Aventus Mainnet",
    "symbols": [
      "AVT"
    ],
    "decimals": [
      18
    ],
    "standardAccount": "*25519",
    "website": "https://aventus.io"
  },
  {
    "prefix": 66,
    "network": "crust",
    "displayName": "Crust Network",
    "symbols": [
      "CRU"
    ],
    "decimals": [
      12
    ],
    "standardAccount": "*25519",
    "website": "https://crust.network"
  },
  {
    "prefix": 67,
    "network": "genshiro",
    "displayName": "Genshiro Network",
    "symbols": [
      "GENS",
      "EQD",
      "LPT0"
    ],
    "decimals": [
      9,
      9,
      9
    ],
    "standardAccount": "*25519",
    "website": "https://genshiro.equilibrium.io"
  },
  {
    "prefix": 68,
    "network": "equilibrium",
    "displayName": "Equilibrium Network",
    "symbols": [
      "EQ"
    ],
    "decimals": [
      9
    ],
    "standardAccount": "*25519",
    "website": "https://equilibrium.io"
  },
  {
    "prefix": 69,
    "network": "sora",
    "displayName": "SORA Network",
    "symbols": [
      "XOR"
    ],
    "decimals": [
      18
    ],
    "standardAccount": "*25519",
    "website": "https://sora.org"
  },
  {
    "prefix": 71,
    "network": "p3d",
    "displayName": "3DP network",
    "symbols": [
      "P3D"
    ],
    "decimals": [
      12
    ],
    "standardAccount": "*25519",
    "website": "https://3dpass.org"
  },
  {
    "prefix": 72,
    "network": "p3dt",
    "displayName": "3DP test network",
    "symbols": [
      "P3Dt"
    ],
    "decimals": [
      12
    ],
    "standardAccount": "*25519",
    "website": "https://3dpass.org"
  },
  {
    "prefix": 73,
    "network": "zeitgeist",
    "displayName": "Zeitgeist",
    "symbols": [
      "ZTG"
    ],
    "decimals": [
      10
    ],
    "standardAccount": "*25519",
    "website": "https://zeitgeist.pm"
  },
  {
    "prefix": 77,
    "network": "manta",
    "displayName": "Manta network",
    "symbols": [
      "MANTA"
    ],
    "decimals": [
      18
    ],
    "standardAccount": "*25519",
    "website": "https://manta.network"
  },
  {
    "prefix": 78,
    "network": "calamari",
    "displayName": "Calamari: Manta Canary Network",
    "symbols": [
      "KMA"
    ],
    "decimals": [
      12
    ],
    "standardAccount": "*25519",
    "website": "https://manta.network"
  },
  {
    "prefix": 81,
    "network": "sora_dot_para",
    "displayName": "SORA Polkadot Parachain",
    "symbols": [
      "XOR"
    ],
    "decimals": [
      18
    ],
    "standardAccount": "*25519",
    "website": "https://sora.org"
  },
  {
    "prefix": 88,
    "network": "polkadex",
    "displayName": "Polkadex Mainnet",
    "symbols": [
      "PDEX"
    ],
    "decimals": [
      12
    ],
    "standardAccount": "*25519",
    "website": "https://polkadex.trade"
  },
  {
    "prefix": 89,
    "network": "polkadexparachain",
    "displayName": "Polkadex Parachain",
    "symbols": [
      "PDEX"
    ],
    "decimals": [
      12
    ],
    "standardAccount": "*25519",
    "website": "https://polkadex.trade"
  },
  {
    "prefix": 90,
    "network": "frequency",
    "displayName": "Frequency",
    "symbols": [
      "FRQCY"
    ],
    "decimals": [
      8
    ],
    "standardAccount": "*25519",
    "website": "https://www.frequency.xyz"
  },
  {
    "prefix": 92,
    "network": "anmol",
    "displayName": "Anmol Network",
    "symbols": [
      "ANML"
    ],
    "decimals": [
      18
    ],
    "standardAccount": "*25519",
    "website": "https://anmol.network/"
  },
  {
    "prefix": 93,
    "network": "fragnova",
    "displayName": "Fragnova Network",
    "symbols": [
      "NOVA"
    ],
    "decimals": [
      12
    ],
    "standardAccount": "*25519",
    "website": "https://fragnova.com"
  },
  {
    "prefix": 98,
    "network": "polkasmith",
    "displayName": "PolkaSmith Canary Network",
    "symbols": [
      "PKS"
    ],
    "decimals": [
      18
    ],
    "standardAccount": "*25519",
    "website": "https://polkafoundry.com"
  },
  {
    "prefix": 99,
    "network": "polkafoundry",
    "displayName": "PolkaFoundry Network",
    "symbols": [
      "PKF"
    ],
    "decimals": [
      18
    ],
    "standardAccount": "*25519",
    "website": "https://polkafoundry.com"
  },
  {
    "prefix": 100,
    "network": "ibtida",
    "displayName": "Anmol Network Ibtida Canary network",
    "symbols": [
      "IANML"
    ],
    "decimals": [
      18
    ],
    "standardAccount": "*25519",
    "website": "https://anmol.network/"
  },
  {
    "prefix": 101,
    "network": "origintrail-parachain",
    "displayName": "OriginTrail Parachain",
    "symbols": [
      "OTP"
    ],
    "decimals": [
      12
    ],
    "standardAccount": "*25519",
    "website": "https://parachain.origintrail.io/"
  },
  {
    "prefix": 105,
    "network": "pontem-network",
    "displayName": "Pontem Network",
    "symbols": [
      "PONT"
    ],
    "decimals": [
      10
    ],
    "standardAccount": "*25519",
    "website": "https://pontem.network"
  },
  {
    "prefix": 110,
    "network": "heiko",
    "displayName": "Heiko",
    "symbols": [
      "HKO"
    ],
    "decimals": [
      12
    ],
    "standardAccount": "*25519",
    "website": "https://parallel.fi/"
  },
  {
    "prefix": 113,
    "network": "integritee-incognito",
    "displayName": "Integritee Incognito",
    "symbols": [],
    "decimals": [],
    "standardAccount": "*25519",
    "website": "https://integritee.network"
  },
  {
    "prefix": 117,
    "network": "tinker",
    "displayName": "Tinker",
    "symbols": [
      "TNKR"
    ],
    "decimals": [
      12
    ],
    "standardAccount": "*25519",
    "website": "https://invarch.network"
  },
  {
    "prefix": 126,
    "network": "joystream",
    "displayName": "Joystream",
    "symbols": [
      "JOY"
    ],
    "decimals": [
      10
    ],
    "standardAccount": "*25519",
    "website": "https://www.joystream.org"
  },
  {
    "prefix": 128,
    "network": "clover",
    "displayName": "Clover Finance",
    "symbols": [
      "CLV"
    ],
    "decimals": [
      18
    ],
    "standardAccount": "*25519",
    "website": "https://clover.finance"
  },
  {
    "prefix": 129,
    "network": "dorafactory-polkadot",
    "displayName": "Dorafactory Polkadot Network",
    "symbols": [
      "DORA"
    ],
    "decimals": [
      12
    ],
    "standardAccount": "*25519",
    "website": "https://dorafactory.org"
  },
  {
    "prefix": 131,
    "network": "litmus",
    "displayName": "Litmus Network",
    "symbols": [
      "LIT"
    ],
    "decimals": [
      12
    ],
    "standardAccount": "*25519",
    "website": "https://litentry.com/"
  },
  {
    "prefix": 136,
    "network": "altair",
    "displayName": "Altair",
    "symbols": [
      "AIR"
    ],
    "decimals": [
      18
    ],
    "standardAccount": "*25519",
    "website": "https://centrifuge.io/"
  },
  {
    "prefix": 137,
    "network": "vara",
    "displayName": "Vara Network",
    "symbols": [
      "VARA"
    ],
    "decimals": [
      12
    ],
    "standardAccount": "*25519",
    "website": "https://vara.network/"
  },
  {
    "prefix": 172,
    "network": "parallel",
    "displayName": "Parallel",
    "symbols": [
      "PARA"
    ],
    "decimals": [
      12
    ],
    "standardAccount": "*25519",
    "website": "https://parallel.fi/"
  },
  {
    "prefix": 252,
    "network": "social-network",
    "displayName": "Social Network",
    "symbols": [
      "NET"
    ],
    "decimals": [
      18
    ],
    "standardAccount": "*25519",
    "website": "https://social.network"
  },
  {
    "prefix": 255,
    "network": "quartz_mainnet",
    "displayName": "QUARTZ by UNIQUE",
    "symbols": [
      "QTZ"
    ],
    "decimals": [
      18
    ],
    "standardAccount": "*25519",
    "website": "https://unique.network"
  },
  {
    "prefix": 268,
    "network": "pioneer_network",
    "displayName": "Pioneer Network by Bit.Country",
    "symbols": [
      "NEER"
    ],
    "decimals": [
      18
    ],
    "standardAccount": "*25519",
    "website": "https://bit.country"
  },
  {
    "prefix": 420,
    "network": "sora_kusama_para",
    "displayName": "SORA Kusama Parachain",
    "symbols": [
      "XOR"
    ],
    "decimals": [
      18
    ],
    "standardAccount": "*25519",
    "website": "https://sora.org"
  },
  {
    "prefix": 440,
    "network": "allfeat_network",
    "displayName": "Allfeat Network",
    "symbols": [
      "AFT"
    ],
    "decimals": [
      12
    ],
    "standardAccount": "*25519",
    "website": "https://allfeat.network"
  },
  {
    "prefix": 666,
    "network": "metaquity_network",
    "displayName": "Metaquity Network",
    "symbols": [
      "MQTY"
    ],
    "decimals": [
      18
    ],
    "standardAccount": "*25519",
    "website": "https://metaquity.xyz/"
  },
  {
    "prefix": 777,
    "network": "curio",
    "displayName": "Curio",
    "symbols": [
      "CGT"
    ],
    "decimals": [
      18
    ],
    "standardAccount": "*25519",
    "website": "https://parachain.capitaldex.exchange/"
  },
  {
    "prefix": 789,
    "network": "geek",
    "displayName": "GEEK Network",
    "symbols": [
      "GEEK"
    ],
    "decimals": [
      18
    ],
    "standardAccount": "*25519",
    "website": "https://geek.gl"
  },
  {
    "prefix": 995,
    "network": "ternoa",
    "displayName": "Ternoa",
    "symbols": [
      "CAPS"
    ],
    "decimals": [
      18
    ],
    "standardAccount": "*25519",
    "website": "https://www.ternoa.network"
  },
  {
    "prefix": 1110,
    "network": "efinity",
    "displayName": "Efinity",
    "symbols": [
      "EFI"
    ],
    "decimals": [
      18
    ],
    "standardAccount": "*25519",
    "website": "https://efinity.io/"
  },
  {
    "prefix": 1221,
    "network": "peaq",
    "displayName": "Peaq Network",
    "symbols": [
      "PEAQ"
    ],
    "decimals": [
      18
    ],
    "standardAccount": "Sr25519",
    "website": "https://www.peaq.network/"
  },
  {
    "prefix": 1222,
    "network": "krest",
    "displayName": "Krest Network",
    "symbols": [
      "KREST"
    ],
    "decimals": [
      18
    ],
    "standardAccount": "Sr25519",
    "website": "https://www.peaq.network/"
  },
  {
    "prefix": 1284,
    "network": "moonbeam",
    "displayName": "Moonbeam",
    "symbols": [
      "GLMR"
    ],
    "decimals": [
      18
    ],
    "standardAccount": "secp256k1",
    "website": "https://moonbeam.network"
  },
  {
    "prefix": 1285,
    "network": "moonriver",
    "displayName": "Moonriver",
    "symbols": [
      "MOVR"
    ],
    "decimals": [
      18
    ],
    "standardAccount": "secp256k1",
    "website": "https://moonbeam.network"
  },
  {
    "prefix": 1328,
    "network": "ajuna",
    "displayName": "Ajuna Network",
    "symbols": [
      "AJUN"
    ],
    "decimals": [
      12
    ],
    "standardAccount": "*25519",
    "website": "https://ajuna.io"
  },
  {
    "prefix": 1337,
    "network": "bajun",
    "displayName": "Bajun Network",
    "symbols": [
      "BAJU"
    ],
    "decimals": [
      12
    ],
    "standardAccount": "*25519",
    "website": "https://ajuna.io"
  },
  {
    "prefix": 1516,
    "network": "societal",
    "displayName": "Societal",
    "symbols": [
      "SCTL"
    ],
    "decimals": [
      12
    ],
    "standardAccount": "*25519",
    "website": "https://www.sctl.xyz"
  },
  {
    "prefix": 1985,
    "network": "seals",
    "displayName": "Seals Network",
    "symbols": [
      "SEAL"
    ],
    "decimals": [
      9
    ],
    "standardAccount": "*25519",
    "website": "https://seals.app"
  },
  {
    "prefix": 2007,
    "network": "kapex",
    "displayName": "Kapex",
    "symbols": [
      "KAPEX"
    ],
    "decimals": [
      12
    ],
    "standardAccount": "*25519",
    "website": "https://totemaccounting.com"
  },
  {
    "prefix": 2009,
    "network": "cloudwalk_mainnet",
    "displayName": "CloudWalk Network Mainnet",
    "symbols": [
      "CWN"
    ],
    "decimals": [
      18
    ],
    "standardAccount": "*25519",
    "website": "https://explorer.mainnet.cloudwalk.io"
  },
  {
    "prefix": 2021,
    "network": "logion",
    "displayName": "logion network",
    "symbols": [
      "LGNT"
    ],
    "decimals": [
      18
    ],
    "standardAccount": "*25519",
    "website": "https://logion.network"
  },
  {
    "prefix": 2032,
    "network": "interlay",
    "displayName": "Interlay",
    "symbols": [
      "INTR"
    ],
    "decimals": [
      10
    ],
    "standardAccount": "*25519",
    "website": "https://interlay.io/"
  },
  {
    "prefix": 2092,
    "network": "kintsugi",
    "displayName": "Kintsugi",
    "symbols": [
      "KINT"
    ],
    "decimals": [
      12
    ],
    "standardAccount": "*25519",
    "website": "https://interlay.io/"
  },
  {
    "prefix": 2106,
    "network": "bitgreen",
    "displayName": "Bitgreen",
    "symbols": [
      "BBB"
    ],
    "decimals": [
      18
    ],
    "standardAccount": "*25519",
    "website": "https://bitgreen.org/"
  },
  {
    "prefix": 2112,
    "network": "chainflip",
    "displayName": "Chainflip",
    "symbols": [
      "FLIP"
    ],
    "decimals": [
      18
    ],
    "standardAccount": "*25519",
    "website": "https://chainflip.io/"
  },
  {
    "prefix": 2199,
    "network": "moonsama",
    "displayName": "Moonsama",
    "symbols": [
      "SAMA"
    ],
    "decimals": [
      18
    ],
    "standardAccount": "secp256k1",
    "website": "https://moonsama.com"
  },
  {
    "prefix": 2206,
    "network": "ICE",
    "displayName": "ICE Network",
    "symbols": [
      "ICY"
    ],
    "decimals": [
      18
    ],
    "standardAccount": "*25519",
    "website": "https://icenetwork.io"
  },
  {
    "prefix": 2207,
    "network": "SNOW",
    "displayName": "SNOW: ICE Canary Network",
    "symbols": [
      "ICZ"
    ],
    "decimals": [
      18
    ],
    "standardAccount": "*25519",
    "website": "https://icenetwork.io"
  },
  {
    "prefix": 2254,
    "network": "subspace_testnet",
    "displayName": "Subspace testnet",
    "symbols": [
      "tSSC"
    ],
    "decimals": [
      18
    ],
    "standardAccount": "*25519",
    "website": "https://subspace.network"
  },
  {
    "prefix": 3333,
    "network": "peerplays",
    "displayName": "Peerplays",
    "symbols": [
      "PPY"
    ],
    "decimals": [
      18
    ],
    "standardAccount": "secp256k1",
    "website": "https://www.peerplays.com/"
  },
  {
    "prefix": 4450,
    "network": "g1",
    "displayName": "\u011E1",
    "symbols": [
      "G1"
    ],
    "decimals": [
      2
    ],
    "standardAccount": "*25519",
    "website": "https://duniter.org"
  },
  {
    "prefix": 5234,
    "network": "humanode",
    "displayName": "Humanode Network",
    "symbols": [
      "HMND"
    ],
    "decimals": [
      18
    ],
    "standardAccount": "*25519",
    "website": "https://humanode.io"
  },
  {
    "prefix": 5845,
    "network": "tangle",
    "displayName": "Tangle Network",
    "symbols": [
      "TNT"
    ],
    "decimals": [
      18
    ],
    "standardAccount": "*25519",
    "website": "https://www.tangle.tools/"
  },
  {
    "prefix": 6094,
    "network": "subspace",
    "displayName": "Subspace",
    "symbols": [
      "SSC"
    ],
    "decimals": [
      18
    ],
    "standardAccount": "*25519",
    "website": "https://subspace.network"
  },
  {
    "prefix": 7007,
    "network": "tidefi",
    "displayName": "Tidefi",
    "symbols": [
      "TDFY"
    ],
    "decimals": [
      12
    ],
    "standardAccount": "*25519",
    "website": "https://tidefi.com"
  },
  {
    "prefix": 7013,
    "network": "gm",
    "displayName": "GM",
    "symbols": [
      "FREN",
      "GM",
      "GN"
    ],
    "decimals": [
      12,
      0,
      0
    ],
    "standardAccount": "*25519",
    "website": "https://gmordie.com"
  },
  {
    "prefix": 7306,
    "network": "krigan",
    "displayName": "Krigan Network",
    "symbols": [
      "KRGN"
    ],
    "decimals": [
      9
    ],
    "standardAccount": "*25519",
    "website": "https://krigan.network"
  },
  {
    "prefix": 7391,
    "network": "unique_mainnet",
    "displayName": "Unique Network",
    "symbols": [
      "UNQ"
    ],
    "decimals": [
      18
    ],
    "standardAccount": "*25519",
    "website": "https://unique.network"
  },
  {
    "prefix": 8866,
    "network": "golden_gate",
    "displayName": "Golden Gate",
    "symbols": [
      "GGX"
    ],
    "decimals": [
      18
    ],
    "standardAccount": "*25519",
    "website": "https://ggxchain.io/"
  },
  {
    "prefix": 8883,
    "network": "sapphire_mainnet",
    "displayName": "Sapphire by Unique",
    "symbols": [
      "QTZ"
    ],
    "decimals": [
      18
    ],
    "standardAccount": "*25519",
    "website": "https://unique.network"
  },
  {
    "prefix": 8886,
    "network": "golden_gate_sydney",
    "displayName": "Golden Gate Sydney",
    "symbols": [
      "GGXT"
    ],
    "decimals": [
      18
    ],
    "standardAccount": "*25519",
    "website": "https://ggxchain.io/"
  },
  {
    "prefix": 9072,
    "network": "hashed",
    "displayName": "Hashed Network",
    "symbols": [
      "HASH"
    ],
    "decimals": [
      18
    ],
    "standardAccount": "*25519",
    "website": "https://hashed.network"
  },
  {
    "prefix": 9807,
    "network": "dentnet",
    "displayName": "DENTNet",
    "symbols": [
      "DENTX"
    ],
    "decimals": [
      18
    ],
    "standardAccount": "*25519",
    "website": "https://www.dentnet.io"
  },
  {
    "prefix": 9935,
    "network": "t3rn",
    "displayName": "t3rn",
    "symbols": [
      "TRN"
    ],
    "decimals": [
      12
    ],
    "standardAccount": "*25519",
    "website": "https://t3rn.io/"
  },
  {
    "prefix": 10041,
    "network": "basilisk",
    "displayName": "Basilisk",
    "symbols": [
      "BSX"
    ],
    "decimals": [
      12
    ],
    "standardAccount": "*25519",
    "website": "https://bsx.fi"
  },
  {
    "prefix": 11330,
    "network": "cess-testnet",
    "displayName": "CESS Testnet",
    "symbols": [
      "TCESS"
    ],
    "decimals": [
      12
    ],
    "standardAccount": "*25519",
    "website": "https://cess.cloud"
  },
  {
    "prefix": 11331,
    "network": "cess",
    "displayName": "CESS",
    "symbols": [
      "CESS"
    ],
    "decimals": [
      12
    ],
    "standardAccount": "*25519",
    "website": "https://cess.cloud"
  },
  {
    "prefix": 11486,
    "network": "luhn",
    "displayName": "Luhn Network",
    "symbols": [
      "LUHN"
    ],
    "decimals": [
      18
    ],
    "standardAccount": "*25519",
    "website": "https://luhn.network"
  },
  {
    "prefix": 11820,
    "network": "contextfree",
    "displayName": "Automata ContextFree",
    "symbols": [
      "CTX"
    ],
    "decimals": [
      18
    ],
    "standardAccount": "*25519",
    "website": "https://ata.network"
  },
  {
    "prefix": 12155,
    "network": "impact",
    "displayName": "Impact Protocol Network",
    "symbols": [
      "BSTY"
    ],
    "decimals": [
      18
    ],
    "standardAccount": "*25519",
    "website": "https://impactprotocol.network/"
  },
  {
    "prefix": 12191,
    "network": "nftmart",
    "displayName": "NFTMart",
    "symbols": [
      "NMT"
    ],
    "decimals": [
      12
    ],
    "standardAccount": "*25519",
    "website": "https://nftmart.io"
  },
  {
    "prefix": 13116,
    "network": "bittensor",
    "displayName": "Bittensor",
    "symbols": [
      "TAO"
    ],
    "decimals": [
      9
    ],
    "standardAccount": "*25519",
    "website": "https://bittensor.com"
  },
  {
    "prefix": 14697,
    "network": "goro",
    "displayName": "GORO Network",
    "symbols": [
      "GORO"
    ],
    "decimals": [
      9
    ],
    "standardAccount": "*25519",
    "website": "https://goro.network"
  }
];

// node_modules/@polkadot/networks/defaults/index.js
init_checked_fetch();
init_modules_watch_stub();

// node_modules/@polkadot/networks/defaults/genesis.js
init_checked_fetch();
init_modules_watch_stub();
var knownGenesis = {
  acala: [
    "0xfc41b9bd8ef8fe53d58c7ea67c794c7ec9a73daf05e6d54b14ff6342c99ba64c"
  ],
  ajuna: [
    "0xe358eb1d11b31255a286c12e44fe6780b7edb171d657905a97e39f71d9c6c3ee"
  ],
  "aleph-node": [
    "0x70255b4d28de0fc4e1a193d7e175ad1ccef431598211c55538f1018651a0344e"
  ],
  astar: [
    "0x9eb76c5184c4ab8679d2d5d819fdf90b9c001403e9e17da2e14b6d8aec4029c6"
  ],
  basilisk: [
    "0xa85cfb9b9fd4d622a5b28289a02347af987d8f73fa3108450e2b4a11c1ce5755"
  ],
  bifrost: [
    "0x262e1b2ad728475fd6fe88e62d34c200abe6fd693931ddad144059b1eb884e5b"
  ],
  "bifrost-kusama": [
    "0x9f28c6a68e0fc9646eff64935684f6eeeece527e37bbe1f213d22caa1d9d6bed"
  ],
  bittensor: [
    "0x2f0555cc76fc2840a25a6ea3b9637146806f1f44b090c175ffde2a7e5ab36c03"
  ],
  centrifuge: [
    "0xb3db41421702df9a7fcac62b53ffeac85f7853cc4e689e0b93aeb3db18c09d82",
    "0x67dddf2673b69e5f875f6f25277495834398eafd67f492e09f3f3345e003d1b5"
  ],
  cere: [
    "0x81443836a9a24caaa23f1241897d1235717535711d1d3fe24eae4fdc942c092c"
  ],
  composable: [
    "0xdaab8df776eb52ec604a5df5d388bb62a050a0aaec4556a64265b9d42755552d"
  ],
  darwinia: [
    "0xe71578b37a7c799b0ab4ee87ffa6f059a6b98f71f06fb8c84a8d88013a548ad6"
  ],
  "dock-mainnet": [
    "0x6bfe24dca2a3be10f22212678ac13a6446ec764103c0f3471c71609eac384aae",
    "0xf73467c6544aa68df2ee546b135f955c46b90fa627e9b5d7935f41061bb8a5a9"
  ],
  edgeware: [
    "0x742a2ca70c2fda6cee4f8df98d64c4c670a052d9568058982dad9d5a7a135c5b"
  ],
  enjin: [
    "0xd8761d3c88f26dc12875c00d3165f7d67243d56fc85b4cf19937601a7916e5a9"
  ],
  equilibrium: [
    "0x6f1a800de3daff7f5e037ddf66ab22ce03ab91874debeddb1086f5f7dbd48925"
  ],
  genshiro: [
    "0x9b8cefc0eb5c568b527998bdd76c184e2b76ae561be76e4667072230217ea243"
  ],
  hydradx: [
    "0xafdc188f45c71dacbaa0b62e16a91f726c7b8699a9748cdf715459de6b7f366d",
    // HydraDX Parachain
    "0xd2a620c27ec5cbc5621ff9a522689895074f7cca0d08e7134a7804e1a3ba86fc",
    // Snakenet Gen3-1
    "0x10af6e84234477d84dc572bac0789813b254aa490767ed06fb9591191d1073f9",
    // Snakenet Gen3
    "0x3d75507dd46301767e601265791da1d9cb47b6ebc94e87347b635e5bf58bd047",
    // Snakenet Gen2
    "0x0ed32bfcab4a83517fac88f2aa7cbc2f88d3ab93be9a12b6188a036bf8a943c2"
    // Snakenet Gen1
  ],
  "interlay-parachain": [
    "0xbf88efe70e9e0e916416e8bed61f2b45717f517d7f3523e33c7b001e5ffcbc72"
  ],
  karura: [
    "0xbaf5aabe40646d11f0ee8abbdc64f4a4b7674925cba08e4a05ff9ebed6e2126b"
  ],
  khala: [
    "0xd43540ba6d3eb4897c28a77d48cb5b729fea37603cbbfc7a86a73b72adb3be8d"
  ],
  kulupu: [
    "0xf7a99d3cb92853d00d5275c971c132c074636256583fee53b3bbe60d7b8769ba"
  ],
  kusama: [
    "0xb0a8d493285c2df73290dfb7e61f870f17b41801197a149ca93654499ea3dafe",
    // Kusama CC3,
    "0xe3777fa922cafbff200cadeaea1a76bd7898ad5b89f7848999058b50e715f636",
    // Kusama CC2
    "0x3fd7b9eb6a00376e5be61f01abb429ffb0b104be05eaff4d458da48fcd425baf"
    // Kusama CC1
  ],
  matrixchain: [
    "0x3af4ff48ec76d2efc8476730f423ac07e25ad48f5f4c9dc39c778b164d808615"
  ],
  nodle: [
    "0x97da7ede98d7bad4e36b4d734b6055425a3be036da2a332ea5a7037656427a21"
  ],
  origintrail: [
    "0xe7e0962324a3b86c83404dbea483f25fb5dab4c224791c81b756cfc948006174"
  ],
  p3d: [
    "0x6c5894837ad89b6d92b114a2fb3eafa8fe3d26a54848e3447015442cd6ef4e66"
  ],
  parallel: [
    "0xe61a41c53f5dcd0beb09df93b34402aada44cb05117b71059cce40a2723a4e97"
  ],
  pendulum: [
    "0x5d3c298622d5634ed019bf61ea4b71655030015bde9beb0d6a24743714462c86"
  ],
  phala: [
    "0x1bb969d85965e4bb5a651abbedf21a54b6b31a21f66b5401cc3f1e286268d736"
  ],
  picasso: [
    "0x6811a339673c9daa897944dcdac99c6e2939cc88245ed21951a0a3c9a2be75bc",
    "0xe8e7f0f4c4f5a00720b4821dbfddefea7490bcf0b19009961cc46957984e2c1c"
  ],
  polkadex: [
    "0x3920bcb4960a1eef5580cd5367ff3f430eef052774f78468852f7b9cb39f8a3c"
  ],
  polkadot: [
    "0x91b171bb158e2d3848fa23a9f1c25182fb8e20313b2c1eb49219da7a70ce90c3"
  ],
  polymesh: [
    "0x6fbd74e5e1d0a61d52ccfe9d4adaed16dd3a7caa37c6bc4d0c2fa12e8b2f4063"
  ],
  quartz: [
    "0xcd4d732201ebe5d6b014edda071c4203e16867305332301dc8d092044b28e554"
  ],
  rococo: [
    "0x6408de7737c59c238890533af25896a2c20608d8b380bb01029acb392781063e",
    "0xaaf2cd1b74b5f726895921259421b534124726263982522174147046b8827897",
    "0x037f5f3c8e67b314062025fc886fcd6238ea25a4a9b45dce8d246815c9ebe770",
    "0xc196f81260cf1686172b47a79cf002120735d7cb0eb1474e8adce56618456fff",
    "0xf6e9983c37baf68846fedafe21e56718790e39fb1c582abc408b81bc7b208f9a",
    "0x5fce687da39305dfe682b117f0820b319348e8bb37eb16cf34acbf6a202de9d9",
    "0xe7c3d5edde7db964317cd9b51a3a059d7cd99f81bdbce14990047354334c9779",
    "0x1611e1dbf0405379b861e2e27daa90f480b2e6d3682414a80835a52e8cb8a215",
    "0x343442f12fa715489a8714e79a7b264ea88c0d5b8c66b684a7788a516032f6b9",
    "0x78bcd530c6b3a068bc17473cf5d2aff9c287102bed9af3ae3c41c33b9d6c6147",
    "0x47381ee0697153d64404fc578392c8fd5cba9073391908f46c888498415647bd",
    "0x19c0e4fa8ab75f5ac7865e0b8f74ff91eb9a100d336f423cd013a8befba40299"
  ],
  sora: [
    "0x7e4e32d0feafd4f9c9414b0be86373f9a1efa904809b683453a9af6856d38ad5"
  ],
  stafi: [
    "0x290a4149f09ea0e402c74c1c7e96ae4239588577fe78932f94f5404c68243d80"
  ],
  statemine: [
    "0x48239ef607d7928874027a43a67689209727dfb3d3dc5e5b03a39bdc2eda771a"
  ],
  statemint: [
    "0x68d56f15f85d3136970ec16946040bc1752654e906147f7e43e9d539d7c3de2f"
  ],
  subsocial: [
    "0x0bd72c1c305172e1275278aaeb3f161e02eccb7a819e63f62d47bd53a28189f8"
  ],
  ternoa: [
    "0x6859c81ca95ef624c9dfe4dc6e3381c33e5d6509e35e147092bfbc780f777c4e"
  ],
  unique: [
    "0x84322d9cddbf35088f1e54e9a85c967a41a56a4f43445768125e61af166c7d31"
  ],
  vtb: [
    "0x286bc8414c7000ce1d6ee6a834e29a54c1784814b76243eb77ed0b2c5573c60f",
    "0x7483b89572fb2bd687c7b9a93b242d0b237f9aba463aba07ec24503931038aaa"
  ],
  westend: [
    "0xe143f23803ac50e8f6f8e62695d1ce9e4e1d68aa36c1cd2cfd15340213f3423e"
  ],
  xxnetwork: [
    "0x50dd5d206917bf10502c68fb4d18a59fc8aa31586f4e8856b493e43544aa82aa"
  ],
  zeitgeist: [
    "0x1bf2a2ecb4a868de66ea8610f2ce7c8c43706561b6476031315f6640fe38e060"
  ]
};

// node_modules/@polkadot/networks/defaults/icons.js
init_checked_fetch();
init_modules_watch_stub();
var knownIcon = {
  centrifuge: "polkadot",
  kusama: "polkadot",
  polkadot: "polkadot",
  sora: "polkadot",
  statemine: "polkadot",
  statemint: "polkadot",
  westmint: "polkadot"
};

// node_modules/@polkadot/networks/defaults/ledger.js
init_checked_fetch();
init_modules_watch_stub();
var knownLedger = {
  acala: 787,
  ajuna: 354,
  "aleph-node": 643,
  astar: 810,
  bifrost: 788,
  "bifrost-kusama": 788,
  centrifuge: 747,
  composable: 354,
  darwinia: 354,
  "dock-mainnet": 594,
  edgeware: 523,
  enjin: 1155,
  equilibrium: 99999997,
  genshiro: 99999996,
  hydradx: 354,
  "interlay-parachain": 354,
  karura: 686,
  khala: 434,
  kusama: 434,
  matrixchain: 1155,
  nodle: 1003,
  origintrail: 354,
  parallel: 354,
  pendulum: 354,
  phala: 354,
  picasso: 434,
  polkadex: 799,
  polkadot: 354,
  polymesh: 595,
  quartz: 631,
  sora: 617,
  stafi: 907,
  statemine: 434,
  // common-good on Kusama, shares derivation
  statemint: 354,
  // common-good on Polkadot, shares derivation
  ternoa: 995,
  unique: 661,
  vtb: 694,
  xxnetwork: 1955,
  zeitgeist: 354
};

// node_modules/@polkadot/networks/defaults/testnets.js
init_checked_fetch();
init_modules_watch_stub();
var knownTestnet = {
  "": true,
  // this is the default non-network entry
  "cess-testnet": true,
  "dock-testnet": true,
  jupiter: true,
  "mathchain-testnet": true,
  p3dt: true,
  subspace_testnet: true,
  "zero-alphaville": true
};

// node_modules/@polkadot/networks/interfaces.js
var UNSORTED = [0, 2, 42];
var TESTNETS = ["testnet"];
function toExpanded(o) {
  const network = o.network || "";
  const nameParts = network.replace(/_/g, "-").split("-");
  const n = o;
  n.slip44 = knownLedger[network];
  n.hasLedgerSupport = !!n.slip44;
  n.genesisHash = knownGenesis[network] || [];
  n.icon = knownIcon[network] || "substrate";
  n.isTestnet = !!knownTestnet[network] || TESTNETS.includes(nameParts[nameParts.length - 1]);
  n.isIgnored = n.isTestnet || !(o.standardAccount && o.decimals?.length && o.symbols?.length) && o.prefix !== 42;
  return n;
}
function filterSelectable({ genesisHash, prefix }) {
  return !!genesisHash.length || prefix === 42;
}
function filterAvailable(n) {
  return !n.isIgnored && !!n.network;
}
function sortNetworks(a, b) {
  const isUnSortedA = UNSORTED.includes(a.prefix);
  const isUnSortedB = UNSORTED.includes(b.prefix);
  return isUnSortedA === isUnSortedB ? isUnSortedA ? 0 : a.displayName.localeCompare(b.displayName) : isUnSortedA ? -1 : 1;
}
var allNetworks = esm_default.map(toExpanded);
var availableNetworks = allNetworks.filter(filterAvailable).sort(sortNetworks);
var selectableNetworks = availableNetworks.filter(filterSelectable);

// node_modules/@polkadot/util-crypto/address/defaults.js
var defaults = {
  allowedDecodedLengths: [1, 2, 4, 8, 32, 33],
  // publicKey has prefix + 2 checksum bytes, short only prefix + 1 checksum byte
  allowedEncodedLengths: [3, 4, 6, 10, 35, 36, 37, 38],
  allowedPrefix: availableNetworks.map(({ prefix }) => prefix),
  prefix: 42
};

// node_modules/@polkadot/util-crypto/address/decode.js
function decodeAddress(encoded, ignoreChecksum, ss58Format = -1) {
  if (!encoded) {
    throw new Error("Invalid empty address passed");
  }
  if (isU8a(encoded) || isHex2(encoded)) {
    return u8aToU8a(encoded);
  }
  try {
    const decoded = base58Decode(encoded);
    if (!defaults.allowedEncodedLengths.includes(decoded.length)) {
      throw new Error("Invalid decoded address length");
    }
    const [isValid, endPos, ss58Length, ss58Decoded] = checkAddressChecksum(decoded);
    if (!isValid && !ignoreChecksum) {
      throw new Error("Invalid decoded address checksum");
    } else if (ss58Format !== -1 && ss58Format !== ss58Decoded) {
      throw new Error(`Expected ss58Format ${ss58Format}, received ${ss58Decoded}`);
    }
    return decoded.slice(ss58Length, endPos);
  } catch (error) {
    throw new Error(`Decoding ${encoded}: ${error.message}`);
  }
}

// node_modules/@polkadot/util-crypto/blake2/index.js
init_checked_fetch();
init_modules_watch_stub();

// node_modules/@polkadot/util-crypto/address/is.js
init_checked_fetch();
init_modules_watch_stub();

// node_modules/@polkadot/util-crypto/address/validate.js
init_checked_fetch();
init_modules_watch_stub();
function validateAddress(encoded, ignoreChecksum, ss58Format) {
  return !!decodeAddress(encoded, ignoreChecksum, ss58Format);
}

// node_modules/@polkadot/util-crypto/address/is.js
function isAddress2(address, ignoreChecksum, ss58Format) {
  try {
    return validateAddress(address, ignoreChecksum, ss58Format);
  } catch {
    return false;
  }
}

// src/utils.ts
function isValidAddress(address) {
  return isAddress2(address);
}
function kodaUrl(chain2, collection, token) {
  const base = `https://kodadot.xyz/${chain2}/`;
  const path = token ? `gallery/${collection}-${token}` : `collection/${collection}`;
  return base + path;
}
function hashOf(value) {
  return blake2AsHex(value, 256, null, true);
}

// src/services/mint.ts
init_checked_fetch();
init_modules_watch_stub();
var BASE_URL = "http://localhost:8080";
var doClaim = async (mint, dry = true) => {
  if (dry) {
    return {
      "sn": "151",
      "collection": "107",
      "chain": "ahp",
      "txHash": "0xa478d67d088573c8c81d9cdb8531d5c790f4f001539aa89d62ae7038feb0536b"
    };
  }
  try {
    const res = await fetch(`${BASE_URL}/do`, {
      method: "POST",
      body: JSON.stringify(mint)
    });
    if (!res.ok) {
      return null;
    }
    const value = await res.json();
    return value;
  } catch (error) {
    if (error instanceof FetchError) {
      console.error(error.response);
    }
  }
  return null;
};

// src/routes/poap.tsx
var app = new FrogBase({
  // Supply a Hub API URL to enable frame verification.
  // hubApiUrl: 'https://api.hub.wevm.dev',
  // browserLocation: 'https://kodadot.xyz',
  // basePath: '/poap',
});
app.frame("/", async (c) => {
  const client = getClient("ahp");
  const query2 = client.collectionById("107");
  const collection = await client.fetch(query2).then(
    (x) => x.data.collection
  );
  console.log("collection", collection);
  const image = $purifyOne(collection.image, "kodadot_beta");
  return c.res({
    title: collection.name,
    image,
    intents: [
      /* @__PURE__ */ jsxDEV2(TextInput, { placeholder: "Enter your Polkadot Address..." }),
      /* @__PURE__ */ jsxDEV2(Button, { action: "/poap/submit", value: `ahp/${collection.id}/denver`, children: "Mint" }),
      /* @__PURE__ */ jsxDEV2(Button.Link, { href: "https://kodadot.xyz", children: "kodadot" })
      // <Button.Mint target='polkadot:b0a8d493285c2df73290dfb7e61f870f:5hmuyxw9xdgbpptgypokw4thfyoe3ryenebr381z9iaegmfy'>Mint</Button.Mint>, // Currently not working
    ]
  });
});
app.frame("/submit", async (c) => {
  const { buttonValue, frameData, inputText } = c;
  if (!inputText || !isValidAddress(inputText) || !buttonValue) {
    return c.res({
      image: /* @__PURE__ */ jsxDEV2(
        "div",
        {
          style: {
            height: "100%",
            width: "100%",
            display: "flex",
            flexDirection: "column",
            alignItems: "center",
            justifyContent: "center",
            backgroundColor: "#fff",
            fontSize: 60,
            fontWeight: 600
          },
          children: /* @__PURE__ */ jsxDEV2(
            "div",
            {
              style: {
                backgroundImage: "linear-gradient(90deg, rgb(255, 77, 77), rgb(249, 203, 40))",
                backgroundClip: "text",
                "-webkit-background-clip": "text",
                color: "transparent"
              },
              children: "Supplied address is invalid \u{1F62D}"
            }
          )
        }
      ),
      intents: [
        /* @__PURE__ */ jsxDEV2(Button.Reset, { children: "Try again" }),
        /* @__PURE__ */ jsxDEV2(Button.Link, { href: "https://kodadot.xyz", children: "kodadot" })
      ]
    });
  }
  const [chain2, collection, code] = buttonValue.split("/");
  const mint = await doClaim({
    chain: chain2,
    collection,
    metadata: "",
    address: inputText
  }, true);
  console.log("mint", mint);
  return c.res({
    image: /* @__PURE__ */ jsxDEV2(
      "div",
      {
        style: {
          height: "100%",
          width: "100%",
          display: "flex",
          flexDirection: "column",
          alignItems: "center",
          justifyContent: "center",
          backgroundColor: "#fff",
          fontSize: 60,
          fontWeight: 600
        },
        children: /* @__PURE__ */ jsxDEV2(
          "div",
          {
            style: {
              backgroundImage: "linear-gradient(90deg, rgb(121, 40, 202), rgb(255, 0, 128))",
              backgroundClip: "text",
              "-webkit-background-clip": "text",
              color: "transparent"
            },
            children: "Congrats \u{1F973}"
          }
        )
      }
    ),
    intents: [
      /* @__PURE__ */ jsxDEV2(Button.Reset, { children: "Try again" }),
      /* @__PURE__ */ jsxDEV2(Button.Link, { href: kodaUrl(chain2, collection, mint?.sn), children: "\u{1F5BC}\uFE0F" })
    ]
  });
});

// src/routes/gallery.tsx
init_checked_fetch();
init_modules_watch_stub();

// src/services/uniquery.ts
init_checked_fetch();
init_modules_watch_stub();
async function getCollection(chain2, id2) {
  const client = getClient(chain2);
  const withImage = extendFields(["image", "max", "supply"]);
  const query2 = client.collectionById(id2, withImage);
  console.log(JSON.stringify(query2, null, 2));
  try {
    const result = await client.fetch(query2);
    return result.data?.collection;
  } catch (error) {
    console.error(error);
    return null;
  }
}
async function getItem(chain2, collection, id2) {
  const client = getClient(chain2);
  const final = `${collection}-${id2}`;
  const query2 = client.itemById(final);
  console.log(JSON.stringify(query2, null, 2));
  try {
    const result = await client.fetch(query2);
    return result.data?.item;
  } catch (error) {
    console.error(error);
    return null;
  }
}

// src/routes/gallery.tsx
var app2 = new FrogBase();
async function fetchCollection(chain2, id2) {
  try {
    return await getCollection(chain2, id2);
  } catch (error) {
    console.error(error);
    throw new Error("Failed to fetch collection");
  }
}
async function fetchItem(chain2, collection, id2) {
  try {
    return await getItem(chain2, collection, id2);
  } catch (error) {
    console.error(error);
    throw new Error("Failed to fetch item");
  }
}
app2.frame("/:chain/:id", async (c) => {
  const { chain: chain2, id: id2 } = c.req.param();
  const collection = await fetchCollection(chain2, id2);
  if (!collection || isNaN(collection.max) || collection.max <= 0 || isNaN(collection.supply) || collection.supply <= 0) {
    throw new Error("The collection should have a valid maximum and supply");
  }
  const { image, max: max2, name, supply } = collection;
  const label = `Browse:${name}[${max2}]`;
  return c.res({
    title: name,
    image: $purifyOne(image, "kodadot_beta"),
    intents: [/* @__PURE__ */ jsxDEV2(Button, { action: `/view/${chain2}/${id2}/1`, value: supply, children: label })]
    // Pass supply as value
  });
});
app2.frame("/view/:chain/:id/:curr", async (c) => {
  const { chain: chain2, id: id2, curr } = c.req.param();
  const { buttonValue } = c;
  let max2 = Number(buttonValue);
  const collection = await fetchCollection(chain2, id2);
  if (!collection || isNaN(collection.supply) || collection.supply <= 0) {
    throw new Error("The collection should have a valid supply");
  }
  max2 = Math.max(max2, 1);
  max2 = Math.min(max2, collection.supply);
  const item = await fetchItem(chain2, id2, curr);
  const image = item ? $purifyOne(item.image, "kodadot_beta") : null;
  const random = Math.floor(Math.random() * max2) + 1;
  return c.res({
    image: image || "",
    intents: [
      parseInt(curr) > 1 ? /* @__PURE__ */ jsxDEV2(Button, { value: `${max2}`, action: `/view/${chain2}/${id2}/${parseInt(curr) - 1}/`, children: "\u2B05\uFE0F" }) : null,
      /* @__PURE__ */ jsxDEV2(Button, { value: `${max2}`, action: `/view/${chain2}/${id2}/${parseInt(curr) + 1}/`, children: "\u27A1\uFE0F" }),
      /* @__PURE__ */ jsxDEV2(Button, { action: `/view/${chain2}/${id2}/${random}`, value: `${max2}`, children: "\u{1F3B2}" }),
      /* @__PURE__ */ jsxDEV2(Button.Link, { href: kodaUrl(chain2, id2, curr) || "", children: "\u{1F5BC}\uFE0F" })
    ]
  });
});

// src/routes/genart.tsx
init_checked_fetch();
init_modules_watch_stub();

// src/services/capture.ts
init_checked_fetch();
init_modules_watch_stub();
var BASE_URL2 = "https://capture.kodadot.art";
var api = $fetch.create({
  baseURL: BASE_URL2
});
var doScreenshot = async (url) => {
  try {
    const res = await fetch(`${BASE_URL2}/screenshot`, {
      method: "POST",
      body: JSON.stringify({
        // url: 'https://nftstorage.link/ipfs/bafybeibc4bhdksstboetdg7q7dzzbxl6ynqmhjdifukm3hxirqvebxefea/?hash=0x485978453152395357446f70556b4a50484a4a526966526f4e4d474a375a38465078347932695351577834785a4b38'
        url
      })
    });
    if (!res.ok) {
      return null;
    }
    const buffer = await res.arrayBuffer();
    return buffer;
  } catch (error) {
    if (error instanceof FetchError) {
      console.error(error.response);
    }
  }
  return null;
};

// src/routes/genart.tsx
var app3 = new FrogBase({
  // initialState,
});
app3.frame("/", async (c) => {
  const collection = await getCollection("ahp", "106");
  const image = $purifyOne(collection.image, "kodadot_beta");
  const label = `Generate:${collection.name}`;
  return c.res({
    title: collection.name,
    image,
    intents: [
      /* @__PURE__ */ jsxDEV2(Button, { action: `/genart/view`, children: label })
    ]
  });
});
app3.frame("/view", async (c) => {
  const uri = "ipfs://bafybeiadxh5cyyu25lyg5rxvkr3gpkxbs6xuo3ay47nw3tje4p5e7m7ba4";
  const content = $purifyOne(uri, "kodadot_beta");
  const hash2 = hashOf(Date.now().toString());
  const url = `${content}/?hash=${hash2}`;
  const image = await doScreenshot(url);
  if (!image) {
    return c.res({
      image: /* @__PURE__ */ jsxDEV2(
        "div",
        {
          style: {
            height: "100%",
            width: "100%",
            display: "flex",
            flexDirection: "column",
            alignItems: "center",
            justifyContent: "center",
            backgroundColor: "#fff",
            fontSize: 60,
            fontWeight: 600
          },
          children: /* @__PURE__ */ jsxDEV2(
            "div",
            {
              style: {
                backgroundImage: "linear-gradient(90deg, rgb(255, 77, 77), rgb(249, 203, 40))",
                backgroundClip: "text",
                "-webkit-background-clip": "text",
                color: "transparent"
              },
              children: "Unable to generate \u{1F62D}"
            }
          )
        }
      ),
      intents: [
        /* @__PURE__ */ jsxDEV2(Button.Reset, { children: "Try again" })
      ]
    });
  }
  return c.res({
    image: /* @__PURE__ */ jsxDEV2("img", { src: image }),
    intents: [
      /* @__PURE__ */ jsxDEV2(Button, { children: "Generate" }),
      /* @__PURE__ */ jsxDEV2(Button.Reset, { children: "Reset" })
    ]
  });
});

// src/index.tsx
var app4 = new FrogBase({
  // Supply a Hub API URL to enable frame verification.
  // hubApiUrl: 'https://api.hub.wevm.dev',
  // browserLocation: 'https://kodadot.xyz',
  // basePath: '/poap',
});
app4.use(async (c, next) => {
  console.log("Incoming request:", c.req);
  await next();
  const isFrame = c.res.headers.get("content-type")?.includes("html");
  if (isFrame) {
    let html2 = await c.res.text();
    const metaTag = '<meta property="of:accepts:xmtp" content="2024-02-01" />';
    html2 = html2.replace(/(<head>)/i, `$1${metaTag}`);
    c.res = new Response(html2, {
      headers: {
        "content-type": "text/html"
      }
    });
  }
  console.log("Outgoing response:", c.res);
});
app4.route("/poap", app);
app4.route("/gallery", app2);
app4.route("/genart", app3);
var src_default = app4;

// node_modules/wrangler/templates/middleware/middleware-miniflare3-json-error.ts
init_checked_fetch();
init_modules_watch_stub();
function reduceError(e) {
  return {
    name: e?.name,
    message: e?.message ?? String(e),
    stack: e?.stack,
    cause: e?.cause === void 0 ? void 0 : reduceError(e.cause)
  };
}
var jsonError = async (request, env, _ctx, middlewareCtx) => {
  try {
    return await middlewareCtx.next(request, env);
  } catch (e) {
    const error = reduceError(e);
    return Response.json(error, {
      status: 500,
      headers: { "MF-Experimental-Error-Stack": "true" }
    });
  }
};
var middleware_miniflare3_json_error_default = jsonError;
var wrap3 = void 0;

// .wrangler/tmp/bundle-KhfhM0/middleware-insertion-facade.js
var envWrappers = [wrap3].filter(Boolean);
var facade = {
  ...src_default,
  envWrappers,
  middleware: [
    middleware_miniflare3_json_error_default,
    ...src_default.middleware ? src_default.middleware : []
  ].filter(Boolean)
};
var middleware_insertion_facade_default = facade;

// node_modules/wrangler/templates/middleware/common.ts
init_checked_fetch();
init_modules_watch_stub();
var __facade_middleware__ = [];
function __facade_register__(...args) {
  __facade_middleware__.push(...args.flat());
}
function __facade_invokeChain__(request, env, ctx, dispatch, middlewareChain) {
  const [head, ...tail] = middlewareChain;
  const middlewareCtx = {
    dispatch,
    next(newRequest, newEnv) {
      return __facade_invokeChain__(newRequest, newEnv, ctx, dispatch, tail);
    }
  };
  return head(request, env, ctx, middlewareCtx);
}
function __facade_invoke__(request, env, ctx, dispatch, finalMiddleware) {
  return __facade_invokeChain__(request, env, ctx, dispatch, [
    ...__facade_middleware__,
    finalMiddleware
  ]);
}

// .wrangler/tmp/bundle-KhfhM0/middleware-loader.entry.ts
var __Facade_ScheduledController__ = class {
  constructor(scheduledTime, cron, noRetry) {
    this.scheduledTime = scheduledTime;
    this.cron = cron;
    this.#noRetry = noRetry;
  }
  #noRetry;
  noRetry() {
    if (!(this instanceof __Facade_ScheduledController__)) {
      throw new TypeError("Illegal invocation");
    }
    this.#noRetry();
  }
};
var __facade_modules_fetch__ = function(request, env, ctx) {
  if (middleware_insertion_facade_default.fetch === void 0)
    throw new Error("Handler does not export a fetch() function.");
  return middleware_insertion_facade_default.fetch(request, env, ctx);
};
function getMaskedEnv(rawEnv) {
  let env = rawEnv;
  if (middleware_insertion_facade_default.envWrappers && middleware_insertion_facade_default.envWrappers.length > 0) {
    for (const wrapFn of middleware_insertion_facade_default.envWrappers) {
      env = wrapFn(env);
    }
  }
  return env;
}
var registeredMiddleware = false;
var facade2 = {
  ...middleware_insertion_facade_default.tail && {
    tail: maskHandlerEnv(middleware_insertion_facade_default.tail)
  },
  ...middleware_insertion_facade_default.trace && {
    trace: maskHandlerEnv(middleware_insertion_facade_default.trace)
  },
  ...middleware_insertion_facade_default.scheduled && {
    scheduled: maskHandlerEnv(middleware_insertion_facade_default.scheduled)
  },
  ...middleware_insertion_facade_default.queue && {
    queue: maskHandlerEnv(middleware_insertion_facade_default.queue)
  },
  ...middleware_insertion_facade_default.test && {
    test: maskHandlerEnv(middleware_insertion_facade_default.test)
  },
  ...middleware_insertion_facade_default.email && {
    email: maskHandlerEnv(middleware_insertion_facade_default.email)
  },
  fetch(request, rawEnv, ctx) {
    const env = getMaskedEnv(rawEnv);
    if (middleware_insertion_facade_default.middleware && middleware_insertion_facade_default.middleware.length > 0) {
      if (!registeredMiddleware) {
        registeredMiddleware = true;
        for (const middleware of middleware_insertion_facade_default.middleware) {
          __facade_register__(middleware);
        }
      }
      const __facade_modules_dispatch__ = function(type, init) {
        if (type === "scheduled" && middleware_insertion_facade_default.scheduled !== void 0) {
          const controller = new __Facade_ScheduledController__(
            Date.now(),
            init.cron ?? "",
            () => {
            }
          );
          return middleware_insertion_facade_default.scheduled(controller, env, ctx);
        }
      };
      return __facade_invoke__(
        request,
        env,
        ctx,
        __facade_modules_dispatch__,
        __facade_modules_fetch__
      );
    } else {
      return __facade_modules_fetch__(request, env, ctx);
    }
  }
};
function maskHandlerEnv(handler) {
  return (data, env, ctx) => handler(data, getMaskedEnv(env), ctx);
}
var middleware_loader_entry_default = facade2;
export {
  app4 as app,
  middleware_loader_entry_default as default
};
/*! Bundled license information:

@noble/hashes/esm/utils.js:
  (*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) *)

workers-og/dist/index.js:
  (*! Bundled license information:
  
  css-background-parser/index.js:
    (*!
     * https://github.com/gilmoreorless/css-background-parser
     * Copyright  2015 Gilmore Davidson under the MIT license: http://gilmoreorless.mit-license.org/
     *)
  
  parse-css-color/dist/index.umd.js:
    (**
    	 * parse-css-color
    	 * @version v0.2.1
    	 * @link http://github.com/noeldelgado/parse-css-color/
    	 * @license MIT
    	 *)
  
  escape-html/index.js:
    (*!
     * escape-html
     * Copyright(c) 2012-2013 TJ Holowaychuk
     * Copyright(c) 2015 Andreas Lubbe
     * Copyright(c) 2015 Tiancheng "Timothy" Gu
     * MIT Licensed
     *)
  *)

@scure/base/lib/esm/index.js:
  (*! scure-base - MIT License (c) 2022 Paul Miller (paulmillr.com) *)

@noble/hashes/esm/utils.js:
  (*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) *)
*/
//# sourceMappingURL=index.js.map
